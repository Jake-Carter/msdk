{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Analog Devices MSDK Documentation Welcome to the MSDK Documentation. The Maxim Microcontrollers SDK (MSDK), now a part of Analog Devices , contains the necessary software and tools to develop firmware for the MAX32xxx and MAX78xxx Microcontrollers . To get started see the User Guide . For development resources : Github Contributing","title":"Home"},{"location":"#analog-devices-msdk-documentation","text":"Welcome to the MSDK Documentation. The Maxim Microcontrollers SDK (MSDK), now a part of Analog Devices , contains the necessary software and tools to develop firmware for the MAX32xxx and MAX78xxx Microcontrollers . To get started see the User Guide . For development resources : Github Contributing","title":"Analog Devices MSDK Documentation"},{"location":"CONTRIBUTING/","text":"Analog Devices MSDK Development and Contribution Guidelines Development Flow Development for the MSDK also follows the official GitHub development flow guidelines . For beginners, learngitbranching.js.org is a great hands-on starting resource. Contribution Guidelines The MSDK follows the GitHub contribution guidelines . External contributions from outside the Analog Devices organization should be made via a Pull Request opened from a fork. Internal contributions should also preferrably use a fork where possible. If a direct branch on the mainline MSDK repo is made, the following branch naming conventions should be used when possible: Bugfix/ticket: fix/ticketnumber New feature: feature/branchname Generic development branch: dev/branchname New and/or modified example branch: example/branchname Style Guide The MSDK code-base, for the most-part, follows the Linux Kernel coding style and Google's C++ Style Guide with the following exception(s): Indentations are 4 spaces. Formatting and styling is enforced via clang-format version 14 and cpplint , which automatically run checks against all PRs. A PR cannot be merged until it passes these checks. Running the Linter & Formatter Both utilities can be run locally. cpplint should be run first, then clang-format. Additionally, both should be run from the root directory of the MSDK repo so that their config files are loaded properly. clang-format rules are loaded from the .clang-format and cpplint rules are loaded from CPPLINT.cfg in the root directory of the repo. As a result, the utilities must also be run from the root directory of the repo. cpplint cpplint enforces good code practices by scanning for common mistakes and ensuring certain higher-level code patterns are followed. It's a good idea to resolve the errors found by cpplint before before running clang-format, which deals with lower-level code styling and syntax patterns. cd into the root directory of the MSDK repo. Run cpplint. To run cpplint on a file , use cpplint <filepath> . $ cpplint Examples/MAX78000/Hello_World/main.c Done processing Examples/MAX78000/Hello_World/main.c To recursively run cpplint on an entire directory , use cpplint --recursive <filepath> . $ cpplint --recursive Examples/MAX78000 Examples/MAX78000/ADC/example_config.h:1: #ifndef header guard has wrong style, please use: EXAMPLES_MAX78000_ADC_EXAMPLE_CONFIG_H_ [build/header_guard] [5] Examples/MAX78000/ADC/example_config.h:14: #endif line should be \"#endif // EXAMPLES_MAX78000_ADC_EXAMPLE_CONFIG_H_\" [build/header_guard] [5] Done processing Examples/MAX78000/ADC/example_config.h Done processing Examples/MAX78000/ADC/main.c Done processing Examples/MAX78000/AES/main.c Done processing Examples/MAX78000/ARM-DSP/arm_bayes_example/arm_bayes_example_f32.c ... Resolve any errors. git add and git commit any changes to your code. clang-format clang-format is a code formatter and style checker that enforces a common style for the code-base. The MSDK uses version 14 , which is sometimes not available by default on some Linux distributions. It can be retrieved from https://apt.llvm.org/ . cd into the root directory of the MSDK repo. Run clang-format. To run a clang-format check on a file, use the -n \"dry-run\" flag. clang-format-14 --style=file --Werror --verbose -n <filename> For example: $ clang-format-14 --style=file --Werror --verbose -n Examples/MAX78000/CRC/main.c Formatting [1/1] Examples/MAX78000/CRC/main.c Examples/MAX78000/CRC/main.c:86:40: error: code should be clang-formatted [-Wclang-format-violations] for (i = 0; i < DATA_LENGTH; i++) { array[i] = i; } ^ To apply the formatter to automatically format a file, use the -i flag. clang-format-14 --style=file --Werror --verbose -i <filename> For example: $ clang-format-14 --style=file --verbose -i Examples/MAX78000/CRC/main.c Formatting [1/1] Examples/MAX78000/CRC/main.c This will apply the formatter and overwrite the file. Check the formatter's work using git diff . $ diff --git a/Examples/MAX78000/CRC/main.c b/Examples/MAX78000/CRC/main.c index 1dda1feed..c16ceb962 100644 --- a/Examples/MAX78000/CRC/main.c +++ b/Examples/MAX78000/CRC/main.c @@ -83,7 +83,9 @@ void Test_CRC(int asynchronous) printf(asynchronous ? \"TEST CRC ASYNC\\n\" : \"TEST CRC SYNC\\n\"); - for (i = 0; i < DATA_LENGTH; i++) { array[i] = i; } + for (i = 0; i < DATA_LENGTH; i++) { + array[i] = i; + } To apply the formatter to multiple files, the * and ** wildcard characters can be used. * matches any file or folder, and ** recursively matches any file or folder. To recursively run clang-format on all C files in an entire directory, use: clang-format-14 --style=file --verbose -n <filepath>/**/*.c . For example: $ clang-format-14 --style=file --verbose -i Examples/MAX78000/ARM-DSP/**/*.c Formatting [1/24] Examples/MAX78000/ARM-DSP/arm_bayes_example/arm_bayes_example_f32.c Formatting [2/24] Examples/MAX78000/ARM-DSP/arm_class_marks_example/arm_class_marks_example_f32.c Formatting [3/24] Examples/MAX78000/ARM-DSP/arm_convolution_example/arm_convolution_example_f32.c Formatting [4/24] Examples/MAX78000/ARM-DSP/arm_convolution_example/math_helper.c Formatting [5/24] Examples/MAX78000/ARM-DSP/arm_dotproduct_example_f32/arm_dotproduct_example_f32.c ... ... which runs the formatter for all C files in the Examples/MAX78000/ARM-DSP directory and all its subdirectories . It should be noted that ** is not supported on native Windows, but * is. git add and git commit any changes to your code. Now, it's ready for a PR! The same checks will be automatically run against any PRs that are opened in the MSDK, and they must pass before the code can be approved. Contributing Examples First, ensure that the example project has been linted and formatted to follow the Style Guide Copy the example project into the Examples folder of the SDK for the applicable target microcontrollers. git add and git commit the Example project. Commit your project files before running MSDKGen. Run the MSDKGen utility to ensure the example project's support files are updated to the latest version. python msdkgen.py update-all --projects yourprojectname --overwrite Re-test the project if applicable. If the updated files break any projects they can be restored to the previously working version using the git restore command. For example, the command below will restore all files in your current working directory. git restore ** The git diff command can also be used to inspect local changes to help identify the root cause. Ex: git diff ./ Contributing Libraries Libraries should be added to the Libraries sub-folder of the MSDK. All libraries should include a libraryname.mk file that can be added to Libraries/libs.mk via a toggle-switch. The filename should match the name of library as closely as possible, and expose any required configuration variables . If necessary, a library may also include a \"core\" Makefile or set of Makefiles to build it as a standalone static library file. The naming convention is lib<libraryname>.a . Self-Locating Makefile The first thing that the libraryname.mk file should do is locate its own directory and store it in a variable. The code snippet can be used to achieve this. ifeq \"$(LIBRARYNAME_DIR)\" \"\" # If LIBRARYNAME_DIR is not specified, this Makefile will locate itself. LIBRARYNAME_DIR := $(dir $(abspath $(lastword $(MAKEFILE_LIST)))) endif All filepaths for the library should then use this $(LIBRARYNAME_DIR) -type variable as their \"root\" for all filepaths. This is a safe and reliable way to self-reference internal library files. For an example, see the Libraries/PeriphDrivers/periphdriver.mk file. Simple Libraries For simple libraries, it may be sufficient to just add the library's source files to the build using VPATH and IPATH . For example: IPATH += $(LIBRARY_NAME_DIR)/include VPATH += $(LIBRARY_NAME_DIR)/src SRCS += libfile1.c SRCS += libfile2.c An example of this is MiscDrivers , which is a simple source-file-only library. It gets its source code selectively added to the build via Libraries/Boards/MAX78000/EvKit_V1/board.mk files. Advanced Libraries More advanced libraries (including those with a large number of source files) should include a rule to build as a static library file with a recursive Make call . This type of library should also set up the appropriate configuration variables to include that static library to the build. Contributing Documentation Code Maintainers MSDK code should be documented using Doxygen syntax on all public functions, data structures, and variables. See the DoxyGen Manual for more details on syntax for C-like languages. DoxyGen is automatically run across the MSDK code as part of the User Guide's build process. A Peripheral API reference is generated for each target microcontroller using the Doxygen files located in Libraries/PeriphDrivers/Documentation , and the output is packaged as a sub-component of the User Guide when it's built. For code maintainers no action is needed other than maintaining up to date Doxygen documentation for all source code. User Guide An MSDK User Guide is maintained in the USERUIDE.md file. This document contains higher-level usage info for the MSDK. If a part, IDE, or library is supported by the MSDK then there should be some relevant info in the User Guide covering its setup, configuration, and usage. When writing markdown links, relative paths should always be used. Additionally, links to local files on the user's filesystem cannot be used, since the online copy of the docs will throw a 404 on them. See Writing Your Docs for more details. Static resources such as images should be placed in the res folder. Building the Documentation Local Builds The Documentation/build.py script can be used to build the MSDK User Guide and supporting documentation locally. This script: Builds all the Peripheral API references using Doxygen and copies them into Documentation Copies any markdown (.md) files from the root of the repo into Documentation Builds the MSDK User Guide using Mkdocs , which packages everything in Documentation into a static HTML/CSS/JavaScript site in the docs folder. To build the docs: Install doxygen Install Python 3 pip install -r Documentation/requirements.txt python Documentation/build.py The site will be built in the docs folder of the repo. To preview the generated site: mkdocs serve This will open a localhost test server with live re-loading. To configure the generated site, use mkdocs.yml . See Mkdocs Configuration for more details. Auto Builds and Deployment The \"Build & Deploy Docs\" Github Action will perform all the local steps above. Additionally, it will deploy the static site to the gh-pages branch of the repository for use with Github Pages . When the gh-pages branch is updated, Pages will refresh the online copy of the documentation within ~5-10 mins. This auto-deploy procedure is triggered on every push to the release branch.","title":"Contributing"},{"location":"CONTRIBUTING/#analog-devices-msdk-development-and-contribution-guidelines","text":"","title":"Analog Devices MSDK Development and Contribution Guidelines"},{"location":"CONTRIBUTING/#development-flow","text":"Development for the MSDK also follows the official GitHub development flow guidelines . For beginners, learngitbranching.js.org is a great hands-on starting resource.","title":"Development Flow"},{"location":"CONTRIBUTING/#contribution-guidelines","text":"The MSDK follows the GitHub contribution guidelines . External contributions from outside the Analog Devices organization should be made via a Pull Request opened from a fork. Internal contributions should also preferrably use a fork where possible. If a direct branch on the mainline MSDK repo is made, the following branch naming conventions should be used when possible: Bugfix/ticket: fix/ticketnumber New feature: feature/branchname Generic development branch: dev/branchname New and/or modified example branch: example/branchname","title":"Contribution Guidelines"},{"location":"CONTRIBUTING/#style-guide","text":"The MSDK code-base, for the most-part, follows the Linux Kernel coding style and Google's C++ Style Guide with the following exception(s): Indentations are 4 spaces. Formatting and styling is enforced via clang-format version 14 and cpplint , which automatically run checks against all PRs. A PR cannot be merged until it passes these checks.","title":"Style Guide"},{"location":"CONTRIBUTING/#running-the-linter-formatter","text":"Both utilities can be run locally. cpplint should be run first, then clang-format. Additionally, both should be run from the root directory of the MSDK repo so that their config files are loaded properly. clang-format rules are loaded from the .clang-format and cpplint rules are loaded from CPPLINT.cfg in the root directory of the repo. As a result, the utilities must also be run from the root directory of the repo.","title":"Running the Linter &amp; Formatter"},{"location":"CONTRIBUTING/#cpplint","text":"cpplint enforces good code practices by scanning for common mistakes and ensuring certain higher-level code patterns are followed. It's a good idea to resolve the errors found by cpplint before before running clang-format, which deals with lower-level code styling and syntax patterns. cd into the root directory of the MSDK repo. Run cpplint. To run cpplint on a file , use cpplint <filepath> . $ cpplint Examples/MAX78000/Hello_World/main.c Done processing Examples/MAX78000/Hello_World/main.c To recursively run cpplint on an entire directory , use cpplint --recursive <filepath> . $ cpplint --recursive Examples/MAX78000 Examples/MAX78000/ADC/example_config.h:1: #ifndef header guard has wrong style, please use: EXAMPLES_MAX78000_ADC_EXAMPLE_CONFIG_H_ [build/header_guard] [5] Examples/MAX78000/ADC/example_config.h:14: #endif line should be \"#endif // EXAMPLES_MAX78000_ADC_EXAMPLE_CONFIG_H_\" [build/header_guard] [5] Done processing Examples/MAX78000/ADC/example_config.h Done processing Examples/MAX78000/ADC/main.c Done processing Examples/MAX78000/AES/main.c Done processing Examples/MAX78000/ARM-DSP/arm_bayes_example/arm_bayes_example_f32.c ... Resolve any errors. git add and git commit any changes to your code.","title":"cpplint"},{"location":"CONTRIBUTING/#clang-format","text":"clang-format is a code formatter and style checker that enforces a common style for the code-base. The MSDK uses version 14 , which is sometimes not available by default on some Linux distributions. It can be retrieved from https://apt.llvm.org/ . cd into the root directory of the MSDK repo. Run clang-format. To run a clang-format check on a file, use the -n \"dry-run\" flag. clang-format-14 --style=file --Werror --verbose -n <filename> For example: $ clang-format-14 --style=file --Werror --verbose -n Examples/MAX78000/CRC/main.c Formatting [1/1] Examples/MAX78000/CRC/main.c Examples/MAX78000/CRC/main.c:86:40: error: code should be clang-formatted [-Wclang-format-violations] for (i = 0; i < DATA_LENGTH; i++) { array[i] = i; } ^ To apply the formatter to automatically format a file, use the -i flag. clang-format-14 --style=file --Werror --verbose -i <filename> For example: $ clang-format-14 --style=file --verbose -i Examples/MAX78000/CRC/main.c Formatting [1/1] Examples/MAX78000/CRC/main.c This will apply the formatter and overwrite the file. Check the formatter's work using git diff . $ diff --git a/Examples/MAX78000/CRC/main.c b/Examples/MAX78000/CRC/main.c index 1dda1feed..c16ceb962 100644 --- a/Examples/MAX78000/CRC/main.c +++ b/Examples/MAX78000/CRC/main.c @@ -83,7 +83,9 @@ void Test_CRC(int asynchronous) printf(asynchronous ? \"TEST CRC ASYNC\\n\" : \"TEST CRC SYNC\\n\"); - for (i = 0; i < DATA_LENGTH; i++) { array[i] = i; } + for (i = 0; i < DATA_LENGTH; i++) { + array[i] = i; + } To apply the formatter to multiple files, the * and ** wildcard characters can be used. * matches any file or folder, and ** recursively matches any file or folder. To recursively run clang-format on all C files in an entire directory, use: clang-format-14 --style=file --verbose -n <filepath>/**/*.c . For example: $ clang-format-14 --style=file --verbose -i Examples/MAX78000/ARM-DSP/**/*.c Formatting [1/24] Examples/MAX78000/ARM-DSP/arm_bayes_example/arm_bayes_example_f32.c Formatting [2/24] Examples/MAX78000/ARM-DSP/arm_class_marks_example/arm_class_marks_example_f32.c Formatting [3/24] Examples/MAX78000/ARM-DSP/arm_convolution_example/arm_convolution_example_f32.c Formatting [4/24] Examples/MAX78000/ARM-DSP/arm_convolution_example/math_helper.c Formatting [5/24] Examples/MAX78000/ARM-DSP/arm_dotproduct_example_f32/arm_dotproduct_example_f32.c ... ... which runs the formatter for all C files in the Examples/MAX78000/ARM-DSP directory and all its subdirectories . It should be noted that ** is not supported on native Windows, but * is. git add and git commit any changes to your code. Now, it's ready for a PR! The same checks will be automatically run against any PRs that are opened in the MSDK, and they must pass before the code can be approved.","title":"clang-format"},{"location":"CONTRIBUTING/#contributing-examples","text":"First, ensure that the example project has been linted and formatted to follow the Style Guide Copy the example project into the Examples folder of the SDK for the applicable target microcontrollers. git add and git commit the Example project. Commit your project files before running MSDKGen. Run the MSDKGen utility to ensure the example project's support files are updated to the latest version. python msdkgen.py update-all --projects yourprojectname --overwrite Re-test the project if applicable. If the updated files break any projects they can be restored to the previously working version using the git restore command. For example, the command below will restore all files in your current working directory. git restore ** The git diff command can also be used to inspect local changes to help identify the root cause. Ex: git diff ./","title":"Contributing Examples"},{"location":"CONTRIBUTING/#contributing-libraries","text":"Libraries should be added to the Libraries sub-folder of the MSDK. All libraries should include a libraryname.mk file that can be added to Libraries/libs.mk via a toggle-switch. The filename should match the name of library as closely as possible, and expose any required configuration variables . If necessary, a library may also include a \"core\" Makefile or set of Makefiles to build it as a standalone static library file. The naming convention is lib<libraryname>.a .","title":"Contributing Libraries"},{"location":"CONTRIBUTING/#self-locating-makefile","text":"The first thing that the libraryname.mk file should do is locate its own directory and store it in a variable. The code snippet can be used to achieve this. ifeq \"$(LIBRARYNAME_DIR)\" \"\" # If LIBRARYNAME_DIR is not specified, this Makefile will locate itself. LIBRARYNAME_DIR := $(dir $(abspath $(lastword $(MAKEFILE_LIST)))) endif All filepaths for the library should then use this $(LIBRARYNAME_DIR) -type variable as their \"root\" for all filepaths. This is a safe and reliable way to self-reference internal library files. For an example, see the Libraries/PeriphDrivers/periphdriver.mk file.","title":"Self-Locating Makefile"},{"location":"CONTRIBUTING/#simple-libraries","text":"For simple libraries, it may be sufficient to just add the library's source files to the build using VPATH and IPATH . For example: IPATH += $(LIBRARY_NAME_DIR)/include VPATH += $(LIBRARY_NAME_DIR)/src SRCS += libfile1.c SRCS += libfile2.c An example of this is MiscDrivers , which is a simple source-file-only library. It gets its source code selectively added to the build via Libraries/Boards/MAX78000/EvKit_V1/board.mk files.","title":"Simple Libraries"},{"location":"CONTRIBUTING/#advanced-libraries","text":"More advanced libraries (including those with a large number of source files) should include a rule to build as a static library file with a recursive Make call . This type of library should also set up the appropriate configuration variables to include that static library to the build.","title":"Advanced Libraries"},{"location":"CONTRIBUTING/#contributing-documentation","text":"","title":"Contributing Documentation"},{"location":"CONTRIBUTING/#code-maintainers","text":"MSDK code should be documented using Doxygen syntax on all public functions, data structures, and variables. See the DoxyGen Manual for more details on syntax for C-like languages. DoxyGen is automatically run across the MSDK code as part of the User Guide's build process. A Peripheral API reference is generated for each target microcontroller using the Doxygen files located in Libraries/PeriphDrivers/Documentation , and the output is packaged as a sub-component of the User Guide when it's built. For code maintainers no action is needed other than maintaining up to date Doxygen documentation for all source code.","title":"Code Maintainers"},{"location":"CONTRIBUTING/#user-guide","text":"An MSDK User Guide is maintained in the USERUIDE.md file. This document contains higher-level usage info for the MSDK. If a part, IDE, or library is supported by the MSDK then there should be some relevant info in the User Guide covering its setup, configuration, and usage. When writing markdown links, relative paths should always be used. Additionally, links to local files on the user's filesystem cannot be used, since the online copy of the docs will throw a 404 on them. See Writing Your Docs for more details. Static resources such as images should be placed in the res folder.","title":"User Guide"},{"location":"CONTRIBUTING/#building-the-documentation","text":"","title":"Building the Documentation"},{"location":"CONTRIBUTING/#local-builds","text":"The Documentation/build.py script can be used to build the MSDK User Guide and supporting documentation locally. This script: Builds all the Peripheral API references using Doxygen and copies them into Documentation Copies any markdown (.md) files from the root of the repo into Documentation Builds the MSDK User Guide using Mkdocs , which packages everything in Documentation into a static HTML/CSS/JavaScript site in the docs folder. To build the docs: Install doxygen Install Python 3 pip install -r Documentation/requirements.txt python Documentation/build.py The site will be built in the docs folder of the repo. To preview the generated site: mkdocs serve This will open a localhost test server with live re-loading. To configure the generated site, use mkdocs.yml . See Mkdocs Configuration for more details.","title":"Local Builds"},{"location":"CONTRIBUTING/#auto-builds-and-deployment","text":"The \"Build & Deploy Docs\" Github Action will perform all the local steps above. Additionally, it will deploy the static site to the gh-pages branch of the repository for use with Github Pages . When the gh-pages branch is updated, Pages will refresh the online copy of the documentation within ~5-10 mins. This auto-deploy procedure is triggered on every push to the release branch.","title":"Auto Builds and Deployment"},{"location":"LICENSE/","text":"Copyright (C) Maxim Integrated Products, Inc., All rights Reserved. This software is protected by copyright laws of the United States and of foreign countries. This material may also be protected by patent laws and technology transfer regulations of the United States and of foreign countries. This software is furnished under a license agreement and/or a nondisclosure agreement and may only be used or reproduced in accordance with the terms of those agreements. Dissemination of this information to any party or parties not specified in the license agreement and/or nondisclosure agreement is expressly prohibited. The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL MAXIM INTEGRATED BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. Except as contained in this notice, the name of Maxim Integrated Products, Inc. shall not be used except as stated in the Maxim Integrated Products, Inc. Branding Policy. The mere transfer of this software does not imply any licenses of trade secrets, proprietary technology, copyrights, patents, trademarks, maskwork rights, or any other form of intellectual property whatsoever. Maxim Integrated Products, Inc. retains all ownership rights.","title":"License"},{"location":"USERGUIDE/","text":"MSDK User Guide MSDK User Guide Overview Supported Operating Systems Supported Parts Supported Development Environments Supported Languages Installation Prerequisites Download Setup Completing the Installation on MacOS Maintenance Updates Older Versions and Offline Installer Development Resources Getting Started Key Concepts Getting Started with Visual Studio Code Setup (VS Code) Building and Running a Project (VS Code) Getting Started with Eclipse Setup (Eclipse) Building and Running a Project (Eclipse) Getting Started with Command-Line Development Setup (Command-Line) Windows Linux/MacOS Verification Building and Running an Example (Command-Line) Visual Studio Code Opening Example Projects How to Set the BSP (VS Code) Building a Project Cleaning a Project Flashing and Debugging Arm Core Debugging Breakpoints Peripheral Browsing Dual Core Debugging Eclipse Running Eclipse Creating a New Project Importing Examples How to Set the BSP (Eclipse) Building a Project Flashing and Debugging Segger J-Link Setup Guide (Eclipse) Keil MDK IAR Embedded Workbench Command-Line Development How to Set the BSP (Command-Line) Building on the Command-Line Cleaning on the Command-Line Flashing on the Command-Line Debugging on the Command-Line Common GDB Commands Board Support Packages How to Set the BSP BSP Table Custom BSPs Disabling BSPs Build System Build System Overview Default Build Behavior Build Configuration Variables How to Set a Build Configuration Variable Where to Set a Build Configuration Variable Precedence Hierarchy Build Configuration Variables Reference Table Peripheral Driver API Organization Examples Libraries CMSIS-DSP CMSIS-DSP Supported Parts Cordio Bluetooth Low Energy Cordio Supported Parts MAXUSB MAXUSB Supported Parts Miscellaneous Drivers SDHC SDHC Supported Parts FreeRTOS FreeRTOS Supported Parts FreeRTOS-Plus Overview The Maxim Microcontrollers SDK (MSDK), now a part of Analog Devices , contains the necessary software and tools to develop firmware for the MAX32xxx and MAX78xxx Microcontrollers . That includes register and system startup files to enable low-level development for its supported parts . It also provides higher-level peripheral driver APIs (written in C) alongside various utilities, third-party libraries, Board Support Packages (BSPs), and a set of example programs for each microcontroller. Additionally, the MSDK includes a GCC-based toolchain, and builds are managed by a system of Makefiles (See GNU Make ). A custom fork of OpenOCD enables flashing and debugging. The MSDK's toolchain and build system offers a Command Line Interface (CLI), and project files for supported development environments are maintained that build on top of that CLI. This document describes the MSDK's installation, setup, and usage. Supported Operating Systems Windows (Windows 10 only) Linux (Ubuntu only) MacOS Supported Parts The MSDK officially supports the following microcontrollers and evaluation platforms. MAX32520 : ChipDNA Secure Microcontroller with Secure Boot for IoT Applications MAX32520-KIT MAX32520FTHR MAX32570 : Low-Power Arm Cortex-M4 Microcontroller with Contactless Radio for Secure Applications (Available by NDA only ) MAX32570-QNKIT MAX32570-MNKIT MAX32572 (Not Yet Publicly Available) MAX32572EVKIT (Not Yet Publicly Available) MAX32650 : Ultra-Low-Power Arm Cortex-M4 with FPU-Based Microcontroller (MCU) with 3MB Flash and 1MB SRAM MAX32650-EVKIT MAX32650FTHR MAX32651 : Ultra-Low-Power Arm Cortex-M4 with FPU-Based Microcontroller (MCU) with 3MB Flash and 1MB SRAM MAX32651-EVKIT MAX32655 : Low-Power, Arm Cortex-M4 Processor with FPU-Based Microcontroller and Bluetooth 5.2 MAX32655EVKIT MAX32655FTHR MAX32660 : Tiny, Ultra-Low-Power Arm Cortex-M4 Processor with FPU-Based Microcontroller (MCU) with 256KB Flash and 96KB SRAM MAX32660-EVSYS MAX32662 (Not Yet Publicly Available) MAX32662EVKIT (Not Yet Publicly Available) MAX32665-MAX32666 Family : Low-Power Arm Cortex-M4 with FPU-Based Microcontroller with Bluetooth 5 for Wearables MAX32666EVKIT MAX32666FTHR MAX32666FTHR2 (Product Page Not Yet Available) MAX32670 : High-Reliability, Ultra-Low-Power Microcontroller Powered by Arm Cortex-M4 Processor with FPU for Industrial and IoT MAX32670EVKIT MAX32672 : High-Reliability, Tiny, Ultra-Low-Power Arm Cortex-M4F Microcontroller with 12-Bit 1MSPS ADC MAX32672EVKIT MAX32675 : Ultra-Low-Power Arm Cortex-M4F with Precision Analog Front-End for Industrial and Medical Sensors MAX32675EVKIT MAX32675FTHR (Product Page Not Yet Available) MAX32680 : Ultra-Low-Power Arm Cortex-M4F with Precision Analog Front-End and Bluetooth LE 5.2 MAX32680EVKIT MAX32690 : Arm Cortex-M4 with FPU Microcontroller and Bluetooth LE 5 for Industrial and Wearables MAX32690EVKIT (Product Page Not Yet Available) MAX78000 : Artificial Intelligence Microcontroller with Ultra-Low-Power Convolutional Neural Network Accelerator MAX78000EVKIT MAX78000FTHR MAXREFDES178 MAX78002 : Artificial Intelligence Microcontroller with Low-Power Convolutional Neural Network Accelerator MAX78002EVKIT Supported Development Environments Visual Studio Code Eclipse IDE IAR Embedded Workbench Keil MDK Command-line Development Supported shells (Windows): MSYS2 Supported shells (Ubuntu and MacOS): Bash Zsh Supported Languages C Assembly (Arm and/or RISC-V instruction set depending on the microcontroller) Installation Prerequisites Administrator rights (On MacOS) - Homebrew Download The MSDK installer is available for supported Operating Systems from the download links below. Windows 10 Linux (Ubuntu) This file must be made executable before running ( chmod +x MaximMicrosSDK_linux.run ). Alternatively, set `Allow executing as program\" in the Ubuntu GUI. MacOS On MacOS, the installer is distributed inside a .dmg disk image file. Double-click the downloaded file to mount it. Afterward, the installer executable will be made available inside the mounted drive. Setup Download the installer executable to an accessible location and launch it. Click Next to proceed from the Welcome screen. Choose the installation location. Select the components to install. It's recommended to install all components. Continue to the installation page, and click install to begin. Installation can be safely canceled at any time. Click Finish to complete the installation. You should now see the contents of the installation directory populated with the MSDK. Note: On MacOS, some additional steps are required. Completing the Installation on MacOS On MacOS, some additional missing packages must be manually installed with Homebrew . For non-M1 platforms: Follow the instructions on the Homebrew home page to install Homebrew on your system. Then, open a terminal and run the command brew install make libusb-compat libftdi hidapi libusb The MSDK toolchain is dependent on GNU make 4.x+ being available as make , but Homebrew will install it as gmake . Modify your shell's startup script to account for this. Run brew info make for more details, and check the \"caveats\" section. ==> make: stable 4.4.1 (bottled) Utility for directing compilation https://www.gnu.org/software/make/ /usr/local/Cellar/make/4.4.1 (16 files, 1.3MB) * Poured from bottle using the formulae.brew.sh API on 2023-03-28 at 17:46:43 From: https://github.com/Homebrew/homebrew-core/blob/HEAD/Formula/make.rb License: GPL-3.0-only ==> Dependencies Build: lzip, lzip ==> Caveats GNU \"make\" has been installed as \"gmake\". If you need to use it as \"make\", you can add a \"gnubin\" directory to your PATH from your bashrc like: PATH=\"/usr/local/opt/make/libexec/gnubin:$PATH\" ==> Analytics install: 549 (30 days), 30,768 (90 days), 164,034 (365 days) install-on-request: 405 (30 days), 19,728 (90 days), 109,440 (365 days) build-error: 0 (30 days) Typically, this involves adding the following line to your shell's startup script ( ~/.zshrc , ~/.bashrc , etc.) PATH=\"/usr/local/opt/make/libexec/gnubin:$PATH\" Restart your shell and verify that make --version returns 4.x+. For M1 platforms : The MSDK's OpenOCD binaries ship pre-compiled for Intel Silicon (i386). As a result, you should use a Rosetta terminal on M1 platforms to install the i386 version of Homebrew and retrieve OpenOCD's dependencies with it. Installing from Rosetta ensures OpenOCD gets the packages with the architecture it needs. From there, Rosetta will handle the rest and allow running the binaries on the M1 platform's arm64 architecture. Additionally, the MSDK toolchain requires Make 4.x+, which must also be retrieved via Homebrew. The i386 version of Homebrew can be installed in parallel with the arm64 version and typically installs into a separate filesystem. Open a terminal and update Rosetta. softwareupdate --install-rosetta --agree-to-license Close the terminal. Create a new Rosetta terminal: Launch Finder. Navigate to Applications and find the \"Terminal\" application. Right-Click Terminal and Duplicate it. Rename it to \"Terminal i386\". This will be a new application shortcut to the Rosetta terminal. Right-Click \"Terminal i386\" > Get Info > Enable \"Open using Rosetta\" Launch the new \"Terminal i386\" and type arch to verify that it says i386 now. From your Rosetta terminal, follow the instructions on the Homebrew home page to install Homebrew on your system. Verify the correct version of Homebrew is running from your Rosetta terminal using the which brew command. This command should return a path beginning with /usr/local . Note: On systems with multiple or pre-existing Homebrew installations, the arm64 version of Homebrew may still take precedence over the newly installed x86_64 version. If which brew contains /opt/homebrew instead, you may need to edit your terminal profile's startup script. Alternatively, you can directly run the correct Homebrew binary using its absolute path. Run the command brew install make libusb-compat libftdi hidapi libusb (or, if you need to use the absolute path) /usr/local/homebrew/bin/brew make install libusb-compat libftdi hidapi libusb The MSDK toolchain is dependent on GNU make 4.x+ being available as make , but Homebrew will install it as gmake . Modify your shell's startup script to account for this. Run brew info make for more details, and check the \"caveats\" section. ==> make: stable 4.4.1 (bottled) Utility for directing compilation https://www.gnu.org/software/make/ /usr/local/Cellar/make/4.4.1 (16 files, 1.3MB) * Poured from bottle using the formulae.brew.sh API on 2023-03-28 at 17:46:43 From: https://github.com/Homebrew/homebrew-core/blob/HEAD/Formula/make.rb License: GPL-3.0-only ==> Dependencies Build: lzip, lzip ==> Caveats GNU \"make\" has been installed as \"gmake\". If you need to use it as \"make\", you can add a \"gnubin\" directory to your PATH from your bashrc like: PATH=\"/usr/local/opt/make/libexec/gnubin:$PATH\" ==> Analytics install: 549 (30 days), 30,768 (90 days), 164,034 (365 days) install-on-request: 405 (30 days), 19,728 (90 days), 109,440 (365 days) build-error: 0 (30 days) Typically, this involves adding the following line to your shell's startup script ( ~/.zshrc , ~/.bashrc , etc.) PATH=\"/usr/local/opt/make/libexec/gnubin:$PATH\" Restart your shell and verify that make --version returns 4.x+. Maintenance An MSDK installation contains a MaintenanceTool executable program in its root directory. Use the Maintenance Tool to retrieve updates, manage components, and uninstall the MSDK. Updates The MSDK releases updates quarterly, and the Maintenance Tool will retrieve the latest release when Update components is run. Older Versions and Offline Installer Older versions of the MSDK are available as an offline installer for each release tag. They are available on the Releases page of the MSDK GitHub and can be used to roll back to a specific MSDK release. Development Resources Users can obtain development copies of the MSDK resources from Github . Setup instructions can be found in the repository's README . Getting Started The MSDK is designed for both evaluation and end-application development. The typical evaluation cycle usually involves setting up the development environment, running demos, and exercising the peripheral driver API on an evaluation platform . The typical development cycle typically involves building a prototype application on an evaluation platform first, then porting the application to a custom board. This section describes how to get started with the MSDK focusing on the evaluation cycle. First , review the Key Concepts below. Then, proceed to the section for your preferred IDE. Each sub-section is written as a self-contained quick-start with links to additional documentation on important topics. Getting Started with Visual Studio Code Getting Started with Eclipse Getting Started with Command-Line Development Key Concepts The MSDK supports multiple development environments with different features that may tailor to the user's preferences. There are a few key concepts to remember that are universal to MSDK development. Target Microcontroller : The target microcontroller refers to the base part number of the microcontroller used for development. The MSDK contains register-level support and startup files for each of its supported parts , and it's important to note that support files for a target microcontroller and its Board Support Packages are distinct from each other. For example, if the MAX78000EVKIT or MAX78000FTHR is being used, the Target Microcontroller is the MAX78000. Board Support Package (BSP) : The MSDK supports evaluation platforms for target microcontrollers with Board Support Packages . For microcontrollers with multiple evaluation platforms, multiple BSPs are available. These can be found in the Libraries/Boards folder of the MSDK installation. By default, most projects in the MSDK come pre-configured for the \"EVKIT\"-type BSP, which is generally the largest evaluation platform for that device with most (or all) pins broken out. It's important to note that the active BSP may need to be reconfigured for a project, which is done slightly differently for each development environment. System Environment : Your system's environment is a broad term that encapsulates the programs and variables available to your system's shell on the command line. The user is expected to have some basic familiarity with this concept. System Path : Your system's Path is a unique environment variable that tells it where to search for program binaries. The user is expected to be familiar with this concept and how to modify the system Path if necessary. Integrated Development Environment (IDE) : An IDE offers a higher-level user interface (typically with a GUI) that manages the tools for editing source code, building source code, flashing program binaries, and debugging . The abbreviation is frequently used in this document, and the MSDK supports multiple IDEs that can be used depending on preference. (See \"Supported Development Environments\" ) Build Configuration vs. Project Configuration : An MSDK project is comprised of two complementary systems: The Build System and the Integrated Development Environment (IDE) . These systems each offer their own configuration interfaces, and it's important to note what each is used for. The Build System manages source code compilation into program binaries and offers a Command-Line Interface (CLI) for setting Build Configuration Variables . The IDE offers a higher-level user interface (typically with a GUI) for managing a project and sits on top of the build system's CLI . Each IDE offers its own settings for managing fundamental aspects of the build, such as: Setting the Target Microcontroller Setting the Board Support Package Configuring the Environment and System Path for use with the MSDK toolchain Getting Started with Visual Studio Code The MSDK includes Visual Studio Code (\"VS Code\") support through the VSCode-Maxim project. This section walks through setup, opening, and running an example project with VS Code. This material is also available in video form targeting the MAX78000 in \"Understanding Artificial Intelligence Episode 8.5 - Visual Studio Code\" . For complete documentation, see the Visual Studio Code section of this User Guide. Setup (VS Code) The setup below only needs to be done once per MSDK installation . Download and install Visual Studio Code for your OS here . Launch Visual Studio Code. Install the Microsoft C/C++ extension . Use CTRL + SHIFT + P (or COMMAND + SHIFT + P on MacOS) to open the developer prompt. Type \"open user settings\" and select the \"Preferences: Open User Settings (JSON)\" option. Add the entries below to your user settings.json file. Change the MAXIM_PATH option to point to the MSDK installation . // There may be other settings up here... \"MAXIM_PATH\": \"Change me! Only use forward slashes (/) for this path\", \"update.mode\": \"manual\", \"extensions.autoUpdate\": false, // There may be other settings down here... For example, you might set \"MAXIM_PATH\":\"C:/MaximSDK\" on Windows, \"MAXIM_PATH\":\"/home/username/MaximSDK\" on Linux/MacOS, etc. Save your changes to the file with CTRL + S and restart VS Code. Building and Running a Project (VS Code) Launch Visual Studio Code. Select File -> Open Folder... Navigate to an example project for the target microcontroller in the MSDK's Examples folder and open it with Select Folder . VS Code will prompt for trust the first time. Select Trust folder and enable all features The opened project should look something like this. Set the Board Support Package to match your evaluation platform. In VS Code, this is done by editing the .vscode/settings.json file and setting the \"board\" project configuration option. See Board Support Packages for more details. Save your changes to settings.json with CTRL+S . Reload the VS Code window. After changing any options in settings.json , a reload is necessary to force it to re-index VS Code's Intellisense engine. VS Code can be conveniently reloaded with the Reload Window developer command accessed with CTRL + SHIFT + P (or COMMAND + SHIFT + P on MacOS). Press the shortcut Ctrl+Shift+B to open the available Build Tasks (alternatively navigate to Terminal -> Run Build task... ). Run the \"build\" task to compile the project for the configured Target Microcontroller and BSP . Notice that the TARGET and BOARD Build Configuration Variables are set on the command line. The program binary is successfully compiled into the .elf program binary in the build sub-folder of the project. Connect a debug adapter between the host PC and the evaluation platform. Detailed instructions on this hardware setup can be found in the evaluation platform's Datasheet and Quick-Start Guide, which are available on its analog.com product page. Run the flash build task. Running this task will automatically build the project if needed, flash the program binary, and halt the program execution to await a debugger connection. Open the Run and Debug window ( CTRL+SHIFT+D ) and launch the debugger ( F5 ). Verify the program counter enters main successfully. Press Continue ( F5 ) to run the program. Continue | Step Over | Step Into | Step Out | Restart | Stop Exercise the debugger and press stop to disconnect when finished. Getting Started with Eclipse Setup (Eclipse) The only setup required to use Eclipse is to ensure that the \"Eclipse\" component has been selected during the MSDK installation . If the MSDK is already installed, Eclipse can be retrieved using the Maintenance Tool . This section is an Eclipse \"quick-start\" that walks through creating, building, and running a project. For complete documentation, see the Eclipse section of this User Guide. Building and Running a Project (Eclipse) Launch Eclipse with its start menu shortcut. Ensure Eclipse is set to the C/C++ perspective in the top right corner. Otherwise, the new project wizard will not show up. Navigate to File -> New -> Maxim Microcontrollers . Enter the project name and hit Next . Follow the new project wizard. Chip type selects the Target Microcontroller Board type selects the Board Support Package (BSP) Example type selects the example project to be copied as the template for the new project. Adapter type selects the debug adapter to use. Select Finish to create the new project. Build the project using the Build hammer button (top left). Select the correct project in the Launch Configuration dropdown and set it to Debug mode. Use the Debug button (top left) to flash the program binary and connect the debugger. The Eclipse view will switch to debug mode, and the debugger will break on entry into main . Resume the program ( F8 ) using the top control bar and exercise the debugger. Terminate the debugger ( CTRL+F2 ) when finished. Getting Started with Command-Line Development This section demonstrates how to build MSDK example projects on the command line. It also shows how to flash and debug over the command line. The MAX78002EVKIT will be used as an example, but the same concepts apply to all parts. For more detailed documentation, see the Command-Line Development section of this User Guide. Setup (Command-Line) Windows On Windows, use the MinGW shortcut to launch an MSYS2/MinGW terminal. This shortcut points to Tools/MSYS2/msys.bat in an MSDK installation and correctly configures the user's environment for development. Linux/MacOS On Linux and MacOS, copy the following contents into your shell's terminal profile/startup script to manually configure your environment for MSDK development. Depending on your system and shell, this could be ~/.profile , ~/.zprofile , ~/.bashrc , ~/.zshrc , etc. Command-line Linux/MacOS users are expected to know which file to edit for their particular system and preferences. # Set MAXIM_PATH to point to the MSDK export MAXIM_PATH=#changeme! # Add Arm Embedded GCC to path (v10.3) export ARM_GCC_ROOT=$MAXIM_PATH/Tools/GNUTools/10.3 export PATH=$ARM_GCC_ROOT/bin:$PATH # Add xPack RISC-V GCC to path (v10.2) export XPACK_GCC_ROOT=$MAXIM_PATH/Tools/xPack/riscv-none-embed-gcc/10.2.0-1.2 export PATH=$XPACK_GCC_ROOT/bin:$PATH # Add OpenOCD to path export OPENOCD_ROOT=$MAXIM_PATH/Tools/OpenOCD export PATH=$OPENOCD_ROOT:$PATH Change export MAXIM_PATH=#changeme! to the installation location of the MSDK. This will make the toolchain accessible from the command line by adding it to your system's path . # Set MAXIM_PATH environment variable export MAXIM_PATH=$HOME/MaximSDK Verification Run the following commands to verify that the toolchain is accessible. They should display version numbers successfully. arm-none-eabi-gcc -v arm-none-eabi-gdb -v make -v openocd -v Any \"file not found\" errors indicate that MAXIM_PATH has not been set correctly or the system's Path has not been configured correctly. Building and Running an Example (Command-Line) First, copy an example project to an accessible directory outside of the SDK. It is strongly recommended to keep the MSDK examples unmodified in case they need to be referenced again later. Launch your terminal. On Windows, use the MinGW shortcut or Tools/MSYS2/msys.bat file to launch the MSYS2 terminal. cd into the location of the copied example project. Run the following command to build the example: make -r -j -r is an option that improves build speed. -j enables parallel execution of the build in the maximum number of threads. Expected output: Loaded project.mk CC main.c CC /home/msdk/Libraries/Boards/MAX78002/EvKit_V1/Source/board.c CC /home/msdk/Libraries/Boards/MAX78002/EvKit_V1/../../../MiscDrivers/stdio.c CC /home/msdk/Libraries/Boards/MAX78002/EvKit_V1/../../../MiscDrivers/LED/led.c CC /home/msdk/Libraries/Boards/MAX78002/EvKit_V1/../../../MiscDrivers/PushButton/pb.c CC /home/msdk/Libraries/Boards/MAX78002/EvKit_V1/../../../MiscDrivers/Display/adafruit_3315_tft.c CC /home/msdk/Libraries/Boards/MAX78002/EvKit_V1/../../../MiscDrivers/Touchscreen/adafruit_3315_touch.c CC /home/msdk/Libraries/Boards/MAX78002/EvKit_V1/../../../MiscDrivers/Camera/camera.c CC /home/msdk/Libraries/Boards/MAX78002/EvKit_V1/../../../MiscDrivers/Camera/mipi_camera.c CC /home/msdk/Libraries/Boards/MAX78002/EvKit_V1/../../../MiscDrivers/Camera/ov7692.c CC /home/msdk/Libraries/Boards/MAX78002/EvKit_V1/../../../MiscDrivers/Camera/sccb.c AS /home/msdk/Libraries/CMSIS/Device/Maxim/MAX78002/Source/GCC/startup_max78002.S CC /home/msdk/Libraries/CMSIS/Device/Maxim/MAX78002/Source/heap.c CC /home/msdk/Libraries/CMSIS/Device/Maxim/MAX78002/Source/system_max78002.c LD /home/msdk/Examples/MAX78002/Hello_World/build/max78002.elf arm-none-eabi-size --format=berkeley /home/msdk/Examples/MAX78002/Hello_World/build/max78002.elf text data bss dec hex filename 35708 2504 1156 39368 99c8 /home/msdk/Examples/MAX78002/Hello_World/build/max78002.elf Connect a debug adapter between the host PC and the evaluation platform. Detailed instructions on this hardware setup can be found in the evaluation platform's Datasheet and Quick-Start Guide, which are available on its analog.com product page. Run the command below to launch an OpenOCD server , flash the program binary, and halt the program execution. openocd -s $MAXIM_PATH/Tools/OpenOCD/scripts -f interface/cmsis-dap.cfg -f target/max78002.cfg -c \"program build/max78002.elf verify; init; reset halt\" Expected output: Open On-Chip Debugger 0.11.0+dev-g4cdaa275b (2022-03-02-09:57) Licensed under GNU GPL v2 For bug reports, read http://openocd.org/doc/doxygen/bugs.html DEPRECATED! use 'adapter driver' not 'interface' Info : CMSIS-DAP: SWD supported Info : CMSIS-DAP: Atomic commands supported Info : CMSIS-DAP: Test domain timer supported Info : CMSIS-DAP: FW Version = 0256 Info : CMSIS-DAP: Serial# = 044417016af50c6500000000000000000000000097969906 Info : CMSIS-DAP: Interface Initialised (SWD) Info : SWCLK/TCK = 1 SWDIO/TMS = 1 TDI = 0 TDO = 0 nTRST = 0 nRESET = 1 Info : CMSIS-DAP: Interface ready Info : clock speed 2000 kHz Info : SWD DPIDR 0x2ba01477 Info : max32xxx.cpu: Cortex-M4 r0p1 processor detected Info : max32xxx.cpu: target has 6 breakpoints, 4 watchpoints Info : starting gdb server for max32xxx.cpu on 3333 Info : Listening on port 3333 for gdb connections Info : SWD DPIDR 0x2ba01477 target halted due to debug-request, current mode: Thread xPSR: 0x81000000 pc: 0x0000fff4 msp: 0x20003ff0 ** Programming Started ** ** Programming Finished ** ** Verify Started ** ** Verified OK ** Info : Listening on port 6666 for tcl connections Info : Listening on port 4444 for telnet connections # Note: OpenOCD is now waiting for a GDB client Launch a new separate terminal . On Windows, use the MinGW shortcut or Tools/MSYS2/msys.bat file to launch the MSYS2 terminal. cd into the location of the copied example project. Run the following command to launch a GDB client . arm-none-eabi-gdb --se=build/max78002.elf --se sets the symbol and executable file to the compiled program file. By default, the output filename matches the target microcontroller. Expected output: GNU gdb (GNU Arm Embedded Toolchain 10.3-2021.10) 10.2.90.20210621-git Copyright (C) 2021 Free Software Foundation, Inc. License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html> This is free software: you are free to change and redistribute it. There is NO WARRANTY, to the extent permitted by law. Type \"show copying\" and \"show warranty\" for details. This GDB was configured as \"--host=i686-w64-mingw32 --target=arm-none-eabi\". Type \"show configuration\" for configuration details. For bug reporting instructions, please see: <https://www.gnu.org/software/gdb/bugs/>. Find the GDB manual and other documentation resources online at: <http://www.gnu.org/software/gdb/documentation/>. For help, type \"help\". Type \"apropos word\" to search for commands related to \"word\"... Reading symbols from build/max78002.elf... (gdb) Connect the GDB Client to the OpenOCD server with the following command. target extended-remote localhost:3333 Expected output: Remote debugging using localhost:3333 0x0000fff4 in ?? () # Note: ?? may be present at this stage, which is OK. Reset the target microcontroller. monitor reset halt Expected output: SWD DPIDR 0x2ba01477 target halted due to debug-request, current mode: Thread xPSR: 0x81000000 pc: 0x0000fff4 msp: 0x20003ff0 Set a breakpoint on main . b main Expected output: Breakpoint 1 at 0x10000224: file main.c, line 62. Note: automatically using hardware breakpoints for read-only addresses. Continue the debugger. continue Expected output (for the Hello World example): Continuing. Breakpoint 1, main () at main.c:62 62 printf(\"Hello World!\\n\"); (Optional) Continue exercising the debugger. Run help for GDB help, or see Common GDB Commands . Quit GDB. quit Expected output: A debugging session is active. Inferior 1 [Remote target] will be detached. Quit anyway? (y or n) [answered Y; input not from terminal] Detaching from program: C:\\Users\\User\\codespace\\Hello_World\\build\\max78002.elf, Remote target [Inferior 1 (Remote target) detached] In the terminal window running the OpenOCD server , press CTRL + C to issue the shutdown command and quit. Visual Studio Code Support for Visual Studio Code is maintained for the MSDK and developed on the VSCode-Maxim GitHub repository. For setup/quick-start instructions, see \"Getting Started with Visual Studio Code\" first. This section offers detailed usage info focusing on the typical development cycle. Opening Example Projects Visual Studio Code is built around a \"working directory\" paradigm. The editor is always rooted in a working directory, and the main mechanism for changing that directory is File -> Open Folder... As a result, you'll notice that there is no \"New Project\" mechanism. A \"project\" in VS Code is simply a folder. It will look inside the opened folder for a .vscode sub -folder to load project-specific settings from. (Note: You may need to enable viewing of hidden items in your file explorer to see the .vscode sub-folder). To open a project: 1. Launch Visual Studio Code. Select File -> Open Folder... Navigate to an example project for the target microcontroller in the MSDK's Examples folder and open it with Select Folder . VS Code will prompt for trust the first time. Select Trust folder and enable all features The opened project should look something like this. Verify the Board Support Package for the project is set correctly. See How to Set the BSP (VS Code) below. How to Set the BSP (VS Code) To set the BSP for an open project: Set the \"board\" project configuration option in .vscode/settings.json , which maps to the BOARD Build Configuration Variable . See Board Support Packages for a table of possible values. Reload the VS Code window to re-index its Intellisense engine. VS Code can be conveniently reloaded with the Reload Window developer command accessed with CTRL + SHIFT + P (or COMMAND + SHIFT + P on MacOS). Building a Project An open project will present four available build tasks from Terminal > Run Build task... or the shortcut Ctrl+Shift+B . Run the \"build\" task to compile the project for the configured Target Microcontroller and BSP . Notice the TARGET , BOARD , and PROJECT Build Configuration Variables being set on the command line, and the program binary successfully compiled into the .elf program binary in the build sub-folder of the project. Cleaning a Project To clean a project, run the clean build task . This will delete the build folder and its contents. The next time the project is built, it will be rebuilt from scratch. It should be noted that clean will only remove the project's build output. The clean-periph task can be used to clean the project and the peripheral driver libraries. Flashing and Debugging This section assumes a debugger is connected between the host PC and the evaluation platform. For more detailed instructions on this hardware setup, refer to the evaluation platform's Datasheet and Quick-Start Guide, which are available on its analog.com product page. Arm Core Debugging Run the flash build task . Running this task will automatically build the project if needed, flash the program binary, and halt the program execution to await a debugger connection. Flashing does not happen automatically when launching the debugger . This is an intentional design choice for VS Code to allow the debugger to quickly restart the program under debug without a lengthy re-flash procedure. Open the Run and Debug window ( CTRL+SHIFT+D ) and launch the debugger ( F5 ). Use the Arm M4 profile. Verify the program counter enters main successfully. Press Continue ( F5 ) to run the program. The debugger control bar can be used to exercise the debugger further. Continue | Step Over | Step Into | Step Out | Restart | Stop Breakpoints Breakpoints can be set by clicking next to a line number in VS Code's editor. They are removed by clicking on them again. Additionally conditional breakpoints can be added by right-clicking on a line. The condition and condition type can be modified with the dropdown. This is useful for setting a breakpoint on a certain value in a for loop iterator or when a specific bit in a register is set, for example. Peripheral Browsing A peripheral browser lets you quickly view the formatted register-level contents of the peripheral blocks on a target microcontroller under debug. Currently, VSCode-Maxim does not feature a true peripheral browser. Instead, watch expressions can be used to inspect peripherals at the register level. Watch expressions can be set for all registers. (For example, the sysctrl register below). Adding ,b lets you print out the value in binary Adding ,x prints the value in hex . Standard logical and bitwise operations are supported inside the watch expression. Register and variable values can be modified through these same watch-points. (Right click -> Set Value) It should be noted that the debugger's watch points are contextual , meaning that its symbol look-ups will depend on the active point in your program. Dual Core Debugging For microcontrollers with both an Arm M4 and a RISC-V core, the GDB (RISC-V) launch profile is provided to enable RISC-V debugging. The RISC-V core requires setup and handoff from the Arm M4 core. As a result, this is an advanced configuration requiring a unique combination of the project's source code, Makefiles, and VSCode-Maxim project settings. Such projects are appended with the -riscv suffix in the project's folder name. This section demonstrates how to debug -riscv projects in VS Code using the mnist-riscv project for the MAX78000 as an example. Connect both your Arm (SWD) and RISC-V (JTAG) debuggers. VSCode-Maxim projects come pre-configured to use the ARM-USB-OCD-H + ARM-JTAG-20-10 adapters for the RISC-V JTAG port. Ex: Make sure your Olimex debugger drivers are installed correctly. Sometimes they need to be updated using the \"zadig\" tool. See Section 3.3.3 of the Olimex User Manual , and use the Zadig tool to install WinUSB drivers. Download the max78000_riscv.cfg file and place it inside the Tools/OpenOCD/scripts/target folder of your MSDKinstallation. Open the project in VS Code. Run the \"Flash\" task. Launch the debugger using the GDB (Arm M4) profile first : ... which should hit the breakpoint in main.c ... Continue the debugger. The code in main.c will boot up the RISC-V core. You can optionally set a breakpoint on WakeISR to see when the RISC-V core has signaled it's ready. Now, switch the debugger profile to the GDB (RISC-V) profile and launch it. This will launch an additional instance on a separate port and connect to the Olimex adapter. The \"Signal 0\" exception below is a known issue caused by a reset bug on the RISC-V core. The exception message is harmless and can be safely ignored. From here, the debugger should be fully functional. The Arm vs. RISC-V debugger instance can be selected with the dropdown on the debugger control bar. Eclipse For setup/quick-start instructions, see \"Getting Started with Eclipse\" first. This section offers detailed usage info focusing on the typical development cycle. Running Eclipse Eclipse must be launched with the Eclipse MaximSDK shortcut. The shortcut points to the Tools/Eclipse/cdt/eclipse(.bat/.sh) file, which configures Eclipse's system environment for use with the MSDK toolchain. When Eclipse is launched, it will prompt for a workspace location. This is a local folder that Eclipse will copy its projects into. Creating a New Project Launch Eclipse. Ensure that the Eclipse is set to the C/C++ perspective in the top right corner. Otherwise, the new project wizard will not show up. Navigate to File -> New -> Maxim Microcontrollers . Enter the project name and hit Next . Follow the new project wizard. Chip type selects the Target Microcontroller Board type selects the Board Support Package (BSP) Example type selects the example project to be copied as the template for the new project. Adapter type selects the debug adapter to use. Select Finish to create the new project. Importing Examples Launch Eclipse. Use File -> Import to open the import wizard. Select General -> Existing Projects into Workspace and hit Next . Browse to the Examples folder in the MSDK installation for your target microcontroller and select the example projects to import into the workspace. Ensure that Copy projects into workspace is selected. This will copy the projects out of the MSDK and leave the originals unmodified. Select Finish to import the project(s). The projects should now show up in the Project Explorer. How to Set the BSP (Eclipse) Imported Eclipse projects files are configured for the EVKIT -type BSP by default. To set the BSP: Right click the project name and select Properties . Navigate to C/C++ Build -> Environment . Set the BOARD Build Configuration Variable to match the target evaluation platform. See Board Support Packages for a table of possible values. clean and rebuild the project. Building a Project Ensure that the Eclipse is set to the C/C++ perspective (top right). Select the correct project in the Launch Configuration dropdown. Use the Build hammer button (top left) to build the project. Flashing and Debugging Connect a debug adapter between the host PC and the evaluation platform. For more detailed instructions on this hardware setup, refer to the evaluation platform's Datasheet and Quick-Start Guide, which are available on its analog.com product page. Ensure the correct project in the Launch Configuration dropdown is selected in Debug mode. Use the Debug button (top left) to flash the program binary and connect the debugger. The Eclipse view will switch to debug mode, and the debugger will break on entry into the main. Resume the program ( F8 ) using the top control bar and exercise the debugger. Terminate the debugger ( CTRL+F2 ) when finished. Segger J-Link Setup Guide (Eclipse) Eclipse offers built-in support for Segger J-Link debuggers. J-Link debugging can be enabled following the steps below: Download and install the latest Segger J-Link Software and Documentation from here Follow the instructions from the Segger J-Link Eclipse plugin here with the following modifications specific to the MSDK. Other options an be left at their defaults. Modify the Executable name under \"GDB Client Setup\" to arm-none-eabi-gdb${cross_suffix} Modify the \"Startup\" options to issue a monitor reset halt under initialization commands and uncheck Pre-run/Restart reset Keil MDK The Keil MDK Microcontroller Development Kit is developed and maintained by Arm. ADI maintains CMSIS Pack files supporting this environment. Supporting documentation is maintained by Arm, and can be found on the MDK5 page . The latest pack files can be found under the \"Maxim\" section of the device list . IAR Embedded Workbench IAR Embedded Workbench is a third-party IDE that requires a software license. ADI maintains support files for this IDE in the form of CMSIS Pack files. Supporting documentation is maintained by IAR, and can be found on the Embedded Workbench Product Page under \"User Guides and documentation\". Command-Line Development This section offers more detailed info on command-line development. For setup/quick-start, see \"Getting Started with Command-Line Development\" . How to Set the BSP (Command-Line) To persistently the BSP, set the BOARD Build Configuration Variable . by editing the project.mk that can be found inside each project. # This file can be used to set build configuration # variables. These variables are defined in a file called # \"Makefile\" that is located next to this one. # For instructions on how to use this system, see # https://analog-devices-msdk.github.io/msdk/USERGUIDE/ # ********************************************************** # Add your config here! BOARD=FTHR_RevA # Set the BSP for the MAX78000FTHR Alternatively, set BOARD on the command line when building (i.e., make -r -j BOARD=FTHR_RevA ) to set/override the BSP for a single build. Building on the Command-Line cd into the project folder. Run make Parallel Build (fastest build, but console message formatting may be mangled): make -r -j Serial Build make -r Take note of the output filename and location, which by default is the lowercase name of the Target microcontroller and created in the build folder. Cleaning on the Command-Line cd into the project folder. Run make clean Project clean : make clean deletes the project build folder and all of its contents. Library clean : make distclean can be used to clean out all build products, including the project build folder and all peripheral driver libraries. Flashing on the Command-Line Build the project. Connect a debug adapter between the host PC and the evaluation platform. For more detailed instructions on this hardware setup, refer to the evaluation platform's Datasheet and Quick-Start Guide, which are available on its analog.com product page. Flash the program using openocd . Flash and exit: Use this command if you just want to flash the program but not debug . OpenOCD will flash the program and exit on completion. openocd -s $MAXIM_PATH/Tools/OpenOCD/scripts -f interface/cmsis-dap.cfg -f target/max78002.cfg -c \"program build/max78002.elf verify exit\" -f target/max78002.cfg sets the OpenOCD config file for the Target microcontroller . Supported options can be found in the Tools/OpenOCD/scripts/target folder. Change this to match the target microcontroller . -c \"program build/max78002.elf verify exit\" flashes the program binary. Change build/max78002.elf to match the correct filename. Expected output: Open On-Chip Debugger 0.11.0+dev-g4cdaa275b (2022-03-02-09:57) Licensed under GNU GPL v2 For bug reports, read http://openocd.org/doc/doxygen/bugs.html DEPRECATED! use 'adapter driver' not 'interface' Info : CMSIS-DAP: SWD supported Info : CMSIS-DAP: Atomic commands supported Info : CMSIS-DAP: Test domain timer supported Info : CMSIS-DAP: FW Version = 0256 Info : CMSIS-DAP: Serial# = 044417016af50c6500000000000000000000000097969906 Info : CMSIS-DAP: Interface Initialised (SWD) Info : SWCLK/TCK = 1 SWDIO/TMS = 1 TDI = 0 TDO = 0 nTRST = 0 nRESET = 1 Info : CMSIS-DAP: Interface ready Info : clock speed 2000 kHz Info : SWD DPIDR 0x2ba01477 Info : max32xxx.cpu: Cortex-M4 r0p1 processor detected Info : max32xxx.cpu: target has 6 breakpoints, 4 watchpoints Info : starting gdb server for max32xxx.cpu on 3333 Info : Listening on port 3333 for gdb connections Info : SWD DPIDR 0x2ba01477 target halted due to debug-request, current mode: Thread xPSR: 0x81000000 pc: 0x0000fff4 msp: 0x20003ff0 ** Programming Started ** ** Programming Finished ** ** Verify Started ** ** Verified OK ** shutdown command invoked Flash and hold: Use this if you want to also debug the program. OpenOCD will flash the program, reset the MAX78002, halt program execution, and wait for a GDB debugger client connection. openocd -s $MAXIM_PATH/Tools/OpenOCD/scripts -f interface/cmsis-dap.cfg -f target/max78002.cfg -c \"program build/max78002.elf verify; init; reset halt\" -f target/max78002.cfg sets the OpenOCD config file for the Target microcontroller . Supported options can be found in the Tools/OpenOCD/scripts/target folder. Change this to match the target microcontroller . -c \"program build/max78002.elf verify exit\" flashes the program binary. Change build/max78002.elf to match the correct filename. Expected output: Open On-Chip Debugger 0.11.0+dev-g4cdaa275b (2022-03-02-09:57) Licensed under GNU GPL v2 For bug reports, read http://openocd.org/doc/doxygen/bugs.html DEPRECATED! use 'adapter driver' not 'interface' Info : CMSIS-DAP: SWD supported Info : CMSIS-DAP: Atomic commands supported Info : CMSIS-DAP: Test domain timer supported Info : CMSIS-DAP: FW Version = 0256 Info : CMSIS-DAP: Serial# = 044417016af50c6500000000000000000000000097969906 Info : CMSIS-DAP: Interface Initialised (SWD) Info : SWCLK/TCK = 1 SWDIO/TMS = 1 TDI = 0 TDO = 0 nTRST = 0 nRESET = 1 Info : CMSIS-DAP: Interface ready Info : clock speed 2000 kHz Info : SWD DPIDR 0x2ba01477 Info : max32xxx.cpu: Cortex-M4 r0p1 processor detected Info : max32xxx.cpu: target has 6 breakpoints, 4 watchpoints Info : starting gdb server for max32xxx.cpu on 3333 Info : Listening on port 3333 for gdb connections Info : SWD DPIDR 0x2ba01477 target halted due to debug-request, current mode: Thread xPSR: 0x81000000 pc: 0x0000fff4 msp: 0x20003ff0 ** Programming Started ** ** Programming Finished ** ** Verify Started ** ** Verified OK ** Info : Listening on port 6666 for tcl connections Info : Listening on port 4444 for telnet connections # Note: OpenOCD is now waiting for a GDB client connection Debugging on the Command-Line Flash the program using the Flash and Hold command. Launch an new separate terminal . On Windows, use the MinGW shortcut or Tools/MSYS2/msys.bat file to launch the MSYS2 terminal. cd into the location of the copied example project. Run the following command to launch a GDB client . arm-none-eabi-gdb --se=build/max78002.elf --se sets the symbol and executable file to the compiled program file. Change this to match the build output filename. Expected output: GNU gdb (GNU Arm Embedded Toolchain 10.3-2021.10) 10.2.90.20210621-git Copyright (C) 2021 Free Software Foundation, Inc. License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html> This is free software: you are free to change and redistribute it. There is NO WARRANTY, to the extent permitted by law. Type \"show copying\" and \"show warranty\" for details. This GDB was configured as \"--host=i686-w64-mingw32 --target=arm-none-eabi\". Type \"show configuration\" for configuration details. For bug reporting instructions, please see: <https://www.gnu.org/software/gdb/bugs/>. Find the GDB manual and other documentation resources online at: <http://www.gnu.org/software/gdb/documentation/>. For help, type \"help\". Type \"apropos word\" to search for commands related to \"word\"... Reading symbols from build/max78002.elf... (gdb) Connect the GDB Client to the OpenOCD server with the following command. target extended-remote localhost:3333 Expected output: Remote debugging using localhost:3333 0x0000fff4 in ?? () # Note: ?? may be present at this stage, which is OK. Reset the target microcontroller. monitor reset halt Expected output: SWD DPIDR 0x2ba01477 target halted due to debug-request, current mode: Thread xPSR: 0x81000000 pc: 0x0000fff4 msp: 0x20003ff0 Set a breakpoint on main . b main Expected output: Breakpoint 1 at 0x10000224: file main.c, line 62. Note: automatically using hardware breakpoints for read-only addresses. Continue the debugger. continue Expected output (for the Hello World example): Continuing. Breakpoint 1, main () at main.c:62 62 printf(\"Hello World!\\n\"); (Optional) Continue exercising the debugger. Run help for GDB help, or see Common GDB Commands . Quit GDB. quit Expected output: A debugging session is active. Inferior 1 [Remote target] will be detached. Quit anyway? (y or n) [answered Y; input not from terminal] Detaching from program: C:\\Users\\User\\codespace\\Hello_World\\build\\max78002.elf, Remote target [Inferior 1 (Remote target) detached] Quit OpenOCD. In the terminal window running the OpenOCD server , press CTRL + C to issue the shutdown command. Common GDB Commands Command Short Command Description monitor halt Halt the microcontroller. monitor reset halt Reset the microcontroller and immediately halt. monitor max32xxx mass_erase 0 Mass erase the flash. file <filename> Set the program file to <filename> load Flash the current program file continue c Continue execution. break <arg> b <arg> Set a breakpoint. <arg> can be a function name, file:line_number, or address. print <variable> p Print the value of a variable. The variable must be in the current scope. backtrace bt Print contents of the stack frame. step s Execute the next instruction. next n Execute the next line of code. finish f Continue to the end of the current function. info reg Print the values of the ARM registers. help Print descriptions for available commands help <cmd> Print description for given command. quit q Quit the GDB client Board Support Packages The MSDK supports multiple parts and evaluation platforms (see supported parts ) through \"Board Support Packages\" (BSPs) . For microcontrollers with multiple evaluation platforms, multiple BSPs will be available. The role of a BSP is to provide a hardware abstraction layer for the initialization and management of board-level hardware such as serial interfaces, pushbuttons, LEDs, external peripheral devices, TFT displays, etc. which will vary between evaluation platforms. The BSP abstraction layer also improves code portability to custom devices. The first task when opening or creating any project is to ensure the BSP is set correctly. How to Set the BSP To set the BSP for a project: In VS Code : How to Set the BSP (VS Code) In Eclipse : How to Set the BSP (Eclipse) Command-Line Development: How to Set the BSP (Command-Line) BSP Table Available BSPs are located in the Libraries/Boards folder for each Target Microcontroller . The name of a BSP's folder is used with the BOARD build configuration variable to build a project for a specific BSP. The table below matches the correct BOARD values to external part numbers . External Part Number TARGET BOARD MAX32520-KIT MAX32520 EvKit_V1 MAX32520FTHR MAX32520 MAX32520FTHR MAX32650-EVKIT MAX32650 EvKit_V1 MAX32650FTHR MAX32650 FTHR_APPS_A MAX32655EVKIT MAX32655 EvKit_V1 MAX32655FTHR MAX32655 FTHR_Apps_P1 MAX32660-EVSYS MAX32660 EvKit_V1 MAX32662EVKIT MAX32662 EvKit_V1 MAX32666EVKIT MAX32665 EvKit_V1 MAX32666FTHR MAX32665 FTHR MAX32666FTHR2 MAX32665 FTHR2 MAX32670EVKIT MAX32670 EvKit_V1 MAX32672EVKIT MAX32672 EvKit_V1 MAX32672FTHR MAX32672 FTHR MAX32675EVKIT MAX32675 EvKit_V1 MAX32675FTHR MAX32675 FTHR_Apps_B MAX32680EVKIT MAX32680 EvKit_V1 MAX32690EVKIT MAX32690 EvKit_V1 MAX78000EVKIT MAX78000 EvKit_V1 MAX78000FTHR MAX78000 FTHR_RevA MAXREFDES178 MAX78000 MAXREFDES178 MAX78002EVKIT MAX78002 EvKit_V1 Custom BSPs For custom boards, additional BSPs can be easily created and added to the MSDK. Inspecting the Libraries/CMSIS/Device/Maxim/TARGET/Source/system_TARGET.c for a target microcontroller shows how the BSP is integrated and which startup functions can be implemented. For example, the MAX78000's system_max78000.c startup file shows that PreInit and Board_Init are weak functions that can be overridden. They are called from the default SystemInit implementation, which can also be overridden. /* This function is called before C runtime initialization and can be * implemented by the application for early initializations. If a value other * than '0' is returned, the C runtime initialization will be skipped. * * You may over-ride this function in your program by defining a custom * PreInit(), but care should be taken to reproduce the initialization steps * or a non-functional system may result. */ __weak int PreInit(void) { /* Do nothing */ return 0; } /* This function can be implemented by the application to initialize the board */ __weak int Board_Init(void) { /* Do nothing */ return 0; } /* This function is called just before control is transferred to main(). * * You may over-ride this function in your program by defining a custom * SystemInit(), but care should be taken to reproduce the initialization * steps or a non-functional system may result. */ __weak void SystemInit(void) { /* Configure the interrupt controller to use the application vector table in */ /* the application space */ #if defined(__CC_ARM) || defined(__GNUC__) /* IAR sets the VTOR pointer incorrectly and causes stack corruption */ SCB->VTOR = (uint32_t)__isr_vector; #endif /* __CC_ARM || __GNUC__ */ /* Enable instruction cache */ MXC_ICC_Enable(MXC_ICC0); /* Enable FPU on Cortex-M4, which occupies coprocessor slots 10 and 11 */ /* Grant full access, per \"Table B3-24 CPACR bit assignments\". */ /* DDI0403D \"ARMv7-M Architecture Reference Manual\" */ SCB->CPACR |= SCB_CPACR_CP10_Msk | SCB_CPACR_CP11_Msk; __DSB(); __ISB(); SystemCoreClockUpdate(); Board_Init(); } A custom BSP can implement one or all of the weak functions. To do so, it's recommended to create a new directory inside the Libraries/Boards folder for the target microcontroller with the file structure below. The name of the created directory will be the string to use with the BOARD build configuration variable to select the custom BSP. Libraries \u2514\u2500 Boards \u2514\u2500 TARGET \u2514\u2500 CustomBSP \u251c\u2500 Include | \u2514\u2500 board.h \u251c\u2500 Source | \u2514\u2500 board.c \u2514\u2500 board.mk The following contents can be used as a bare-bones starter template. board.h // board.h #define BOARD_CUSTOM // ^ This type of compiler definition is // sometimes useful. It allows application code // to check if a specific BSP is being used. // Ex: #ifdef BOARD_CUSTOM // ... // #endif /** * \\brief Initialize the BSP and board interfaces. * \\returns #E_NO_ERROR if everything is successful */ int Board_Init(void); board.c //board.c #include \"board.h\" #include \"mxc_error.h\" int Board_Init(void) { // Implement me! return E_NO_ERROR; } board.mk ifeq \"$(BOARD_DIR)\" \"\" # This Makefile will self-locate if BOARD_DIR is not specified. BOARD_DIR := $(dir $(abspath $(lastword $(MAKEFILE_LIST)))) endif SRCS += board.c VPATH += $(BOARD_DIR)/Source IPATH += $(BOARD_DIR)/Include Disabling BSPs It should also be noted that BSP integration can be disabled entirely by setting the LIB_BOARD build configuration variable to 0. This will skip the inclusion of the BSP's board.mk file entirely, and the default system initialization functions will be used. Build System Build System Overview The Build System manages the compilation of source code into program binaries and offers a Command-Line Interface (CLI) for setting Build Configuration Variables . All IDEs interface with this system. The Build System is managed by two files found in a project's root directory, one called Makefile and one called project.mk . These files are used by the GNU Make program (which is a part of the MSDK toolchain) to locate and build a project's source code. Makefile is the \"core\" file and should not be edited directly. Instead, it exposes the CLI that can be accessed in the project.mk file, on the command line, in your system's environment, or through your IDE. It also comes with a default configuration that is suitable for most projects. project.mk offers a convenient and stable access point for advanced build configuration, and this is the file that should be edited if necessary. When the command make is run from inside of a project folder, the program make will resolve any project-specific settings and then build the project's source code. Default Build Behavior By default, the build system will auto-search the root project directory for source code ( *.c ) and header files ( *.h ) to compile into a program binary. The optional include and src directories are also searched if they exist. Root Project Directory \u251c\u2500 project.mk \u251c\u2500 Makefile \u251c\u2500 *.h \u251c\u2500 *.c \u251c\u2500include # <-- Optional \u2514\u2500 *.h \u251c\u2500src # <-- Optional \u2514\u2500 *.c Additionally, a project's build system will come pre-configured for a specific Target Microcontroller and its primary BSP . The default configuration is suitable for most use cases, but a system of Build Configuration Variables is available if additional configuration is needed. Build Configuration Variables A Build Configuration Variable is a Makefile variable and therefore follows the same rules. However, they have been streamlined to be made much easier to use, so most of the official GNU Make documentation is only needed for advanced use cases. How to Set a Build Configuration Variable To set a standard configuration variable, use the = syntax ... VARIABLE=VALUE The = operator is used for most configuration variables with a few exceptions (documented in the reference table ) when a variable should contain a list of values . In such cases, use += the syntax to add values to the list. VARIABLE+=VALUE1 VARIABLE+=VALUE2 Where to Set a Build Configuration Variable For most variables, you should set them in the project.mk file (exceptions are documented in the reference table and IDE-specific sections). For example, to enable hardware floating-point acceleration for a project, the MFLOAT_ABI configuration variable can be used with a value of hard . The contents of project.mk might then look as follows: ( Inside project.mk ) # This file can be used to set build configuration # variables. These variables are defined in a file called # \"Makefile\" that is located next to this one. # For instructions on how to use this system, see # https://analog-devices-msdk.github.io/msdk/USERGUIDE/ # ********************************************************** MFLOAT_ABI=hard # Enable hardware floating point acceleration It should also be noted that configuration variables can be set on the command line as well. For example make MFLOAT_ABI=hard will have the same effect. Additionally, environment variables can be used. For example (on Linux) export MFLOAT_ABI=hard will set the hardware floating point acceleration as the default for all projects with an environment variable. However, there is a precedence hierarchy that should be taken into consideration. Precedence Hierarchy The precedence hierarchy for the value of a configuration variable is: IDE/command-line > project.mk > environment variable > default value If a value is set in an IDE and project.mk, the IDE's value will take precedence. However, the \"override\" directive can be used in project.mk to give it max precedence. Build Configuration Variables Reference Table Configuration Variable Description Details TARGET Set the Target Microcontroller If you are using an IDE, set this variable in the IDE's settings instead of project.mk BOARD Set the Board Support Package (BSP) If you are using an IDE, set this variable in the IDE's settings instead of project.mk. See Board Support Packages for more details. When you change this option, it's usually a good idea to fully clean your project, then rebuild. MAXIM_PATH (Optional) Specify the location of the MSDK This optional variable can be used to change where the Makefile looks for the MSDK installation. By default, the build system will attempt to locate the MSDK with a relative path. If a project is moved outside of the SDK, this variable must be set to the absolute path of the MSDK installation. CAMERA (Optional) Set the Camera drivers to use This option is only useful for the MAX78000 and MAX78002 and sets the camera drivers to use for the project. Permitted values are HM01B0 , HM0360_MONO , HM0360_COLOR , OV5642 , OV7692 (default), or PAG7920 . Camera drivers can be found in the Libraries/MiscDrivers/Camera folder. Depending on the selected camera, a compiler definition may be added to the build. See the board.mk file for the active BSP for more details. VPATH Where to search for source (.c) files Use the += operator with this variable . This controls where the Makefile will look for source code files. If AUTOSEARCH is enabled (which it is by default), all source code files in the directories specified by this option will be automatically added to the build. If AUTOSEARCH is disabled, this tells the Makefile where to look for the files specified by SRCS . IPATH Where to search for header (.h) files Use the += operator with this variable . This controls where the Makefile will look for header files. Unlike the VPATH option, this is not related to AUTOSEARCH . Individual header files are not ever manually added to the build. Instead, you only need to specify the location of your header files. AUTOSEARCH Automatically search for source (.c) files Enable or disable the automatic detection of .c files on VPATH (enabled by default). Set to 0 to disable or 1 to enable. If auto-search is disabled, source files must be manually added to SRCS . SRCS List of source (.c) files to add to the build Use the += operator with this variable . All of the files in this list will be added to the build. If AUTOSEARCH is enabled, this is most useful for adding the full absolute path to a singular source file to selectively add to the build. If AUTOSEARCH is disabled, all of the source files for the project must be added to SRCS , and they must also all be located on an entry in VPATH . Otherwise, a full path relative to the Makefile must be used. PROJECT Set the output filename This controls the output filename of the build. File extensions should not be included in the filename. For VS Code, you should use the project_name advanced config option instead of project.mk. MXC_OPTIMIZE_CFLAGS Set the optimization level See Optimize Options for more details. Normal builds will default to -Og , which is good for debugging, while release builds will default to -O2 . PROJ_CFLAGS Add a compiler flag to the build Use the += operator with this variable . Compiler flags can be added with this option, including compiler definitions. For each value, the same syntax should be used as if the compiler flag was passed in over the command line. These can include standard GCC options and/or ARM-specific options. PROJ_AFLAGS Add an assembler flag to the build Use the += operator with this variable . Assembler flags can be added with this option. MFLOAT_ABI Set the floating point acceleration level Sets the floating-point acceleration level. Permitted values are hard , soft , and softfp (default). To enable full hardware acceleration instructions, use hard , but keep in mind that all libraries your source code uses must also be compiled with hard . If there is any conflict, you'll get a linker error. For more details, see -mfloat-abi under ARM Options . LINKERFILE Set the linkerfile to use Set the linkerfile with this option. The file should exist in Libraries/CMSIS/Device/Maxim/TARGET/Source/GCC in the MSDK, or it should be placed inside the root directory of the project. PROJ_LDFLAGS Add a linker flag to the build Use the += operator with this variable . Flags can be passed to the linker with this option. See GCC Options for Linking LIB_BOARD Include the BSP library (enabled by default) Inclusion of the Board-Support Package (BSP) library, which is enabled by default, can be toggled with this variable. Set to 0 to disable or 1 to enable. LIB_PERIPHDRIVERS Include the peripheral driver library (enabled by default) The peripheral driver library can be toggled with this option. If disabled, you'll lose access to the higher-level driver functions but still have access to the register-level files. Set to 0 to disable or 1 to enable. LIB_CMSIS_DSP Include the CMSIS-DSP library The CMSIS-DSP library can be enabled with this option. Set to 0 to disable or 1 to enable. LIB_CORDIO Include the Cordio library The Cordio BLE library can be included with this option. This is only applicable for microcontrollers with an integrated BLE controller. LIB_FCL Include the Free Cryptographic Library (FCL) This option toggles the Free Cryptographic Library (FCL), which is a collection of software-implemented common cryptographic functions that can be included with this option. Set to 0 to disable or 1 to enable. LIB_FREERTOS Include the FreeRTOS library The FreeRTOS library can be enabled with this option, which is an open-source Real-Time Operating System (RTOS). Set to 0 to disable or 1 to enable. LIB_LC3 Include the LC3 codec library This option enables the inclusion of the Low Complexity Communication Codec (LC3), which is an efficient low latency audio codec. Set to 0 to disable or 1 to enable. LIB_LITTLEFS Include the littleFS library This option toggles the \"Little File System\" library - a small filesystem library designed for microcontrollers. Set to 0 to disable or 1 to enable. LIB_LWIP Include the lwIP library LIB_MAXUSB Include the MaxUSB library This option toggles the inclusion of the MAXUSB library, which facilitates the use of the native USB peripherals on some microcontrollers. Set to 0 to disable or 1 to enable. LIB_SDHC Include the SDHC library This option toggles the Secure Digital High Capacity (SDHC) library, which can be used to interface with SD cards. Additionally, it enables the FatFS library, which implements a generic FAT filesystem. SBT Toggle SBT integration Toggles integration with the Secure Boot Tools (SBTs) . These are a suite of applications designed for use with microcontrollers that have secure bootloaders. When this is enabled, some additional rules become available such as make sla and make scpa . Set to 0 to disable or 1 to enable. MAXIM_SBT_DIR Where to find the SBTs This option can be used to manually specify the location of the SBTs. Usually, this is not necessary. By default, the Tools/SBT directory of the MaximSDK will be searched. If the SBT installer is used, it will set the MAXIM_SBT_DIR environment variable to point to itself automatically. TARGET_SEC Secure part number to use Some secure microcontrollers have multiple secure variants, and this option can be used to specify the variant to use with the SBTs. Defaults are intelligently selected and can be found in $(MAXIM_SBT_DIR)/SBT-config.mk SCP_PACKETS Where to build the scp_packets folder Defaults to build/scp_packets TEST_KEY Which test key to sign applications with Defaults to $(MAXIM_SBT_DIR)/devices/$(TARGET_SEC)/keys/maximtestcrk.key , which is the Maxim test key that can be used for development. Peripheral Driver API A microcontroller is made up of a Central Processing Unit (CPU) that is surrounded by additional peripheral hardware blocks such as timers, memory controllers, UART controllers, ADCs, RTCs, audio interfaces, and many more. The Peripheral Driver API is an important core library in the MSDK that allows the CPU to utilize the microcontroller's hardware blocks over a higher-level Application Programming Interface (API) . The links below will open detailed API references for each microcontroller. Offline copies of these API references can also be found in the Documentation folder of the MSDK installation . MAX32520 API MAX32650 API MAX32655 API MAX32660 API MAX32665-MAX32666 API MAX32670 API MAX32672 API MAX32675 API MAX32680 API MAX32690 API MAX78000 API MAX78002 API Organization The Peripheral Driver API's source code is organized as follows: Header files (.h) can be found in the Libraries/PeriphDrivers/Include folder. These files contain function declarations for the API, describing the function prototypes and their associated documentation. Source files (.c) can be found in the Libraries/PeriphDrivers/Source folder. These files contain the function definitions for the API - the implementations of the functions declared by the header files. The implementation files are further organized based on die type and hardware revision . This is worth noting when browsing or debugging through the drivers. The die type files follow the _MEXX or _AIXX naming convention These files' responsibility is to manage microcontroller-specific implementation details that may interact with other peripheral APIs before ultimately calling the revision-specific files. The _hardware revision_ files follow the _revX naming convention. These files contain the pure driver implementation for a peripheral block and typically interact with the hardware almost entirely at the register level. Examples The MSDK contains examples for each microcontroller that demonstrate the usage of its Peripheral APIs . They can be found in the Examples folder of an MSDK installation. Each example contains a README.md file describing what it does. In general, there is at least one example per peripheral block, and the example's name will indicate what it matches (i.e., DMA , ADC , SPI ). Libraries The MSDK contains a large number of libraries, both third-party and in-house. These libraries are an extension to the \"core\" SDK resources and contain drivers for various external components such as TFT displays, cameras, accelerometers, audio codecs, and other devices. The MSDK also contains libraries for more advanced internal hardware peripherals that provide an additional abstraction layer over the Peripheral Driver API , such as USB, the SDHC interface, and the Cordio BLE stack. Libraries are enabled for a project with a convenient toggle switch (See the \"Libraries\" section of the Build Configuration Variables ). When a library is enabled, it may also offer its own Build Configuration Variables in addition to those already available in the core Build System . CMSIS-DSP The CMSIS-DSP library provides a suite of common Digital Signal Processing (DSP) functions that take advantage of hardware accelerated Floating Point Unit (FPU) available on microcontrollers with Arm Cortex-M cores. This library is distributed in the MSDK as a pre-compiled static library file, and the MSDK maintains a port of the official code examples in the ARM-DSP Examples folder for each microcontroller. Please refer to the CMSIS-DSP official documentation for more detailed documentation on the library functions and usage. CMSIS-DSP Supported Parts All microcontrollers with a Cortex M4 core are supported. Cordio Bluetooth Low Energy The Cordio Bluetooth Low Energy (BLE) library provides a full BLE stack for microcontrollers with an integrated BLE controller. The Cordio library warrants its own separate documentation. See the Cordio BLE User Guide . Cordio Supported Parts MAX32655 MAX32665 MAX32680 MAX32690 MAXUSB The MAXUSB library provides a higher-level interface for utilizing the built-in USB controller hardware available on some microcontrollers. This allows the microcontroller to enumerate as a USB device without the need for an external USB controller IC. MAXUSB Supported Parts MAX32570 MAX32650 MAX32655 and MAX32656 MAX32665-MAX32666 MAX32690 MAX78002 Miscellaneous Drivers The Libraries/MiscDrivers folder of the MSDK contains drivers for miscellaneous external components such as TFT displays, cameras, audio codecs, PMICs, pushbuttons, etc. These resources are usually closely tied with the Board Support Packages . SDHC The Secure Digital High Capacity (SDHC) library offers a higher-level interface built on top of the SDHC Peripheral Driver API that includes a FatFS File System implementation for managing files on SD cards. SDHC Supported Parts MAX32650 MAX32570 MAX32665-MAX32666 MAX78002 FreeRTOS FreeRTOS is a Real-Time Operating System (RTOS), which offers basic abstractions for multi-tasking and an OS layer specifically targeted at embedded systems with real-time requirements. The MSDK maintains an official support layer for the FreeRTOS kernel. Official documentation can be found on the FreeRTOS website . FreeRTOS Supported Parts FreeRTOS is supported by all parts in the MSDK. See the FreeRTOSDemo example application. FreeRTOS-Plus FreeRTOS-Plus is an additional library that implements addon functionality for the FreeRTOS kernel. The MSDK maintains support for some, but not all, available addons. FreeRTOS-Plus-CLI : Supported FreeRTOS-Plus-TCP : Not supported (Contributions welcome!)","title":"MSDK User Guide"},{"location":"USERGUIDE/#msdk-user-guide","text":"MSDK User Guide Overview Supported Operating Systems Supported Parts Supported Development Environments Supported Languages Installation Prerequisites Download Setup Completing the Installation on MacOS Maintenance Updates Older Versions and Offline Installer Development Resources Getting Started Key Concepts Getting Started with Visual Studio Code Setup (VS Code) Building and Running a Project (VS Code) Getting Started with Eclipse Setup (Eclipse) Building and Running a Project (Eclipse) Getting Started with Command-Line Development Setup (Command-Line) Windows Linux/MacOS Verification Building and Running an Example (Command-Line) Visual Studio Code Opening Example Projects How to Set the BSP (VS Code) Building a Project Cleaning a Project Flashing and Debugging Arm Core Debugging Breakpoints Peripheral Browsing Dual Core Debugging Eclipse Running Eclipse Creating a New Project Importing Examples How to Set the BSP (Eclipse) Building a Project Flashing and Debugging Segger J-Link Setup Guide (Eclipse) Keil MDK IAR Embedded Workbench Command-Line Development How to Set the BSP (Command-Line) Building on the Command-Line Cleaning on the Command-Line Flashing on the Command-Line Debugging on the Command-Line Common GDB Commands Board Support Packages How to Set the BSP BSP Table Custom BSPs Disabling BSPs Build System Build System Overview Default Build Behavior Build Configuration Variables How to Set a Build Configuration Variable Where to Set a Build Configuration Variable Precedence Hierarchy Build Configuration Variables Reference Table Peripheral Driver API Organization Examples Libraries CMSIS-DSP CMSIS-DSP Supported Parts Cordio Bluetooth Low Energy Cordio Supported Parts MAXUSB MAXUSB Supported Parts Miscellaneous Drivers SDHC SDHC Supported Parts FreeRTOS FreeRTOS Supported Parts FreeRTOS-Plus","title":"MSDK User Guide"},{"location":"USERGUIDE/#overview","text":"The Maxim Microcontrollers SDK (MSDK), now a part of Analog Devices , contains the necessary software and tools to develop firmware for the MAX32xxx and MAX78xxx Microcontrollers . That includes register and system startup files to enable low-level development for its supported parts . It also provides higher-level peripheral driver APIs (written in C) alongside various utilities, third-party libraries, Board Support Packages (BSPs), and a set of example programs for each microcontroller. Additionally, the MSDK includes a GCC-based toolchain, and builds are managed by a system of Makefiles (See GNU Make ). A custom fork of OpenOCD enables flashing and debugging. The MSDK's toolchain and build system offers a Command Line Interface (CLI), and project files for supported development environments are maintained that build on top of that CLI. This document describes the MSDK's installation, setup, and usage.","title":"Overview"},{"location":"USERGUIDE/#supported-operating-systems","text":"Windows (Windows 10 only) Linux (Ubuntu only) MacOS","title":"Supported Operating Systems"},{"location":"USERGUIDE/#supported-parts","text":"The MSDK officially supports the following microcontrollers and evaluation platforms. MAX32520 : ChipDNA Secure Microcontroller with Secure Boot for IoT Applications MAX32520-KIT MAX32520FTHR MAX32570 : Low-Power Arm Cortex-M4 Microcontroller with Contactless Radio for Secure Applications (Available by NDA only ) MAX32570-QNKIT MAX32570-MNKIT MAX32572 (Not Yet Publicly Available) MAX32572EVKIT (Not Yet Publicly Available) MAX32650 : Ultra-Low-Power Arm Cortex-M4 with FPU-Based Microcontroller (MCU) with 3MB Flash and 1MB SRAM MAX32650-EVKIT MAX32650FTHR MAX32651 : Ultra-Low-Power Arm Cortex-M4 with FPU-Based Microcontroller (MCU) with 3MB Flash and 1MB SRAM MAX32651-EVKIT MAX32655 : Low-Power, Arm Cortex-M4 Processor with FPU-Based Microcontroller and Bluetooth 5.2 MAX32655EVKIT MAX32655FTHR MAX32660 : Tiny, Ultra-Low-Power Arm Cortex-M4 Processor with FPU-Based Microcontroller (MCU) with 256KB Flash and 96KB SRAM MAX32660-EVSYS MAX32662 (Not Yet Publicly Available) MAX32662EVKIT (Not Yet Publicly Available) MAX32665-MAX32666 Family : Low-Power Arm Cortex-M4 with FPU-Based Microcontroller with Bluetooth 5 for Wearables MAX32666EVKIT MAX32666FTHR MAX32666FTHR2 (Product Page Not Yet Available) MAX32670 : High-Reliability, Ultra-Low-Power Microcontroller Powered by Arm Cortex-M4 Processor with FPU for Industrial and IoT MAX32670EVKIT MAX32672 : High-Reliability, Tiny, Ultra-Low-Power Arm Cortex-M4F Microcontroller with 12-Bit 1MSPS ADC MAX32672EVKIT MAX32675 : Ultra-Low-Power Arm Cortex-M4F with Precision Analog Front-End for Industrial and Medical Sensors MAX32675EVKIT MAX32675FTHR (Product Page Not Yet Available) MAX32680 : Ultra-Low-Power Arm Cortex-M4F with Precision Analog Front-End and Bluetooth LE 5.2 MAX32680EVKIT MAX32690 : Arm Cortex-M4 with FPU Microcontroller and Bluetooth LE 5 for Industrial and Wearables MAX32690EVKIT (Product Page Not Yet Available) MAX78000 : Artificial Intelligence Microcontroller with Ultra-Low-Power Convolutional Neural Network Accelerator MAX78000EVKIT MAX78000FTHR MAXREFDES178 MAX78002 : Artificial Intelligence Microcontroller with Low-Power Convolutional Neural Network Accelerator MAX78002EVKIT","title":"Supported Parts"},{"location":"USERGUIDE/#supported-development-environments","text":"Visual Studio Code Eclipse IDE IAR Embedded Workbench Keil MDK Command-line Development Supported shells (Windows): MSYS2 Supported shells (Ubuntu and MacOS): Bash Zsh","title":"Supported Development Environments"},{"location":"USERGUIDE/#supported-languages","text":"C Assembly (Arm and/or RISC-V instruction set depending on the microcontroller)","title":"Supported Languages"},{"location":"USERGUIDE/#installation","text":"","title":"Installation"},{"location":"USERGUIDE/#prerequisites","text":"Administrator rights (On MacOS) - Homebrew","title":"Prerequisites"},{"location":"USERGUIDE/#download","text":"The MSDK installer is available for supported Operating Systems from the download links below. Windows 10 Linux (Ubuntu) This file must be made executable before running ( chmod +x MaximMicrosSDK_linux.run ). Alternatively, set `Allow executing as program\" in the Ubuntu GUI. MacOS On MacOS, the installer is distributed inside a .dmg disk image file. Double-click the downloaded file to mount it. Afterward, the installer executable will be made available inside the mounted drive.","title":"Download"},{"location":"USERGUIDE/#setup","text":"Download the installer executable to an accessible location and launch it. Click Next to proceed from the Welcome screen. Choose the installation location. Select the components to install. It's recommended to install all components. Continue to the installation page, and click install to begin. Installation can be safely canceled at any time. Click Finish to complete the installation. You should now see the contents of the installation directory populated with the MSDK. Note: On MacOS, some additional steps are required.","title":"Setup"},{"location":"USERGUIDE/#completing-the-installation-on-macos","text":"On MacOS, some additional missing packages must be manually installed with Homebrew . For non-M1 platforms: Follow the instructions on the Homebrew home page to install Homebrew on your system. Then, open a terminal and run the command brew install make libusb-compat libftdi hidapi libusb The MSDK toolchain is dependent on GNU make 4.x+ being available as make , but Homebrew will install it as gmake . Modify your shell's startup script to account for this. Run brew info make for more details, and check the \"caveats\" section. ==> make: stable 4.4.1 (bottled) Utility for directing compilation https://www.gnu.org/software/make/ /usr/local/Cellar/make/4.4.1 (16 files, 1.3MB) * Poured from bottle using the formulae.brew.sh API on 2023-03-28 at 17:46:43 From: https://github.com/Homebrew/homebrew-core/blob/HEAD/Formula/make.rb License: GPL-3.0-only ==> Dependencies Build: lzip, lzip ==> Caveats GNU \"make\" has been installed as \"gmake\". If you need to use it as \"make\", you can add a \"gnubin\" directory to your PATH from your bashrc like: PATH=\"/usr/local/opt/make/libexec/gnubin:$PATH\" ==> Analytics install: 549 (30 days), 30,768 (90 days), 164,034 (365 days) install-on-request: 405 (30 days), 19,728 (90 days), 109,440 (365 days) build-error: 0 (30 days) Typically, this involves adding the following line to your shell's startup script ( ~/.zshrc , ~/.bashrc , etc.) PATH=\"/usr/local/opt/make/libexec/gnubin:$PATH\" Restart your shell and verify that make --version returns 4.x+. For M1 platforms : The MSDK's OpenOCD binaries ship pre-compiled for Intel Silicon (i386). As a result, you should use a Rosetta terminal on M1 platforms to install the i386 version of Homebrew and retrieve OpenOCD's dependencies with it. Installing from Rosetta ensures OpenOCD gets the packages with the architecture it needs. From there, Rosetta will handle the rest and allow running the binaries on the M1 platform's arm64 architecture. Additionally, the MSDK toolchain requires Make 4.x+, which must also be retrieved via Homebrew. The i386 version of Homebrew can be installed in parallel with the arm64 version and typically installs into a separate filesystem. Open a terminal and update Rosetta. softwareupdate --install-rosetta --agree-to-license Close the terminal. Create a new Rosetta terminal: Launch Finder. Navigate to Applications and find the \"Terminal\" application. Right-Click Terminal and Duplicate it. Rename it to \"Terminal i386\". This will be a new application shortcut to the Rosetta terminal. Right-Click \"Terminal i386\" > Get Info > Enable \"Open using Rosetta\" Launch the new \"Terminal i386\" and type arch to verify that it says i386 now. From your Rosetta terminal, follow the instructions on the Homebrew home page to install Homebrew on your system. Verify the correct version of Homebrew is running from your Rosetta terminal using the which brew command. This command should return a path beginning with /usr/local . Note: On systems with multiple or pre-existing Homebrew installations, the arm64 version of Homebrew may still take precedence over the newly installed x86_64 version. If which brew contains /opt/homebrew instead, you may need to edit your terminal profile's startup script. Alternatively, you can directly run the correct Homebrew binary using its absolute path. Run the command brew install make libusb-compat libftdi hidapi libusb (or, if you need to use the absolute path) /usr/local/homebrew/bin/brew make install libusb-compat libftdi hidapi libusb The MSDK toolchain is dependent on GNU make 4.x+ being available as make , but Homebrew will install it as gmake . Modify your shell's startup script to account for this. Run brew info make for more details, and check the \"caveats\" section. ==> make: stable 4.4.1 (bottled) Utility for directing compilation https://www.gnu.org/software/make/ /usr/local/Cellar/make/4.4.1 (16 files, 1.3MB) * Poured from bottle using the formulae.brew.sh API on 2023-03-28 at 17:46:43 From: https://github.com/Homebrew/homebrew-core/blob/HEAD/Formula/make.rb License: GPL-3.0-only ==> Dependencies Build: lzip, lzip ==> Caveats GNU \"make\" has been installed as \"gmake\". If you need to use it as \"make\", you can add a \"gnubin\" directory to your PATH from your bashrc like: PATH=\"/usr/local/opt/make/libexec/gnubin:$PATH\" ==> Analytics install: 549 (30 days), 30,768 (90 days), 164,034 (365 days) install-on-request: 405 (30 days), 19,728 (90 days), 109,440 (365 days) build-error: 0 (30 days) Typically, this involves adding the following line to your shell's startup script ( ~/.zshrc , ~/.bashrc , etc.) PATH=\"/usr/local/opt/make/libexec/gnubin:$PATH\" Restart your shell and verify that make --version returns 4.x+.","title":"Completing the Installation on MacOS"},{"location":"USERGUIDE/#maintenance","text":"An MSDK installation contains a MaintenanceTool executable program in its root directory. Use the Maintenance Tool to retrieve updates, manage components, and uninstall the MSDK.","title":"Maintenance"},{"location":"USERGUIDE/#updates","text":"The MSDK releases updates quarterly, and the Maintenance Tool will retrieve the latest release when Update components is run.","title":"Updates"},{"location":"USERGUIDE/#older-versions-and-offline-installer","text":"Older versions of the MSDK are available as an offline installer for each release tag. They are available on the Releases page of the MSDK GitHub and can be used to roll back to a specific MSDK release.","title":"Older Versions and Offline Installer"},{"location":"USERGUIDE/#development-resources","text":"Users can obtain development copies of the MSDK resources from Github . Setup instructions can be found in the repository's README .","title":"Development Resources"},{"location":"USERGUIDE/#getting-started","text":"The MSDK is designed for both evaluation and end-application development. The typical evaluation cycle usually involves setting up the development environment, running demos, and exercising the peripheral driver API on an evaluation platform . The typical development cycle typically involves building a prototype application on an evaluation platform first, then porting the application to a custom board. This section describes how to get started with the MSDK focusing on the evaluation cycle. First , review the Key Concepts below. Then, proceed to the section for your preferred IDE. Each sub-section is written as a self-contained quick-start with links to additional documentation on important topics. Getting Started with Visual Studio Code Getting Started with Eclipse Getting Started with Command-Line Development","title":"Getting Started"},{"location":"USERGUIDE/#key-concepts","text":"The MSDK supports multiple development environments with different features that may tailor to the user's preferences. There are a few key concepts to remember that are universal to MSDK development. Target Microcontroller : The target microcontroller refers to the base part number of the microcontroller used for development. The MSDK contains register-level support and startup files for each of its supported parts , and it's important to note that support files for a target microcontroller and its Board Support Packages are distinct from each other. For example, if the MAX78000EVKIT or MAX78000FTHR is being used, the Target Microcontroller is the MAX78000. Board Support Package (BSP) : The MSDK supports evaluation platforms for target microcontrollers with Board Support Packages . For microcontrollers with multiple evaluation platforms, multiple BSPs are available. These can be found in the Libraries/Boards folder of the MSDK installation. By default, most projects in the MSDK come pre-configured for the \"EVKIT\"-type BSP, which is generally the largest evaluation platform for that device with most (or all) pins broken out. It's important to note that the active BSP may need to be reconfigured for a project, which is done slightly differently for each development environment. System Environment : Your system's environment is a broad term that encapsulates the programs and variables available to your system's shell on the command line. The user is expected to have some basic familiarity with this concept. System Path : Your system's Path is a unique environment variable that tells it where to search for program binaries. The user is expected to be familiar with this concept and how to modify the system Path if necessary. Integrated Development Environment (IDE) : An IDE offers a higher-level user interface (typically with a GUI) that manages the tools for editing source code, building source code, flashing program binaries, and debugging . The abbreviation is frequently used in this document, and the MSDK supports multiple IDEs that can be used depending on preference. (See \"Supported Development Environments\" ) Build Configuration vs. Project Configuration : An MSDK project is comprised of two complementary systems: The Build System and the Integrated Development Environment (IDE) . These systems each offer their own configuration interfaces, and it's important to note what each is used for. The Build System manages source code compilation into program binaries and offers a Command-Line Interface (CLI) for setting Build Configuration Variables . The IDE offers a higher-level user interface (typically with a GUI) for managing a project and sits on top of the build system's CLI . Each IDE offers its own settings for managing fundamental aspects of the build, such as: Setting the Target Microcontroller Setting the Board Support Package Configuring the Environment and System Path for use with the MSDK toolchain","title":"Key Concepts"},{"location":"USERGUIDE/#getting-started-with-visual-studio-code","text":"The MSDK includes Visual Studio Code (\"VS Code\") support through the VSCode-Maxim project. This section walks through setup, opening, and running an example project with VS Code. This material is also available in video form targeting the MAX78000 in \"Understanding Artificial Intelligence Episode 8.5 - Visual Studio Code\" . For complete documentation, see the Visual Studio Code section of this User Guide.","title":"Getting Started with Visual Studio Code"},{"location":"USERGUIDE/#setup-vs-code","text":"The setup below only needs to be done once per MSDK installation . Download and install Visual Studio Code for your OS here . Launch Visual Studio Code. Install the Microsoft C/C++ extension . Use CTRL + SHIFT + P (or COMMAND + SHIFT + P on MacOS) to open the developer prompt. Type \"open user settings\" and select the \"Preferences: Open User Settings (JSON)\" option. Add the entries below to your user settings.json file. Change the MAXIM_PATH option to point to the MSDK installation . // There may be other settings up here... \"MAXIM_PATH\": \"Change me! Only use forward slashes (/) for this path\", \"update.mode\": \"manual\", \"extensions.autoUpdate\": false, // There may be other settings down here... For example, you might set \"MAXIM_PATH\":\"C:/MaximSDK\" on Windows, \"MAXIM_PATH\":\"/home/username/MaximSDK\" on Linux/MacOS, etc. Save your changes to the file with CTRL + S and restart VS Code.","title":"Setup (VS Code)"},{"location":"USERGUIDE/#building-and-running-a-project-vs-code","text":"Launch Visual Studio Code. Select File -> Open Folder... Navigate to an example project for the target microcontroller in the MSDK's Examples folder and open it with Select Folder . VS Code will prompt for trust the first time. Select Trust folder and enable all features The opened project should look something like this. Set the Board Support Package to match your evaluation platform. In VS Code, this is done by editing the .vscode/settings.json file and setting the \"board\" project configuration option. See Board Support Packages for more details. Save your changes to settings.json with CTRL+S . Reload the VS Code window. After changing any options in settings.json , a reload is necessary to force it to re-index VS Code's Intellisense engine. VS Code can be conveniently reloaded with the Reload Window developer command accessed with CTRL + SHIFT + P (or COMMAND + SHIFT + P on MacOS). Press the shortcut Ctrl+Shift+B to open the available Build Tasks (alternatively navigate to Terminal -> Run Build task... ). Run the \"build\" task to compile the project for the configured Target Microcontroller and BSP . Notice that the TARGET and BOARD Build Configuration Variables are set on the command line. The program binary is successfully compiled into the .elf program binary in the build sub-folder of the project. Connect a debug adapter between the host PC and the evaluation platform. Detailed instructions on this hardware setup can be found in the evaluation platform's Datasheet and Quick-Start Guide, which are available on its analog.com product page. Run the flash build task. Running this task will automatically build the project if needed, flash the program binary, and halt the program execution to await a debugger connection. Open the Run and Debug window ( CTRL+SHIFT+D ) and launch the debugger ( F5 ). Verify the program counter enters main successfully. Press Continue ( F5 ) to run the program. Continue | Step Over | Step Into | Step Out | Restart | Stop Exercise the debugger and press stop to disconnect when finished.","title":"Building and Running a Project (VS Code)"},{"location":"USERGUIDE/#getting-started-with-eclipse","text":"","title":"Getting Started with Eclipse"},{"location":"USERGUIDE/#setup-eclipse","text":"The only setup required to use Eclipse is to ensure that the \"Eclipse\" component has been selected during the MSDK installation . If the MSDK is already installed, Eclipse can be retrieved using the Maintenance Tool . This section is an Eclipse \"quick-start\" that walks through creating, building, and running a project. For complete documentation, see the Eclipse section of this User Guide.","title":"Setup (Eclipse)"},{"location":"USERGUIDE/#building-and-running-a-project-eclipse","text":"Launch Eclipse with its start menu shortcut. Ensure Eclipse is set to the C/C++ perspective in the top right corner. Otherwise, the new project wizard will not show up. Navigate to File -> New -> Maxim Microcontrollers . Enter the project name and hit Next . Follow the new project wizard. Chip type selects the Target Microcontroller Board type selects the Board Support Package (BSP) Example type selects the example project to be copied as the template for the new project. Adapter type selects the debug adapter to use. Select Finish to create the new project. Build the project using the Build hammer button (top left). Select the correct project in the Launch Configuration dropdown and set it to Debug mode. Use the Debug button (top left) to flash the program binary and connect the debugger. The Eclipse view will switch to debug mode, and the debugger will break on entry into main . Resume the program ( F8 ) using the top control bar and exercise the debugger. Terminate the debugger ( CTRL+F2 ) when finished.","title":"Building and Running a Project (Eclipse)"},{"location":"USERGUIDE/#getting-started-with-command-line-development","text":"This section demonstrates how to build MSDK example projects on the command line. It also shows how to flash and debug over the command line. The MAX78002EVKIT will be used as an example, but the same concepts apply to all parts. For more detailed documentation, see the Command-Line Development section of this User Guide.","title":"Getting Started with Command-Line Development"},{"location":"USERGUIDE/#setup-command-line","text":"","title":"Setup (Command-Line)"},{"location":"USERGUIDE/#windows","text":"On Windows, use the MinGW shortcut to launch an MSYS2/MinGW terminal. This shortcut points to Tools/MSYS2/msys.bat in an MSDK installation and correctly configures the user's environment for development.","title":"Windows"},{"location":"USERGUIDE/#linuxmacos","text":"On Linux and MacOS, copy the following contents into your shell's terminal profile/startup script to manually configure your environment for MSDK development. Depending on your system and shell, this could be ~/.profile , ~/.zprofile , ~/.bashrc , ~/.zshrc , etc. Command-line Linux/MacOS users are expected to know which file to edit for their particular system and preferences. # Set MAXIM_PATH to point to the MSDK export MAXIM_PATH=#changeme! # Add Arm Embedded GCC to path (v10.3) export ARM_GCC_ROOT=$MAXIM_PATH/Tools/GNUTools/10.3 export PATH=$ARM_GCC_ROOT/bin:$PATH # Add xPack RISC-V GCC to path (v10.2) export XPACK_GCC_ROOT=$MAXIM_PATH/Tools/xPack/riscv-none-embed-gcc/10.2.0-1.2 export PATH=$XPACK_GCC_ROOT/bin:$PATH # Add OpenOCD to path export OPENOCD_ROOT=$MAXIM_PATH/Tools/OpenOCD export PATH=$OPENOCD_ROOT:$PATH Change export MAXIM_PATH=#changeme! to the installation location of the MSDK. This will make the toolchain accessible from the command line by adding it to your system's path . # Set MAXIM_PATH environment variable export MAXIM_PATH=$HOME/MaximSDK","title":"Linux/MacOS"},{"location":"USERGUIDE/#verification","text":"Run the following commands to verify that the toolchain is accessible. They should display version numbers successfully. arm-none-eabi-gcc -v arm-none-eabi-gdb -v make -v openocd -v Any \"file not found\" errors indicate that MAXIM_PATH has not been set correctly or the system's Path has not been configured correctly.","title":"Verification"},{"location":"USERGUIDE/#building-and-running-an-example-command-line","text":"First, copy an example project to an accessible directory outside of the SDK. It is strongly recommended to keep the MSDK examples unmodified in case they need to be referenced again later. Launch your terminal. On Windows, use the MinGW shortcut or Tools/MSYS2/msys.bat file to launch the MSYS2 terminal. cd into the location of the copied example project. Run the following command to build the example: make -r -j -r is an option that improves build speed. -j enables parallel execution of the build in the maximum number of threads. Expected output: Loaded project.mk CC main.c CC /home/msdk/Libraries/Boards/MAX78002/EvKit_V1/Source/board.c CC /home/msdk/Libraries/Boards/MAX78002/EvKit_V1/../../../MiscDrivers/stdio.c CC /home/msdk/Libraries/Boards/MAX78002/EvKit_V1/../../../MiscDrivers/LED/led.c CC /home/msdk/Libraries/Boards/MAX78002/EvKit_V1/../../../MiscDrivers/PushButton/pb.c CC /home/msdk/Libraries/Boards/MAX78002/EvKit_V1/../../../MiscDrivers/Display/adafruit_3315_tft.c CC /home/msdk/Libraries/Boards/MAX78002/EvKit_V1/../../../MiscDrivers/Touchscreen/adafruit_3315_touch.c CC /home/msdk/Libraries/Boards/MAX78002/EvKit_V1/../../../MiscDrivers/Camera/camera.c CC /home/msdk/Libraries/Boards/MAX78002/EvKit_V1/../../../MiscDrivers/Camera/mipi_camera.c CC /home/msdk/Libraries/Boards/MAX78002/EvKit_V1/../../../MiscDrivers/Camera/ov7692.c CC /home/msdk/Libraries/Boards/MAX78002/EvKit_V1/../../../MiscDrivers/Camera/sccb.c AS /home/msdk/Libraries/CMSIS/Device/Maxim/MAX78002/Source/GCC/startup_max78002.S CC /home/msdk/Libraries/CMSIS/Device/Maxim/MAX78002/Source/heap.c CC /home/msdk/Libraries/CMSIS/Device/Maxim/MAX78002/Source/system_max78002.c LD /home/msdk/Examples/MAX78002/Hello_World/build/max78002.elf arm-none-eabi-size --format=berkeley /home/msdk/Examples/MAX78002/Hello_World/build/max78002.elf text data bss dec hex filename 35708 2504 1156 39368 99c8 /home/msdk/Examples/MAX78002/Hello_World/build/max78002.elf Connect a debug adapter between the host PC and the evaluation platform. Detailed instructions on this hardware setup can be found in the evaluation platform's Datasheet and Quick-Start Guide, which are available on its analog.com product page. Run the command below to launch an OpenOCD server , flash the program binary, and halt the program execution. openocd -s $MAXIM_PATH/Tools/OpenOCD/scripts -f interface/cmsis-dap.cfg -f target/max78002.cfg -c \"program build/max78002.elf verify; init; reset halt\" Expected output: Open On-Chip Debugger 0.11.0+dev-g4cdaa275b (2022-03-02-09:57) Licensed under GNU GPL v2 For bug reports, read http://openocd.org/doc/doxygen/bugs.html DEPRECATED! use 'adapter driver' not 'interface' Info : CMSIS-DAP: SWD supported Info : CMSIS-DAP: Atomic commands supported Info : CMSIS-DAP: Test domain timer supported Info : CMSIS-DAP: FW Version = 0256 Info : CMSIS-DAP: Serial# = 044417016af50c6500000000000000000000000097969906 Info : CMSIS-DAP: Interface Initialised (SWD) Info : SWCLK/TCK = 1 SWDIO/TMS = 1 TDI = 0 TDO = 0 nTRST = 0 nRESET = 1 Info : CMSIS-DAP: Interface ready Info : clock speed 2000 kHz Info : SWD DPIDR 0x2ba01477 Info : max32xxx.cpu: Cortex-M4 r0p1 processor detected Info : max32xxx.cpu: target has 6 breakpoints, 4 watchpoints Info : starting gdb server for max32xxx.cpu on 3333 Info : Listening on port 3333 for gdb connections Info : SWD DPIDR 0x2ba01477 target halted due to debug-request, current mode: Thread xPSR: 0x81000000 pc: 0x0000fff4 msp: 0x20003ff0 ** Programming Started ** ** Programming Finished ** ** Verify Started ** ** Verified OK ** Info : Listening on port 6666 for tcl connections Info : Listening on port 4444 for telnet connections # Note: OpenOCD is now waiting for a GDB client Launch a new separate terminal . On Windows, use the MinGW shortcut or Tools/MSYS2/msys.bat file to launch the MSYS2 terminal. cd into the location of the copied example project. Run the following command to launch a GDB client . arm-none-eabi-gdb --se=build/max78002.elf --se sets the symbol and executable file to the compiled program file. By default, the output filename matches the target microcontroller. Expected output: GNU gdb (GNU Arm Embedded Toolchain 10.3-2021.10) 10.2.90.20210621-git Copyright (C) 2021 Free Software Foundation, Inc. License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html> This is free software: you are free to change and redistribute it. There is NO WARRANTY, to the extent permitted by law. Type \"show copying\" and \"show warranty\" for details. This GDB was configured as \"--host=i686-w64-mingw32 --target=arm-none-eabi\". Type \"show configuration\" for configuration details. For bug reporting instructions, please see: <https://www.gnu.org/software/gdb/bugs/>. Find the GDB manual and other documentation resources online at: <http://www.gnu.org/software/gdb/documentation/>. For help, type \"help\". Type \"apropos word\" to search for commands related to \"word\"... Reading symbols from build/max78002.elf... (gdb) Connect the GDB Client to the OpenOCD server with the following command. target extended-remote localhost:3333 Expected output: Remote debugging using localhost:3333 0x0000fff4 in ?? () # Note: ?? may be present at this stage, which is OK. Reset the target microcontroller. monitor reset halt Expected output: SWD DPIDR 0x2ba01477 target halted due to debug-request, current mode: Thread xPSR: 0x81000000 pc: 0x0000fff4 msp: 0x20003ff0 Set a breakpoint on main . b main Expected output: Breakpoint 1 at 0x10000224: file main.c, line 62. Note: automatically using hardware breakpoints for read-only addresses. Continue the debugger. continue Expected output (for the Hello World example): Continuing. Breakpoint 1, main () at main.c:62 62 printf(\"Hello World!\\n\"); (Optional) Continue exercising the debugger. Run help for GDB help, or see Common GDB Commands . Quit GDB. quit Expected output: A debugging session is active. Inferior 1 [Remote target] will be detached. Quit anyway? (y or n) [answered Y; input not from terminal] Detaching from program: C:\\Users\\User\\codespace\\Hello_World\\build\\max78002.elf, Remote target [Inferior 1 (Remote target) detached] In the terminal window running the OpenOCD server , press CTRL + C to issue the shutdown command and quit.","title":"Building and Running an Example (Command-Line)"},{"location":"USERGUIDE/#visual-studio-code","text":"Support for Visual Studio Code is maintained for the MSDK and developed on the VSCode-Maxim GitHub repository. For setup/quick-start instructions, see \"Getting Started with Visual Studio Code\" first. This section offers detailed usage info focusing on the typical development cycle.","title":"Visual Studio Code"},{"location":"USERGUIDE/#opening-example-projects","text":"Visual Studio Code is built around a \"working directory\" paradigm. The editor is always rooted in a working directory, and the main mechanism for changing that directory is File -> Open Folder... As a result, you'll notice that there is no \"New Project\" mechanism. A \"project\" in VS Code is simply a folder. It will look inside the opened folder for a .vscode sub -folder to load project-specific settings from. (Note: You may need to enable viewing of hidden items in your file explorer to see the .vscode sub-folder). To open a project: 1. Launch Visual Studio Code. Select File -> Open Folder... Navigate to an example project for the target microcontroller in the MSDK's Examples folder and open it with Select Folder . VS Code will prompt for trust the first time. Select Trust folder and enable all features The opened project should look something like this. Verify the Board Support Package for the project is set correctly. See How to Set the BSP (VS Code) below.","title":"Opening Example Projects"},{"location":"USERGUIDE/#how-to-set-the-bsp-vs-code","text":"To set the BSP for an open project: Set the \"board\" project configuration option in .vscode/settings.json , which maps to the BOARD Build Configuration Variable . See Board Support Packages for a table of possible values. Reload the VS Code window to re-index its Intellisense engine. VS Code can be conveniently reloaded with the Reload Window developer command accessed with CTRL + SHIFT + P (or COMMAND + SHIFT + P on MacOS).","title":"How to Set the BSP (VS Code)"},{"location":"USERGUIDE/#building-a-project","text":"An open project will present four available build tasks from Terminal > Run Build task... or the shortcut Ctrl+Shift+B . Run the \"build\" task to compile the project for the configured Target Microcontroller and BSP . Notice the TARGET , BOARD , and PROJECT Build Configuration Variables being set on the command line, and the program binary successfully compiled into the .elf program binary in the build sub-folder of the project.","title":"Building a Project"},{"location":"USERGUIDE/#cleaning-a-project","text":"To clean a project, run the clean build task . This will delete the build folder and its contents. The next time the project is built, it will be rebuilt from scratch. It should be noted that clean will only remove the project's build output. The clean-periph task can be used to clean the project and the peripheral driver libraries.","title":"Cleaning a Project"},{"location":"USERGUIDE/#flashing-and-debugging","text":"This section assumes a debugger is connected between the host PC and the evaluation platform. For more detailed instructions on this hardware setup, refer to the evaluation platform's Datasheet and Quick-Start Guide, which are available on its analog.com product page.","title":"Flashing and Debugging"},{"location":"USERGUIDE/#arm-core-debugging","text":"Run the flash build task . Running this task will automatically build the project if needed, flash the program binary, and halt the program execution to await a debugger connection. Flashing does not happen automatically when launching the debugger . This is an intentional design choice for VS Code to allow the debugger to quickly restart the program under debug without a lengthy re-flash procedure. Open the Run and Debug window ( CTRL+SHIFT+D ) and launch the debugger ( F5 ). Use the Arm M4 profile. Verify the program counter enters main successfully. Press Continue ( F5 ) to run the program. The debugger control bar can be used to exercise the debugger further. Continue | Step Over | Step Into | Step Out | Restart | Stop","title":"Arm Core Debugging"},{"location":"USERGUIDE/#breakpoints","text":"Breakpoints can be set by clicking next to a line number in VS Code's editor. They are removed by clicking on them again. Additionally conditional breakpoints can be added by right-clicking on a line. The condition and condition type can be modified with the dropdown. This is useful for setting a breakpoint on a certain value in a for loop iterator or when a specific bit in a register is set, for example.","title":"Breakpoints"},{"location":"USERGUIDE/#peripheral-browsing","text":"A peripheral browser lets you quickly view the formatted register-level contents of the peripheral blocks on a target microcontroller under debug. Currently, VSCode-Maxim does not feature a true peripheral browser. Instead, watch expressions can be used to inspect peripherals at the register level. Watch expressions can be set for all registers. (For example, the sysctrl register below). Adding ,b lets you print out the value in binary Adding ,x prints the value in hex . Standard logical and bitwise operations are supported inside the watch expression. Register and variable values can be modified through these same watch-points. (Right click -> Set Value) It should be noted that the debugger's watch points are contextual , meaning that its symbol look-ups will depend on the active point in your program.","title":"Peripheral Browsing"},{"location":"USERGUIDE/#dual-core-debugging","text":"For microcontrollers with both an Arm M4 and a RISC-V core, the GDB (RISC-V) launch profile is provided to enable RISC-V debugging. The RISC-V core requires setup and handoff from the Arm M4 core. As a result, this is an advanced configuration requiring a unique combination of the project's source code, Makefiles, and VSCode-Maxim project settings. Such projects are appended with the -riscv suffix in the project's folder name. This section demonstrates how to debug -riscv projects in VS Code using the mnist-riscv project for the MAX78000 as an example. Connect both your Arm (SWD) and RISC-V (JTAG) debuggers. VSCode-Maxim projects come pre-configured to use the ARM-USB-OCD-H + ARM-JTAG-20-10 adapters for the RISC-V JTAG port. Ex: Make sure your Olimex debugger drivers are installed correctly. Sometimes they need to be updated using the \"zadig\" tool. See Section 3.3.3 of the Olimex User Manual , and use the Zadig tool to install WinUSB drivers. Download the max78000_riscv.cfg file and place it inside the Tools/OpenOCD/scripts/target folder of your MSDKinstallation. Open the project in VS Code. Run the \"Flash\" task. Launch the debugger using the GDB (Arm M4) profile first : ... which should hit the breakpoint in main.c ... Continue the debugger. The code in main.c will boot up the RISC-V core. You can optionally set a breakpoint on WakeISR to see when the RISC-V core has signaled it's ready. Now, switch the debugger profile to the GDB (RISC-V) profile and launch it. This will launch an additional instance on a separate port and connect to the Olimex adapter. The \"Signal 0\" exception below is a known issue caused by a reset bug on the RISC-V core. The exception message is harmless and can be safely ignored. From here, the debugger should be fully functional. The Arm vs. RISC-V debugger instance can be selected with the dropdown on the debugger control bar.","title":"Dual Core Debugging"},{"location":"USERGUIDE/#eclipse","text":"For setup/quick-start instructions, see \"Getting Started with Eclipse\" first. This section offers detailed usage info focusing on the typical development cycle.","title":"Eclipse"},{"location":"USERGUIDE/#running-eclipse","text":"Eclipse must be launched with the Eclipse MaximSDK shortcut. The shortcut points to the Tools/Eclipse/cdt/eclipse(.bat/.sh) file, which configures Eclipse's system environment for use with the MSDK toolchain. When Eclipse is launched, it will prompt for a workspace location. This is a local folder that Eclipse will copy its projects into.","title":"Running Eclipse"},{"location":"USERGUIDE/#creating-a-new-project","text":"Launch Eclipse. Ensure that the Eclipse is set to the C/C++ perspective in the top right corner. Otherwise, the new project wizard will not show up. Navigate to File -> New -> Maxim Microcontrollers . Enter the project name and hit Next . Follow the new project wizard. Chip type selects the Target Microcontroller Board type selects the Board Support Package (BSP) Example type selects the example project to be copied as the template for the new project. Adapter type selects the debug adapter to use. Select Finish to create the new project.","title":"Creating a New Project"},{"location":"USERGUIDE/#importing-examples","text":"Launch Eclipse. Use File -> Import to open the import wizard. Select General -> Existing Projects into Workspace and hit Next . Browse to the Examples folder in the MSDK installation for your target microcontroller and select the example projects to import into the workspace. Ensure that Copy projects into workspace is selected. This will copy the projects out of the MSDK and leave the originals unmodified. Select Finish to import the project(s). The projects should now show up in the Project Explorer.","title":"Importing Examples"},{"location":"USERGUIDE/#how-to-set-the-bsp-eclipse","text":"Imported Eclipse projects files are configured for the EVKIT -type BSP by default. To set the BSP: Right click the project name and select Properties . Navigate to C/C++ Build -> Environment . Set the BOARD Build Configuration Variable to match the target evaluation platform. See Board Support Packages for a table of possible values. clean and rebuild the project.","title":"How to Set the BSP (Eclipse)"},{"location":"USERGUIDE/#building-a-project_1","text":"Ensure that the Eclipse is set to the C/C++ perspective (top right). Select the correct project in the Launch Configuration dropdown. Use the Build hammer button (top left) to build the project.","title":"Building a Project"},{"location":"USERGUIDE/#flashing-and-debugging_1","text":"Connect a debug adapter between the host PC and the evaluation platform. For more detailed instructions on this hardware setup, refer to the evaluation platform's Datasheet and Quick-Start Guide, which are available on its analog.com product page. Ensure the correct project in the Launch Configuration dropdown is selected in Debug mode. Use the Debug button (top left) to flash the program binary and connect the debugger. The Eclipse view will switch to debug mode, and the debugger will break on entry into the main. Resume the program ( F8 ) using the top control bar and exercise the debugger. Terminate the debugger ( CTRL+F2 ) when finished.","title":"Flashing and Debugging"},{"location":"USERGUIDE/#segger-j-link-setup-guide-eclipse","text":"Eclipse offers built-in support for Segger J-Link debuggers. J-Link debugging can be enabled following the steps below: Download and install the latest Segger J-Link Software and Documentation from here Follow the instructions from the Segger J-Link Eclipse plugin here with the following modifications specific to the MSDK. Other options an be left at their defaults. Modify the Executable name under \"GDB Client Setup\" to arm-none-eabi-gdb${cross_suffix} Modify the \"Startup\" options to issue a monitor reset halt under initialization commands and uncheck Pre-run/Restart reset","title":"Segger J-Link Setup Guide (Eclipse)"},{"location":"USERGUIDE/#keil-mdk","text":"The Keil MDK Microcontroller Development Kit is developed and maintained by Arm. ADI maintains CMSIS Pack files supporting this environment. Supporting documentation is maintained by Arm, and can be found on the MDK5 page . The latest pack files can be found under the \"Maxim\" section of the device list .","title":"Keil MDK"},{"location":"USERGUIDE/#iar-embedded-workbench","text":"IAR Embedded Workbench is a third-party IDE that requires a software license. ADI maintains support files for this IDE in the form of CMSIS Pack files. Supporting documentation is maintained by IAR, and can be found on the Embedded Workbench Product Page under \"User Guides and documentation\".","title":"IAR Embedded Workbench"},{"location":"USERGUIDE/#command-line-development","text":"This section offers more detailed info on command-line development. For setup/quick-start, see \"Getting Started with Command-Line Development\" .","title":"Command-Line Development"},{"location":"USERGUIDE/#how-to-set-the-bsp-command-line","text":"To persistently the BSP, set the BOARD Build Configuration Variable . by editing the project.mk that can be found inside each project. # This file can be used to set build configuration # variables. These variables are defined in a file called # \"Makefile\" that is located next to this one. # For instructions on how to use this system, see # https://analog-devices-msdk.github.io/msdk/USERGUIDE/ # ********************************************************** # Add your config here! BOARD=FTHR_RevA # Set the BSP for the MAX78000FTHR Alternatively, set BOARD on the command line when building (i.e., make -r -j BOARD=FTHR_RevA ) to set/override the BSP for a single build.","title":"How to Set the BSP (Command-Line)"},{"location":"USERGUIDE/#building-on-the-command-line","text":"cd into the project folder. Run make Parallel Build (fastest build, but console message formatting may be mangled): make -r -j Serial Build make -r Take note of the output filename and location, which by default is the lowercase name of the Target microcontroller and created in the build folder.","title":"Building on the Command-Line"},{"location":"USERGUIDE/#cleaning-on-the-command-line","text":"cd into the project folder. Run make clean Project clean : make clean deletes the project build folder and all of its contents. Library clean : make distclean can be used to clean out all build products, including the project build folder and all peripheral driver libraries.","title":"Cleaning on the Command-Line"},{"location":"USERGUIDE/#flashing-on-the-command-line","text":"Build the project. Connect a debug adapter between the host PC and the evaluation platform. For more detailed instructions on this hardware setup, refer to the evaluation platform's Datasheet and Quick-Start Guide, which are available on its analog.com product page. Flash the program using openocd . Flash and exit: Use this command if you just want to flash the program but not debug . OpenOCD will flash the program and exit on completion. openocd -s $MAXIM_PATH/Tools/OpenOCD/scripts -f interface/cmsis-dap.cfg -f target/max78002.cfg -c \"program build/max78002.elf verify exit\" -f target/max78002.cfg sets the OpenOCD config file for the Target microcontroller . Supported options can be found in the Tools/OpenOCD/scripts/target folder. Change this to match the target microcontroller . -c \"program build/max78002.elf verify exit\" flashes the program binary. Change build/max78002.elf to match the correct filename. Expected output: Open On-Chip Debugger 0.11.0+dev-g4cdaa275b (2022-03-02-09:57) Licensed under GNU GPL v2 For bug reports, read http://openocd.org/doc/doxygen/bugs.html DEPRECATED! use 'adapter driver' not 'interface' Info : CMSIS-DAP: SWD supported Info : CMSIS-DAP: Atomic commands supported Info : CMSIS-DAP: Test domain timer supported Info : CMSIS-DAP: FW Version = 0256 Info : CMSIS-DAP: Serial# = 044417016af50c6500000000000000000000000097969906 Info : CMSIS-DAP: Interface Initialised (SWD) Info : SWCLK/TCK = 1 SWDIO/TMS = 1 TDI = 0 TDO = 0 nTRST = 0 nRESET = 1 Info : CMSIS-DAP: Interface ready Info : clock speed 2000 kHz Info : SWD DPIDR 0x2ba01477 Info : max32xxx.cpu: Cortex-M4 r0p1 processor detected Info : max32xxx.cpu: target has 6 breakpoints, 4 watchpoints Info : starting gdb server for max32xxx.cpu on 3333 Info : Listening on port 3333 for gdb connections Info : SWD DPIDR 0x2ba01477 target halted due to debug-request, current mode: Thread xPSR: 0x81000000 pc: 0x0000fff4 msp: 0x20003ff0 ** Programming Started ** ** Programming Finished ** ** Verify Started ** ** Verified OK ** shutdown command invoked Flash and hold: Use this if you want to also debug the program. OpenOCD will flash the program, reset the MAX78002, halt program execution, and wait for a GDB debugger client connection. openocd -s $MAXIM_PATH/Tools/OpenOCD/scripts -f interface/cmsis-dap.cfg -f target/max78002.cfg -c \"program build/max78002.elf verify; init; reset halt\" -f target/max78002.cfg sets the OpenOCD config file for the Target microcontroller . Supported options can be found in the Tools/OpenOCD/scripts/target folder. Change this to match the target microcontroller . -c \"program build/max78002.elf verify exit\" flashes the program binary. Change build/max78002.elf to match the correct filename. Expected output: Open On-Chip Debugger 0.11.0+dev-g4cdaa275b (2022-03-02-09:57) Licensed under GNU GPL v2 For bug reports, read http://openocd.org/doc/doxygen/bugs.html DEPRECATED! use 'adapter driver' not 'interface' Info : CMSIS-DAP: SWD supported Info : CMSIS-DAP: Atomic commands supported Info : CMSIS-DAP: Test domain timer supported Info : CMSIS-DAP: FW Version = 0256 Info : CMSIS-DAP: Serial# = 044417016af50c6500000000000000000000000097969906 Info : CMSIS-DAP: Interface Initialised (SWD) Info : SWCLK/TCK = 1 SWDIO/TMS = 1 TDI = 0 TDO = 0 nTRST = 0 nRESET = 1 Info : CMSIS-DAP: Interface ready Info : clock speed 2000 kHz Info : SWD DPIDR 0x2ba01477 Info : max32xxx.cpu: Cortex-M4 r0p1 processor detected Info : max32xxx.cpu: target has 6 breakpoints, 4 watchpoints Info : starting gdb server for max32xxx.cpu on 3333 Info : Listening on port 3333 for gdb connections Info : SWD DPIDR 0x2ba01477 target halted due to debug-request, current mode: Thread xPSR: 0x81000000 pc: 0x0000fff4 msp: 0x20003ff0 ** Programming Started ** ** Programming Finished ** ** Verify Started ** ** Verified OK ** Info : Listening on port 6666 for tcl connections Info : Listening on port 4444 for telnet connections # Note: OpenOCD is now waiting for a GDB client connection","title":"Flashing on the Command-Line"},{"location":"USERGUIDE/#debugging-on-the-command-line","text":"Flash the program using the Flash and Hold command. Launch an new separate terminal . On Windows, use the MinGW shortcut or Tools/MSYS2/msys.bat file to launch the MSYS2 terminal. cd into the location of the copied example project. Run the following command to launch a GDB client . arm-none-eabi-gdb --se=build/max78002.elf --se sets the symbol and executable file to the compiled program file. Change this to match the build output filename. Expected output: GNU gdb (GNU Arm Embedded Toolchain 10.3-2021.10) 10.2.90.20210621-git Copyright (C) 2021 Free Software Foundation, Inc. License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html> This is free software: you are free to change and redistribute it. There is NO WARRANTY, to the extent permitted by law. Type \"show copying\" and \"show warranty\" for details. This GDB was configured as \"--host=i686-w64-mingw32 --target=arm-none-eabi\". Type \"show configuration\" for configuration details. For bug reporting instructions, please see: <https://www.gnu.org/software/gdb/bugs/>. Find the GDB manual and other documentation resources online at: <http://www.gnu.org/software/gdb/documentation/>. For help, type \"help\". Type \"apropos word\" to search for commands related to \"word\"... Reading symbols from build/max78002.elf... (gdb) Connect the GDB Client to the OpenOCD server with the following command. target extended-remote localhost:3333 Expected output: Remote debugging using localhost:3333 0x0000fff4 in ?? () # Note: ?? may be present at this stage, which is OK. Reset the target microcontroller. monitor reset halt Expected output: SWD DPIDR 0x2ba01477 target halted due to debug-request, current mode: Thread xPSR: 0x81000000 pc: 0x0000fff4 msp: 0x20003ff0 Set a breakpoint on main . b main Expected output: Breakpoint 1 at 0x10000224: file main.c, line 62. Note: automatically using hardware breakpoints for read-only addresses. Continue the debugger. continue Expected output (for the Hello World example): Continuing. Breakpoint 1, main () at main.c:62 62 printf(\"Hello World!\\n\"); (Optional) Continue exercising the debugger. Run help for GDB help, or see Common GDB Commands . Quit GDB. quit Expected output: A debugging session is active. Inferior 1 [Remote target] will be detached. Quit anyway? (y or n) [answered Y; input not from terminal] Detaching from program: C:\\Users\\User\\codespace\\Hello_World\\build\\max78002.elf, Remote target [Inferior 1 (Remote target) detached] Quit OpenOCD. In the terminal window running the OpenOCD server , press CTRL + C to issue the shutdown command.","title":"Debugging on the Command-Line"},{"location":"USERGUIDE/#common-gdb-commands","text":"Command Short Command Description monitor halt Halt the microcontroller. monitor reset halt Reset the microcontroller and immediately halt. monitor max32xxx mass_erase 0 Mass erase the flash. file <filename> Set the program file to <filename> load Flash the current program file continue c Continue execution. break <arg> b <arg> Set a breakpoint. <arg> can be a function name, file:line_number, or address. print <variable> p Print the value of a variable. The variable must be in the current scope. backtrace bt Print contents of the stack frame. step s Execute the next instruction. next n Execute the next line of code. finish f Continue to the end of the current function. info reg Print the values of the ARM registers. help Print descriptions for available commands help <cmd> Print description for given command. quit q Quit the GDB client","title":"Common GDB Commands"},{"location":"USERGUIDE/#board-support-packages","text":"The MSDK supports multiple parts and evaluation platforms (see supported parts ) through \"Board Support Packages\" (BSPs) . For microcontrollers with multiple evaluation platforms, multiple BSPs will be available. The role of a BSP is to provide a hardware abstraction layer for the initialization and management of board-level hardware such as serial interfaces, pushbuttons, LEDs, external peripheral devices, TFT displays, etc. which will vary between evaluation platforms. The BSP abstraction layer also improves code portability to custom devices. The first task when opening or creating any project is to ensure the BSP is set correctly.","title":"Board Support Packages"},{"location":"USERGUIDE/#how-to-set-the-bsp","text":"To set the BSP for a project: In VS Code : How to Set the BSP (VS Code) In Eclipse : How to Set the BSP (Eclipse) Command-Line Development: How to Set the BSP (Command-Line)","title":"How to Set the BSP"},{"location":"USERGUIDE/#bsp-table","text":"Available BSPs are located in the Libraries/Boards folder for each Target Microcontroller . The name of a BSP's folder is used with the BOARD build configuration variable to build a project for a specific BSP. The table below matches the correct BOARD values to external part numbers . External Part Number TARGET BOARD MAX32520-KIT MAX32520 EvKit_V1 MAX32520FTHR MAX32520 MAX32520FTHR MAX32650-EVKIT MAX32650 EvKit_V1 MAX32650FTHR MAX32650 FTHR_APPS_A MAX32655EVKIT MAX32655 EvKit_V1 MAX32655FTHR MAX32655 FTHR_Apps_P1 MAX32660-EVSYS MAX32660 EvKit_V1 MAX32662EVKIT MAX32662 EvKit_V1 MAX32666EVKIT MAX32665 EvKit_V1 MAX32666FTHR MAX32665 FTHR MAX32666FTHR2 MAX32665 FTHR2 MAX32670EVKIT MAX32670 EvKit_V1 MAX32672EVKIT MAX32672 EvKit_V1 MAX32672FTHR MAX32672 FTHR MAX32675EVKIT MAX32675 EvKit_V1 MAX32675FTHR MAX32675 FTHR_Apps_B MAX32680EVKIT MAX32680 EvKit_V1 MAX32690EVKIT MAX32690 EvKit_V1 MAX78000EVKIT MAX78000 EvKit_V1 MAX78000FTHR MAX78000 FTHR_RevA MAXREFDES178 MAX78000 MAXREFDES178 MAX78002EVKIT MAX78002 EvKit_V1","title":"BSP Table"},{"location":"USERGUIDE/#custom-bsps","text":"For custom boards, additional BSPs can be easily created and added to the MSDK. Inspecting the Libraries/CMSIS/Device/Maxim/TARGET/Source/system_TARGET.c for a target microcontroller shows how the BSP is integrated and which startup functions can be implemented. For example, the MAX78000's system_max78000.c startup file shows that PreInit and Board_Init are weak functions that can be overridden. They are called from the default SystemInit implementation, which can also be overridden. /* This function is called before C runtime initialization and can be * implemented by the application for early initializations. If a value other * than '0' is returned, the C runtime initialization will be skipped. * * You may over-ride this function in your program by defining a custom * PreInit(), but care should be taken to reproduce the initialization steps * or a non-functional system may result. */ __weak int PreInit(void) { /* Do nothing */ return 0; } /* This function can be implemented by the application to initialize the board */ __weak int Board_Init(void) { /* Do nothing */ return 0; } /* This function is called just before control is transferred to main(). * * You may over-ride this function in your program by defining a custom * SystemInit(), but care should be taken to reproduce the initialization * steps or a non-functional system may result. */ __weak void SystemInit(void) { /* Configure the interrupt controller to use the application vector table in */ /* the application space */ #if defined(__CC_ARM) || defined(__GNUC__) /* IAR sets the VTOR pointer incorrectly and causes stack corruption */ SCB->VTOR = (uint32_t)__isr_vector; #endif /* __CC_ARM || __GNUC__ */ /* Enable instruction cache */ MXC_ICC_Enable(MXC_ICC0); /* Enable FPU on Cortex-M4, which occupies coprocessor slots 10 and 11 */ /* Grant full access, per \"Table B3-24 CPACR bit assignments\". */ /* DDI0403D \"ARMv7-M Architecture Reference Manual\" */ SCB->CPACR |= SCB_CPACR_CP10_Msk | SCB_CPACR_CP11_Msk; __DSB(); __ISB(); SystemCoreClockUpdate(); Board_Init(); } A custom BSP can implement one or all of the weak functions. To do so, it's recommended to create a new directory inside the Libraries/Boards folder for the target microcontroller with the file structure below. The name of the created directory will be the string to use with the BOARD build configuration variable to select the custom BSP. Libraries \u2514\u2500 Boards \u2514\u2500 TARGET \u2514\u2500 CustomBSP \u251c\u2500 Include | \u2514\u2500 board.h \u251c\u2500 Source | \u2514\u2500 board.c \u2514\u2500 board.mk The following contents can be used as a bare-bones starter template. board.h // board.h #define BOARD_CUSTOM // ^ This type of compiler definition is // sometimes useful. It allows application code // to check if a specific BSP is being used. // Ex: #ifdef BOARD_CUSTOM // ... // #endif /** * \\brief Initialize the BSP and board interfaces. * \\returns #E_NO_ERROR if everything is successful */ int Board_Init(void); board.c //board.c #include \"board.h\" #include \"mxc_error.h\" int Board_Init(void) { // Implement me! return E_NO_ERROR; } board.mk ifeq \"$(BOARD_DIR)\" \"\" # This Makefile will self-locate if BOARD_DIR is not specified. BOARD_DIR := $(dir $(abspath $(lastword $(MAKEFILE_LIST)))) endif SRCS += board.c VPATH += $(BOARD_DIR)/Source IPATH += $(BOARD_DIR)/Include","title":"Custom BSPs"},{"location":"USERGUIDE/#disabling-bsps","text":"It should also be noted that BSP integration can be disabled entirely by setting the LIB_BOARD build configuration variable to 0. This will skip the inclusion of the BSP's board.mk file entirely, and the default system initialization functions will be used.","title":"Disabling BSPs"},{"location":"USERGUIDE/#build-system","text":"","title":"Build System"},{"location":"USERGUIDE/#build-system-overview","text":"The Build System manages the compilation of source code into program binaries and offers a Command-Line Interface (CLI) for setting Build Configuration Variables . All IDEs interface with this system. The Build System is managed by two files found in a project's root directory, one called Makefile and one called project.mk . These files are used by the GNU Make program (which is a part of the MSDK toolchain) to locate and build a project's source code. Makefile is the \"core\" file and should not be edited directly. Instead, it exposes the CLI that can be accessed in the project.mk file, on the command line, in your system's environment, or through your IDE. It also comes with a default configuration that is suitable for most projects. project.mk offers a convenient and stable access point for advanced build configuration, and this is the file that should be edited if necessary. When the command make is run from inside of a project folder, the program make will resolve any project-specific settings and then build the project's source code.","title":"Build System Overview"},{"location":"USERGUIDE/#default-build-behavior","text":"By default, the build system will auto-search the root project directory for source code ( *.c ) and header files ( *.h ) to compile into a program binary. The optional include and src directories are also searched if they exist. Root Project Directory \u251c\u2500 project.mk \u251c\u2500 Makefile \u251c\u2500 *.h \u251c\u2500 *.c \u251c\u2500include # <-- Optional \u2514\u2500 *.h \u251c\u2500src # <-- Optional \u2514\u2500 *.c Additionally, a project's build system will come pre-configured for a specific Target Microcontroller and its primary BSP . The default configuration is suitable for most use cases, but a system of Build Configuration Variables is available if additional configuration is needed.","title":"Default Build Behavior"},{"location":"USERGUIDE/#build-configuration-variables","text":"A Build Configuration Variable is a Makefile variable and therefore follows the same rules. However, they have been streamlined to be made much easier to use, so most of the official GNU Make documentation is only needed for advanced use cases.","title":"Build Configuration Variables"},{"location":"USERGUIDE/#how-to-set-a-build-configuration-variable","text":"To set a standard configuration variable, use the = syntax ... VARIABLE=VALUE The = operator is used for most configuration variables with a few exceptions (documented in the reference table ) when a variable should contain a list of values . In such cases, use += the syntax to add values to the list. VARIABLE+=VALUE1 VARIABLE+=VALUE2","title":"How to Set a Build Configuration Variable"},{"location":"USERGUIDE/#where-to-set-a-build-configuration-variable","text":"For most variables, you should set them in the project.mk file (exceptions are documented in the reference table and IDE-specific sections). For example, to enable hardware floating-point acceleration for a project, the MFLOAT_ABI configuration variable can be used with a value of hard . The contents of project.mk might then look as follows: ( Inside project.mk ) # This file can be used to set build configuration # variables. These variables are defined in a file called # \"Makefile\" that is located next to this one. # For instructions on how to use this system, see # https://analog-devices-msdk.github.io/msdk/USERGUIDE/ # ********************************************************** MFLOAT_ABI=hard # Enable hardware floating point acceleration It should also be noted that configuration variables can be set on the command line as well. For example make MFLOAT_ABI=hard will have the same effect. Additionally, environment variables can be used. For example (on Linux) export MFLOAT_ABI=hard will set the hardware floating point acceleration as the default for all projects with an environment variable. However, there is a precedence hierarchy that should be taken into consideration.","title":"Where to Set a Build Configuration Variable"},{"location":"USERGUIDE/#precedence-hierarchy","text":"The precedence hierarchy for the value of a configuration variable is: IDE/command-line > project.mk > environment variable > default value If a value is set in an IDE and project.mk, the IDE's value will take precedence. However, the \"override\" directive can be used in project.mk to give it max precedence.","title":"Precedence Hierarchy"},{"location":"USERGUIDE/#build-configuration-variables-reference-table","text":"Configuration Variable Description Details TARGET Set the Target Microcontroller If you are using an IDE, set this variable in the IDE's settings instead of project.mk BOARD Set the Board Support Package (BSP) If you are using an IDE, set this variable in the IDE's settings instead of project.mk. See Board Support Packages for more details. When you change this option, it's usually a good idea to fully clean your project, then rebuild. MAXIM_PATH (Optional) Specify the location of the MSDK This optional variable can be used to change where the Makefile looks for the MSDK installation. By default, the build system will attempt to locate the MSDK with a relative path. If a project is moved outside of the SDK, this variable must be set to the absolute path of the MSDK installation. CAMERA (Optional) Set the Camera drivers to use This option is only useful for the MAX78000 and MAX78002 and sets the camera drivers to use for the project. Permitted values are HM01B0 , HM0360_MONO , HM0360_COLOR , OV5642 , OV7692 (default), or PAG7920 . Camera drivers can be found in the Libraries/MiscDrivers/Camera folder. Depending on the selected camera, a compiler definition may be added to the build. See the board.mk file for the active BSP for more details. VPATH Where to search for source (.c) files Use the += operator with this variable . This controls where the Makefile will look for source code files. If AUTOSEARCH is enabled (which it is by default), all source code files in the directories specified by this option will be automatically added to the build. If AUTOSEARCH is disabled, this tells the Makefile where to look for the files specified by SRCS . IPATH Where to search for header (.h) files Use the += operator with this variable . This controls where the Makefile will look for header files. Unlike the VPATH option, this is not related to AUTOSEARCH . Individual header files are not ever manually added to the build. Instead, you only need to specify the location of your header files. AUTOSEARCH Automatically search for source (.c) files Enable or disable the automatic detection of .c files on VPATH (enabled by default). Set to 0 to disable or 1 to enable. If auto-search is disabled, source files must be manually added to SRCS . SRCS List of source (.c) files to add to the build Use the += operator with this variable . All of the files in this list will be added to the build. If AUTOSEARCH is enabled, this is most useful for adding the full absolute path to a singular source file to selectively add to the build. If AUTOSEARCH is disabled, all of the source files for the project must be added to SRCS , and they must also all be located on an entry in VPATH . Otherwise, a full path relative to the Makefile must be used. PROJECT Set the output filename This controls the output filename of the build. File extensions should not be included in the filename. For VS Code, you should use the project_name advanced config option instead of project.mk. MXC_OPTIMIZE_CFLAGS Set the optimization level See Optimize Options for more details. Normal builds will default to -Og , which is good for debugging, while release builds will default to -O2 . PROJ_CFLAGS Add a compiler flag to the build Use the += operator with this variable . Compiler flags can be added with this option, including compiler definitions. For each value, the same syntax should be used as if the compiler flag was passed in over the command line. These can include standard GCC options and/or ARM-specific options. PROJ_AFLAGS Add an assembler flag to the build Use the += operator with this variable . Assembler flags can be added with this option. MFLOAT_ABI Set the floating point acceleration level Sets the floating-point acceleration level. Permitted values are hard , soft , and softfp (default). To enable full hardware acceleration instructions, use hard , but keep in mind that all libraries your source code uses must also be compiled with hard . If there is any conflict, you'll get a linker error. For more details, see -mfloat-abi under ARM Options . LINKERFILE Set the linkerfile to use Set the linkerfile with this option. The file should exist in Libraries/CMSIS/Device/Maxim/TARGET/Source/GCC in the MSDK, or it should be placed inside the root directory of the project. PROJ_LDFLAGS Add a linker flag to the build Use the += operator with this variable . Flags can be passed to the linker with this option. See GCC Options for Linking LIB_BOARD Include the BSP library (enabled by default) Inclusion of the Board-Support Package (BSP) library, which is enabled by default, can be toggled with this variable. Set to 0 to disable or 1 to enable. LIB_PERIPHDRIVERS Include the peripheral driver library (enabled by default) The peripheral driver library can be toggled with this option. If disabled, you'll lose access to the higher-level driver functions but still have access to the register-level files. Set to 0 to disable or 1 to enable. LIB_CMSIS_DSP Include the CMSIS-DSP library The CMSIS-DSP library can be enabled with this option. Set to 0 to disable or 1 to enable. LIB_CORDIO Include the Cordio library The Cordio BLE library can be included with this option. This is only applicable for microcontrollers with an integrated BLE controller. LIB_FCL Include the Free Cryptographic Library (FCL) This option toggles the Free Cryptographic Library (FCL), which is a collection of software-implemented common cryptographic functions that can be included with this option. Set to 0 to disable or 1 to enable. LIB_FREERTOS Include the FreeRTOS library The FreeRTOS library can be enabled with this option, which is an open-source Real-Time Operating System (RTOS). Set to 0 to disable or 1 to enable. LIB_LC3 Include the LC3 codec library This option enables the inclusion of the Low Complexity Communication Codec (LC3), which is an efficient low latency audio codec. Set to 0 to disable or 1 to enable. LIB_LITTLEFS Include the littleFS library This option toggles the \"Little File System\" library - a small filesystem library designed for microcontrollers. Set to 0 to disable or 1 to enable. LIB_LWIP Include the lwIP library LIB_MAXUSB Include the MaxUSB library This option toggles the inclusion of the MAXUSB library, which facilitates the use of the native USB peripherals on some microcontrollers. Set to 0 to disable or 1 to enable. LIB_SDHC Include the SDHC library This option toggles the Secure Digital High Capacity (SDHC) library, which can be used to interface with SD cards. Additionally, it enables the FatFS library, which implements a generic FAT filesystem. SBT Toggle SBT integration Toggles integration with the Secure Boot Tools (SBTs) . These are a suite of applications designed for use with microcontrollers that have secure bootloaders. When this is enabled, some additional rules become available such as make sla and make scpa . Set to 0 to disable or 1 to enable. MAXIM_SBT_DIR Where to find the SBTs This option can be used to manually specify the location of the SBTs. Usually, this is not necessary. By default, the Tools/SBT directory of the MaximSDK will be searched. If the SBT installer is used, it will set the MAXIM_SBT_DIR environment variable to point to itself automatically. TARGET_SEC Secure part number to use Some secure microcontrollers have multiple secure variants, and this option can be used to specify the variant to use with the SBTs. Defaults are intelligently selected and can be found in $(MAXIM_SBT_DIR)/SBT-config.mk SCP_PACKETS Where to build the scp_packets folder Defaults to build/scp_packets TEST_KEY Which test key to sign applications with Defaults to $(MAXIM_SBT_DIR)/devices/$(TARGET_SEC)/keys/maximtestcrk.key , which is the Maxim test key that can be used for development.","title":"Build Configuration Variables Reference Table"},{"location":"USERGUIDE/#peripheral-driver-api","text":"A microcontroller is made up of a Central Processing Unit (CPU) that is surrounded by additional peripheral hardware blocks such as timers, memory controllers, UART controllers, ADCs, RTCs, audio interfaces, and many more. The Peripheral Driver API is an important core library in the MSDK that allows the CPU to utilize the microcontroller's hardware blocks over a higher-level Application Programming Interface (API) . The links below will open detailed API references for each microcontroller. Offline copies of these API references can also be found in the Documentation folder of the MSDK installation . MAX32520 API MAX32650 API MAX32655 API MAX32660 API MAX32665-MAX32666 API MAX32670 API MAX32672 API MAX32675 API MAX32680 API MAX32690 API MAX78000 API MAX78002 API","title":"Peripheral Driver API"},{"location":"USERGUIDE/#organization","text":"The Peripheral Driver API's source code is organized as follows: Header files (.h) can be found in the Libraries/PeriphDrivers/Include folder. These files contain function declarations for the API, describing the function prototypes and their associated documentation. Source files (.c) can be found in the Libraries/PeriphDrivers/Source folder. These files contain the function definitions for the API - the implementations of the functions declared by the header files. The implementation files are further organized based on die type and hardware revision . This is worth noting when browsing or debugging through the drivers. The die type files follow the _MEXX or _AIXX naming convention These files' responsibility is to manage microcontroller-specific implementation details that may interact with other peripheral APIs before ultimately calling the revision-specific files. The _hardware revision_ files follow the _revX naming convention. These files contain the pure driver implementation for a peripheral block and typically interact with the hardware almost entirely at the register level.","title":"Organization"},{"location":"USERGUIDE/#examples","text":"The MSDK contains examples for each microcontroller that demonstrate the usage of its Peripheral APIs . They can be found in the Examples folder of an MSDK installation. Each example contains a README.md file describing what it does. In general, there is at least one example per peripheral block, and the example's name will indicate what it matches (i.e., DMA , ADC , SPI ).","title":"Examples"},{"location":"USERGUIDE/#libraries","text":"The MSDK contains a large number of libraries, both third-party and in-house. These libraries are an extension to the \"core\" SDK resources and contain drivers for various external components such as TFT displays, cameras, accelerometers, audio codecs, and other devices. The MSDK also contains libraries for more advanced internal hardware peripherals that provide an additional abstraction layer over the Peripheral Driver API , such as USB, the SDHC interface, and the Cordio BLE stack. Libraries are enabled for a project with a convenient toggle switch (See the \"Libraries\" section of the Build Configuration Variables ). When a library is enabled, it may also offer its own Build Configuration Variables in addition to those already available in the core Build System .","title":"Libraries"},{"location":"USERGUIDE/#cmsis-dsp","text":"The CMSIS-DSP library provides a suite of common Digital Signal Processing (DSP) functions that take advantage of hardware accelerated Floating Point Unit (FPU) available on microcontrollers with Arm Cortex-M cores. This library is distributed in the MSDK as a pre-compiled static library file, and the MSDK maintains a port of the official code examples in the ARM-DSP Examples folder for each microcontroller. Please refer to the CMSIS-DSP official documentation for more detailed documentation on the library functions and usage.","title":"CMSIS-DSP"},{"location":"USERGUIDE/#cmsis-dsp-supported-parts","text":"All microcontrollers with a Cortex M4 core are supported.","title":"CMSIS-DSP Supported Parts"},{"location":"USERGUIDE/#cordio-bluetooth-low-energy","text":"The Cordio Bluetooth Low Energy (BLE) library provides a full BLE stack for microcontrollers with an integrated BLE controller. The Cordio library warrants its own separate documentation. See the Cordio BLE User Guide .","title":"Cordio Bluetooth Low Energy"},{"location":"USERGUIDE/#cordio-supported-parts","text":"MAX32655 MAX32665 MAX32680 MAX32690","title":"Cordio Supported Parts"},{"location":"USERGUIDE/#maxusb","text":"The MAXUSB library provides a higher-level interface for utilizing the built-in USB controller hardware available on some microcontrollers. This allows the microcontroller to enumerate as a USB device without the need for an external USB controller IC.","title":"MAXUSB"},{"location":"USERGUIDE/#maxusb-supported-parts","text":"MAX32570 MAX32650 MAX32655 and MAX32656 MAX32665-MAX32666 MAX32690 MAX78002","title":"MAXUSB Supported Parts"},{"location":"USERGUIDE/#miscellaneous-drivers","text":"The Libraries/MiscDrivers folder of the MSDK contains drivers for miscellaneous external components such as TFT displays, cameras, audio codecs, PMICs, pushbuttons, etc. These resources are usually closely tied with the Board Support Packages .","title":"Miscellaneous Drivers"},{"location":"USERGUIDE/#sdhc","text":"The Secure Digital High Capacity (SDHC) library offers a higher-level interface built on top of the SDHC Peripheral Driver API that includes a FatFS File System implementation for managing files on SD cards.","title":"SDHC"},{"location":"USERGUIDE/#sdhc-supported-parts","text":"MAX32650 MAX32570 MAX32665-MAX32666 MAX78002","title":"SDHC Supported Parts"},{"location":"USERGUIDE/#freertos","text":"FreeRTOS is a Real-Time Operating System (RTOS), which offers basic abstractions for multi-tasking and an OS layer specifically targeted at embedded systems with real-time requirements. The MSDK maintains an official support layer for the FreeRTOS kernel. Official documentation can be found on the FreeRTOS website .","title":"FreeRTOS"},{"location":"USERGUIDE/#freertos-supported-parts","text":"FreeRTOS is supported by all parts in the MSDK. See the FreeRTOSDemo example application.","title":"FreeRTOS Supported Parts"},{"location":"USERGUIDE/#freertos-plus","text":"FreeRTOS-Plus is an additional library that implements addon functionality for the FreeRTOS kernel. The MSDK maintains support for some, but not all, available addons. FreeRTOS-Plus-CLI : Supported FreeRTOS-Plus-TCP : Not supported (Contributions welcome!)","title":"FreeRTOS-Plus"},{"location":"Libraries/Cordio/docs/CORDIO_USERGUIDE/","text":"Cordio Bluetooth LE User Guide This library implements the Bluetooth Low Energy stack, forked from Packetcraft . It depends on additional libraries within the msdk repository. All applications utilizing this library can be found in the Examples directory of an MSDK installation. Supported Features LE Dual Mode Topology: Advertise/Scan while maintaining multiple adjacent connections. 2M PHY: High-speed PHY with 2 Mbps symbol rate. Coded PHY: Forward error correction, 125 kbps or 500 kbps symbol rate. Extended Advertising: Enhanced advertising and scanning. Periodic Advertising: Broadcasting and receiving periodic advertisements. EATT: Enhanced Attribute protocol. LE Secure Connections: LE Secure Connections is an enhanced security feature introduced in Bluetooth v4.2. It uses a Federal Information Processing Standards (FIPS) compliant algorithm called Elliptic Curve Diffie Hellman (ECDH) for key generation. Data Length Extension: Extend the maximum data length supported in a connection. LE Power Control: Dynamic TX power control. *OTA firmware update: Over-the-air firmware update is not a standard Bluetooth feature. We have a wireless data exchange service that can be used for OTA firmware updates. See the BLE_otac_otas examples, the ADI Attach smartphone app, and BLE-PyDex for details. Features in Development Direction finding: Detect the direction of the incoming signal. Also known as Angle of Arrival (AoA) and Angle of Departure (AoD). Hardware support on MAX32655 and MAX32690, unavailable on MAX32665, software in development. LE Audio: Isochronous audio with Bluetooth LE. Hardware support on all platforms, software in development. Getting Started The best application to get started with is the BLE_periph application. It is a simple peripheral application that will allow you to advertise and connect with a central device such as a smartphone. Follow the MSDK User Guide instructions to install the necessary tools and create a new project. Build and run the BLE_periph application for the appropriate target. Building Most of the source code will be built in a library that can be shared between applications. Different variants will be built based on settings in project.mk . # Cordio library options # This will include the Bluetooth Host portions of the stack in the build. BLE_HOST = 1 # This will include the Bluetooth Controller portions of the stack in the build. BLE_CONTROLLER = 1 # Typical system on chip devices will typically include both the Host and the Controller. # Applications for lower level testing will only include the Controller, and use an HCI # interface to communicate with an external Host. # Peripheral devices will be typical for micro controllers and mobile, battery powered devices # These devices will advertise and can be connected to central devices. INIT_PERIPHERAL = 1 # Central devices are typically high power devices like a cell phone or a base station # Central devices will scan and initiate connections with peripherals. INIT_CENTRAL = 0 # TRACE option # Set to 0 to disable # Set to 1 to enable serial port trace messages # Set to 2 to enable verbose messages TRACE = 1 Bluetooth LE Basics References The Bluetooth Special Interest Group (SIG) has documentation available on its website . For the latest core specification, refer to the documentation page. This will be your best resource for learning the details of Bluetooth Low Energy. These books are also excellent references for developers. Getting Started with Bluetooth Low Energy by O'Reilly Bluetooth Low Energy: The Developer's Handbook by Robin Heydon Architecture The Bluetooth stack closely resembles the layers of the network stack. We have the application layer at the top and the physical layer at the bottom. Each layer encapsulates the data and passes it to the appropriate section of the upper and lower layers. The Host Controller Interface (HCI) is the common point where devices are split. Typically this interface is over an asynchronous protocol such as UART. Some devices will define proprietary interfaces between the application and host layers. Multi-core SOCs can also use the HCI or proprietary interfaces to split the stack between multiple CPUs. Test equipment will have a USB interface and act as a Host device when testing the Controller layers. Devices under test will use a USB to UART adapter and act as Controller devices. States These are the common states used in Bluetooth LE communication. Typically devices will be in only one of these states at a time, but it is possible for devices to be in all simultaneously. Advertising Devices in this state are broadcasting advertisement packets to scanning/initiating devices. This is an asynchronous operation that has no synchronization with peer devices. Advertising devices transmit without any previous knowledge of peer devices. Advertising and scanning operations are done on channels 37, 38, and 39. The interval between advertising events is configurable between 20 ms and 10.24 s. Scanning / Initiating Devices in the scanning state listen for advertising devices and can send scan optionally requests for additional information. The scanning interval and window settings are configurable. If a device is scanning with the intent of connecting to a specific device, that is called the initiating state. The initiating devices will send a connection indication to the desired advertising device to indicate its desire to create a connection. Connected Once an initiating device sends the connection request and the advertising device accepts the connection request, the two devices enter the connected state. This is a point-to-point connection allowing devices to exchange information directly. In order to minimize interference, devices in the connected state will hop between channels 0-36 in a pseudo-random order. The channel hopping information is communicated in the connection indication. Each connection event is separated by the connection interval. This interval is configurable from 7.5 ms to 4 s. The master will always transmit first and receive second. The Slave will always receive first and transmit second. Devices will typically always send and receive at least one packet in each interval, and they can optionally transmit and receive multiple packets in each interval. Cordio Stack Architecture This document describes the Cordio software architecture. Refer to the Bluetooth specification Volume 1, Part A for additional information regarding the Bluetooth architecture. Application The App Framework performs many operations common to Bluetooth LE embedded applications, such as: Application-level device, connection, and security management. Simple user interface abstractions for button press handling, sounds, display, and other user feedback. An abstracted device database for storing bonding data and other device parameters. Profiles and Services The GATT Profile specifies the structure in which profile data is exchanged. This structure defines basic elements, such as services and characteristics, used in a profile. The top level of the hierarchy is a profile. A profile is composed of one or more services necessary to fulfill a use case. A service is composed of characteristics or references to other services. Each characteristic contains a value and may contain optional information about the value. The service and characteristic and the components of the characteristic (i.e., value and descriptors) contain the profile data and are all stored in Attributes on the server. Wireless Stack Framework The Wireless Software Foundation (WSF) is a simple OS wrapper, porting layer, and general-purpose software service used by the software system. The goal of WSF is to stay small and lean, supporting only the basic services required by the stack. It consists of the following: Event handler service with event and message passing. Timer service. Queue and buffer management service. Portable data types. Critical sections and task locking. Trace and assert diagnostic services. Security interfaces for encryption and random number generation. Platform Adaption Layer The Platform Adaption Layer is the abstraction between the software stack and the hardware. It includes APIs for timers, UART, RTC, and various system-level functions such as sleep and memory management. Attribute Protocol The ATT subsystem implements the attribute protocol and generic attribute profile (GATT). It contains two independent subsystems: The attribute protocol client (ATTC) and the attribute protocol server (ATTS). ATTC implements all attribute protocol client features and is designed to meet the client requirements of the generic attribute profile. ATTC can support multiple simultaneous connections to different servers. ATTS implements all attribute protocol server features and has support for multiple simultaneous client connections. ATTS also implements the server features defined by the generic attribute profile. Device Manager The DM subsystem implements device management procedures required by the stack. These procedures are partitioned by procedure category and device role (master or slave). The following procedures are implemented in DM: Advertising and device visibility: Enable/disable advertising, set advertising parameters and data, and set connectivity and discoverability. Scanning and device discovery: Start/stop scanning, set scan parameters, advertising reports, and name discovery. Connection management: Create/accept/remove connections, set/update connection parameters, and read RSSI. Security management: Bonding, storage of security parameters, authentication, encryption, authorization, random address management. Local device management: Initialization and reset, set local parameters, vendor-specific commands. DM procedures support the Generic Access Profile (GAP) when applicable. Security Manager Protocol The Security Manager Protocol (SMP) is the peer-to-peer protocol used to generate encryption keys and identity keys. The protocol operates over a dedicated fixed L2CAP channel. The SMP block also manages the storage of the encryption keys and identity keys and is responsible for generating random addresses and resolving random addresses to known device identities. The SMP block interfaces directly with the Controller to provide stored keys used for encryption and authentication during the encryption or pairing procedures. The SMP subsystem implements the security manager protocol. It contains two independent subsystems: The initiator (SMPI). SMPI implements the initiator features of the security manager protocol and has support for multiple simultaneous connections. The responder (SMPR). SMPR implements the responder features of the security manager protocol and has support for only one connection (by Bluetooth specification design). SMP also implements the cryptographic toolbox, which uses AES. The interface to AES is asynchronous and abstracted through WSF. SMP also implements functions to support data signing. Logical Link Control Adaptation Protocol The L2CAP (Logical Link Control Adaptation Protocol) resource manager block is responsible for managing the ordering of submission of PDU fragments to the baseband and some relative scheduling between channels to ensure that L2CAP channels with QoS commitments are not denied access to the physical channel due to Controller resource exhaustion. This is required because the architectural model does not assume that a Controller has limitless buffering or that the HCI is a pipe of infinite bandwidth. L2CAP Resource Managers may also carry out traffic conformance policing to ensure that applications are submitting L2CAP SDUs within the bounds of their negotiated QoS settings. The general Bluetooth data transport model assumes well-behaved applications and does not define how an implementation is expected to deal with this problem. Host Controller Interface The HCI subsystem implements the host-controller interface specification. This specification defines commands, events, and data packets sent between a Bluetooth LE protocol stack on a host and a link layer on a controller. The HCI API is optimized to be a thin interface layer for a single-chip system. It is configurable for either a single-chip system or a traditional system with wired HCI. This reconfigurability is accomplished through a layered implementation. A core layer can be configured for either a single-chip system or wired HCI. A transport and driver layer below the core layer can be configured for different wired transports such as UART. Link Layer The link layer is responsible for the creation, modification, and release of logical links (and, if required, their associated logical transports), as well as the update of parameters related to physical links between devices. The link layer achieves this by communicating with the link layer in remote Bluetooth devices using the Link Layer Protocol (LL) in LE. The LL protocol allows the creation of new logical links and logical transports between devices when required, as well as the general control of link and transport attributes such as the enabling of encryption on the logical transport and the adapting of transmit power on the physical link. Physical Layer The PHY block is responsible for transmitting and receiving packets of information on the physical channel. A control path between the baseband and the PHY block allows the baseband block to control the timing and frequency carrier of the PHY block. The PHY block transforms a stream of data to and from the physical channel and the baseband into required formats. ADI Attach ADI Attach is a smartphone application that can be used for Bluetooth debugging and development. Scan for advertising peripherals. Connect to devices and discover profiles and services. Read and write characteristics. Subscribe to notifications. Perform over-the-air firmware updates with supporting devices. BLE-PyDex BLE-PyDex is a hardware-agnostic Bluetooth device explorer designed to aid in the development and debugging of Bluetooth applications. https://github.com/EdwinFairchild/BLE-PyDex Frequently asked questions How do I change the advertising parameters? Peripheral applications will have a static structure that contains all of the advertising parameters. If run-time changes are desired, you must call AppAdvStop() before changing the parameters and AppAdvStart() to resume. With this configuration, the device will advertise at a fast interval (300 * 0.625 = 187.5 ms) for 5 seconds. It will then advertise slowly (1600 * 0.625 = 1000 ms) indefinitely. /*! configurable parameters for advertising */ static const appAdvCfg_t datsAdvCfg = { { 5000, 0}, /*! Advertising durations in ms, 0 is infinite */ { 300, 1600} /*! Advertising intervals in 0.625 ms units */ }; How do I change the connection parameters? Only the master of the connection can change the connection parameters. Peripheral devices can request a change, but only the master can accept and set the connection parameters. Cell phones and mobile operating systems have different restrictions on connection parameters. Peripheral applications have the following structure that is used to request connection parameter updates. /* iOS connection parameter update requirements The connection parameter request may be rejected if it does not meet the following guidelines: * Peripheral Latency of up to 30 connection intervals. * Supervision Timeout from 2 seconds to 6 seconds. * Interval Min of at least 15 ms. * Interval Min is a multiple of 15 ms. * One of the following: * Interval Max at least 15 ms greater than Interval Min. * Interval Max and Interval Min both set to 15 ms. * Interval Max * (Peripheral Latency + 1) of 2 seconds or less. * Supervision Timeout greater than Interval Max * (Peripheral Latency + 1) * 3. */ /*! configurable parameters for connection parameter update */ static const appUpdateCfg_t datsUpdateCfg = { 0, /*! ^ Connection idle period in ms before attempting connection parameter update. set to zero to disable */ (15 * 8 / 1.25), /*! Minimum connection interval in 1.25ms units */ (15 * 12 / 1.25), /*! Maximum connection interval in 1.25ms units */ 0, /*! Connection latency */ 600, /*! Supervision timeout in 10ms units */ 5 /*! Number of update attempts before giving up */ }; The DmConnUpdate() function can also be used to request a connection parameter update from the peripheral or initiate one from the master. /*************************************************************************************************/ /*! * \\brief Update the connection parameters of an open connection * * \\param connId Connection identifier. * \\param pConnSpec Connection specification. * * \\return None. */ /*************************************************************************************************/ void DmConnUpdate(dmConnId_t connId, hciConnSpec_t *pConnSpec); How do I use the low-power modes? All of the applications will enter sleep mode in idle when built with DEBUG=0 . The Wireless Stack Framework (WSF) operating system will call PalSysSleep() mode when idle. With DEBUG=1 , the CPU will stay in active mode to leave the debugger enabled. To enter the lowest power states, refer to the BLE_FreeRTOS application. This will create FreeRTOS tasks for the Cordio stack and allow users to add additional tasks. Enable configUSE_TICKLESS_IDLE , and the device will enter standby mode and deep sleep between events. WARNING: The CPU debugger is disabled in sleep modes. If your application enters sleep mode directly after reset, it will be difficult to debug and reprogram. How do I send unformatted data like a UART? Unfortunately, there is no Bluetooth SIG-defined standard for this protocol. This stack has a proprietary data transfer service that is used to transmit unformatted data between devices. Refer to the BLE_dats (BLE Data Server) for the peripheral application. You can connect to this device with the BLE_datc (BLE data client) application to see simple data transmission. Refer to the BLE_dats and BLE_dats README for more information. Additional Documentation Documentation for Python tools used for Bluetooth development and debugging can be found here . Documentation for each of the supporting applications can be found below: BLE4 BLE5 FreeRTOS DAT Client/Server BLE FCC BLE Fit BLE MCS OTA Client/Server BLE Periph RF Test Certification Bluetooth LE Mesh solution implementing the Bluetooth Mesh Profile 1.0 and the Bluetooth Mesh Model 1.0 wireless technical specifications QDID 116593 Bluetooth LE Host protocol stack implementing Bluetooth Core 5.2 specification QDID 146344 Bluetooth LE Link Layer protocol stack implementing Bluetooth 5.2 specification QDID 146281 MAX32655 controller subsystem QDID 159701 MAX32665 controller subsystem QDID 142345 Consult the Bluetooth Qualification Process for further details regarding certification.","title":"Cordio BLE User Guide"},{"location":"Libraries/Cordio/docs/CORDIO_USERGUIDE/#cordio-bluetooth-le-user-guide","text":"This library implements the Bluetooth Low Energy stack, forked from Packetcraft . It depends on additional libraries within the msdk repository. All applications utilizing this library can be found in the Examples directory of an MSDK installation.","title":"Cordio Bluetooth LE User Guide"},{"location":"Libraries/Cordio/docs/CORDIO_USERGUIDE/#supported-features","text":"LE Dual Mode Topology: Advertise/Scan while maintaining multiple adjacent connections. 2M PHY: High-speed PHY with 2 Mbps symbol rate. Coded PHY: Forward error correction, 125 kbps or 500 kbps symbol rate. Extended Advertising: Enhanced advertising and scanning. Periodic Advertising: Broadcasting and receiving periodic advertisements. EATT: Enhanced Attribute protocol. LE Secure Connections: LE Secure Connections is an enhanced security feature introduced in Bluetooth v4.2. It uses a Federal Information Processing Standards (FIPS) compliant algorithm called Elliptic Curve Diffie Hellman (ECDH) for key generation. Data Length Extension: Extend the maximum data length supported in a connection. LE Power Control: Dynamic TX power control. *OTA firmware update: Over-the-air firmware update is not a standard Bluetooth feature. We have a wireless data exchange service that can be used for OTA firmware updates. See the BLE_otac_otas examples, the ADI Attach smartphone app, and BLE-PyDex for details.","title":"Supported Features"},{"location":"Libraries/Cordio/docs/CORDIO_USERGUIDE/#features-in-development","text":"Direction finding: Detect the direction of the incoming signal. Also known as Angle of Arrival (AoA) and Angle of Departure (AoD). Hardware support on MAX32655 and MAX32690, unavailable on MAX32665, software in development. LE Audio: Isochronous audio with Bluetooth LE. Hardware support on all platforms, software in development.","title":"Features in Development"},{"location":"Libraries/Cordio/docs/CORDIO_USERGUIDE/#getting-started","text":"The best application to get started with is the BLE_periph application. It is a simple peripheral application that will allow you to advertise and connect with a central device such as a smartphone. Follow the MSDK User Guide instructions to install the necessary tools and create a new project. Build and run the BLE_periph application for the appropriate target.","title":"Getting Started"},{"location":"Libraries/Cordio/docs/CORDIO_USERGUIDE/#building","text":"Most of the source code will be built in a library that can be shared between applications. Different variants will be built based on settings in project.mk . # Cordio library options # This will include the Bluetooth Host portions of the stack in the build. BLE_HOST = 1 # This will include the Bluetooth Controller portions of the stack in the build. BLE_CONTROLLER = 1 # Typical system on chip devices will typically include both the Host and the Controller. # Applications for lower level testing will only include the Controller, and use an HCI # interface to communicate with an external Host. # Peripheral devices will be typical for micro controllers and mobile, battery powered devices # These devices will advertise and can be connected to central devices. INIT_PERIPHERAL = 1 # Central devices are typically high power devices like a cell phone or a base station # Central devices will scan and initiate connections with peripherals. INIT_CENTRAL = 0 # TRACE option # Set to 0 to disable # Set to 1 to enable serial port trace messages # Set to 2 to enable verbose messages TRACE = 1","title":"Building"},{"location":"Libraries/Cordio/docs/CORDIO_USERGUIDE/#bluetooth-le-basics","text":"","title":"Bluetooth LE Basics"},{"location":"Libraries/Cordio/docs/CORDIO_USERGUIDE/#references","text":"The Bluetooth Special Interest Group (SIG) has documentation available on its website . For the latest core specification, refer to the documentation page. This will be your best resource for learning the details of Bluetooth Low Energy. These books are also excellent references for developers. Getting Started with Bluetooth Low Energy by O'Reilly Bluetooth Low Energy: The Developer's Handbook by Robin Heydon","title":"References"},{"location":"Libraries/Cordio/docs/CORDIO_USERGUIDE/#architecture","text":"The Bluetooth stack closely resembles the layers of the network stack. We have the application layer at the top and the physical layer at the bottom. Each layer encapsulates the data and passes it to the appropriate section of the upper and lower layers. The Host Controller Interface (HCI) is the common point where devices are split. Typically this interface is over an asynchronous protocol such as UART. Some devices will define proprietary interfaces between the application and host layers. Multi-core SOCs can also use the HCI or proprietary interfaces to split the stack between multiple CPUs. Test equipment will have a USB interface and act as a Host device when testing the Controller layers. Devices under test will use a USB to UART adapter and act as Controller devices.","title":"Architecture"},{"location":"Libraries/Cordio/docs/CORDIO_USERGUIDE/#states","text":"These are the common states used in Bluetooth LE communication. Typically devices will be in only one of these states at a time, but it is possible for devices to be in all simultaneously.","title":"States"},{"location":"Libraries/Cordio/docs/CORDIO_USERGUIDE/#advertising","text":"Devices in this state are broadcasting advertisement packets to scanning/initiating devices. This is an asynchronous operation that has no synchronization with peer devices. Advertising devices transmit without any previous knowledge of peer devices. Advertising and scanning operations are done on channels 37, 38, and 39. The interval between advertising events is configurable between 20 ms and 10.24 s.","title":"Advertising"},{"location":"Libraries/Cordio/docs/CORDIO_USERGUIDE/#scanning-initiating","text":"Devices in the scanning state listen for advertising devices and can send scan optionally requests for additional information. The scanning interval and window settings are configurable. If a device is scanning with the intent of connecting to a specific device, that is called the initiating state. The initiating devices will send a connection indication to the desired advertising device to indicate its desire to create a connection.","title":"Scanning / Initiating"},{"location":"Libraries/Cordio/docs/CORDIO_USERGUIDE/#connected","text":"Once an initiating device sends the connection request and the advertising device accepts the connection request, the two devices enter the connected state. This is a point-to-point connection allowing devices to exchange information directly. In order to minimize interference, devices in the connected state will hop between channels 0-36 in a pseudo-random order. The channel hopping information is communicated in the connection indication. Each connection event is separated by the connection interval. This interval is configurable from 7.5 ms to 4 s. The master will always transmit first and receive second. The Slave will always receive first and transmit second. Devices will typically always send and receive at least one packet in each interval, and they can optionally transmit and receive multiple packets in each interval.","title":"Connected"},{"location":"Libraries/Cordio/docs/CORDIO_USERGUIDE/#cordio-stack-architecture","text":"This document describes the Cordio software architecture. Refer to the Bluetooth specification Volume 1, Part A for additional information regarding the Bluetooth architecture.","title":"Cordio Stack Architecture"},{"location":"Libraries/Cordio/docs/CORDIO_USERGUIDE/#application","text":"The App Framework performs many operations common to Bluetooth LE embedded applications, such as: Application-level device, connection, and security management. Simple user interface abstractions for button press handling, sounds, display, and other user feedback. An abstracted device database for storing bonding data and other device parameters.","title":"Application"},{"location":"Libraries/Cordio/docs/CORDIO_USERGUIDE/#profiles-and-services","text":"The GATT Profile specifies the structure in which profile data is exchanged. This structure defines basic elements, such as services and characteristics, used in a profile. The top level of the hierarchy is a profile. A profile is composed of one or more services necessary to fulfill a use case. A service is composed of characteristics or references to other services. Each characteristic contains a value and may contain optional information about the value. The service and characteristic and the components of the characteristic (i.e., value and descriptors) contain the profile data and are all stored in Attributes on the server.","title":"Profiles and Services"},{"location":"Libraries/Cordio/docs/CORDIO_USERGUIDE/#wireless-stack-framework","text":"The Wireless Software Foundation (WSF) is a simple OS wrapper, porting layer, and general-purpose software service used by the software system. The goal of WSF is to stay small and lean, supporting only the basic services required by the stack. It consists of the following: Event handler service with event and message passing. Timer service. Queue and buffer management service. Portable data types. Critical sections and task locking. Trace and assert diagnostic services. Security interfaces for encryption and random number generation.","title":"Wireless Stack Framework"},{"location":"Libraries/Cordio/docs/CORDIO_USERGUIDE/#platform-adaption-layer","text":"The Platform Adaption Layer is the abstraction between the software stack and the hardware. It includes APIs for timers, UART, RTC, and various system-level functions such as sleep and memory management.","title":"Platform Adaption Layer"},{"location":"Libraries/Cordio/docs/CORDIO_USERGUIDE/#attribute-protocol","text":"The ATT subsystem implements the attribute protocol and generic attribute profile (GATT). It contains two independent subsystems: The attribute protocol client (ATTC) and the attribute protocol server (ATTS). ATTC implements all attribute protocol client features and is designed to meet the client requirements of the generic attribute profile. ATTC can support multiple simultaneous connections to different servers. ATTS implements all attribute protocol server features and has support for multiple simultaneous client connections. ATTS also implements the server features defined by the generic attribute profile.","title":"Attribute Protocol"},{"location":"Libraries/Cordio/docs/CORDIO_USERGUIDE/#device-manager","text":"The DM subsystem implements device management procedures required by the stack. These procedures are partitioned by procedure category and device role (master or slave). The following procedures are implemented in DM: Advertising and device visibility: Enable/disable advertising, set advertising parameters and data, and set connectivity and discoverability. Scanning and device discovery: Start/stop scanning, set scan parameters, advertising reports, and name discovery. Connection management: Create/accept/remove connections, set/update connection parameters, and read RSSI. Security management: Bonding, storage of security parameters, authentication, encryption, authorization, random address management. Local device management: Initialization and reset, set local parameters, vendor-specific commands. DM procedures support the Generic Access Profile (GAP) when applicable.","title":"Device Manager"},{"location":"Libraries/Cordio/docs/CORDIO_USERGUIDE/#security-manager-protocol","text":"The Security Manager Protocol (SMP) is the peer-to-peer protocol used to generate encryption keys and identity keys. The protocol operates over a dedicated fixed L2CAP channel. The SMP block also manages the storage of the encryption keys and identity keys and is responsible for generating random addresses and resolving random addresses to known device identities. The SMP block interfaces directly with the Controller to provide stored keys used for encryption and authentication during the encryption or pairing procedures. The SMP subsystem implements the security manager protocol. It contains two independent subsystems: The initiator (SMPI). SMPI implements the initiator features of the security manager protocol and has support for multiple simultaneous connections. The responder (SMPR). SMPR implements the responder features of the security manager protocol and has support for only one connection (by Bluetooth specification design). SMP also implements the cryptographic toolbox, which uses AES. The interface to AES is asynchronous and abstracted through WSF. SMP also implements functions to support data signing.","title":"Security Manager Protocol"},{"location":"Libraries/Cordio/docs/CORDIO_USERGUIDE/#logical-link-control-adaptation-protocol","text":"The L2CAP (Logical Link Control Adaptation Protocol) resource manager block is responsible for managing the ordering of submission of PDU fragments to the baseband and some relative scheduling between channels to ensure that L2CAP channels with QoS commitments are not denied access to the physical channel due to Controller resource exhaustion. This is required because the architectural model does not assume that a Controller has limitless buffering or that the HCI is a pipe of infinite bandwidth. L2CAP Resource Managers may also carry out traffic conformance policing to ensure that applications are submitting L2CAP SDUs within the bounds of their negotiated QoS settings. The general Bluetooth data transport model assumes well-behaved applications and does not define how an implementation is expected to deal with this problem.","title":"Logical Link Control Adaptation Protocol"},{"location":"Libraries/Cordio/docs/CORDIO_USERGUIDE/#host-controller-interface","text":"The HCI subsystem implements the host-controller interface specification. This specification defines commands, events, and data packets sent between a Bluetooth LE protocol stack on a host and a link layer on a controller. The HCI API is optimized to be a thin interface layer for a single-chip system. It is configurable for either a single-chip system or a traditional system with wired HCI. This reconfigurability is accomplished through a layered implementation. A core layer can be configured for either a single-chip system or wired HCI. A transport and driver layer below the core layer can be configured for different wired transports such as UART.","title":"Host Controller Interface"},{"location":"Libraries/Cordio/docs/CORDIO_USERGUIDE/#link-layer","text":"The link layer is responsible for the creation, modification, and release of logical links (and, if required, their associated logical transports), as well as the update of parameters related to physical links between devices. The link layer achieves this by communicating with the link layer in remote Bluetooth devices using the Link Layer Protocol (LL) in LE. The LL protocol allows the creation of new logical links and logical transports between devices when required, as well as the general control of link and transport attributes such as the enabling of encryption on the logical transport and the adapting of transmit power on the physical link.","title":"Link Layer"},{"location":"Libraries/Cordio/docs/CORDIO_USERGUIDE/#physical-layer","text":"The PHY block is responsible for transmitting and receiving packets of information on the physical channel. A control path between the baseband and the PHY block allows the baseband block to control the timing and frequency carrier of the PHY block. The PHY block transforms a stream of data to and from the physical channel and the baseband into required formats.","title":"Physical Layer"},{"location":"Libraries/Cordio/docs/CORDIO_USERGUIDE/#adi-attach","text":"ADI Attach is a smartphone application that can be used for Bluetooth debugging and development. Scan for advertising peripherals. Connect to devices and discover profiles and services. Read and write characteristics. Subscribe to notifications. Perform over-the-air firmware updates with supporting devices.","title":"ADI Attach"},{"location":"Libraries/Cordio/docs/CORDIO_USERGUIDE/#ble-pydex","text":"BLE-PyDex is a hardware-agnostic Bluetooth device explorer designed to aid in the development and debugging of Bluetooth applications. https://github.com/EdwinFairchild/BLE-PyDex","title":"BLE-PyDex"},{"location":"Libraries/Cordio/docs/CORDIO_USERGUIDE/#frequently-asked-questions","text":"","title":"Frequently asked questions"},{"location":"Libraries/Cordio/docs/CORDIO_USERGUIDE/#how-do-i-change-the-advertising-parameters","text":"Peripheral applications will have a static structure that contains all of the advertising parameters. If run-time changes are desired, you must call AppAdvStop() before changing the parameters and AppAdvStart() to resume. With this configuration, the device will advertise at a fast interval (300 * 0.625 = 187.5 ms) for 5 seconds. It will then advertise slowly (1600 * 0.625 = 1000 ms) indefinitely. /*! configurable parameters for advertising */ static const appAdvCfg_t datsAdvCfg = { { 5000, 0}, /*! Advertising durations in ms, 0 is infinite */ { 300, 1600} /*! Advertising intervals in 0.625 ms units */ };","title":"How do I change the advertising parameters?"},{"location":"Libraries/Cordio/docs/CORDIO_USERGUIDE/#how-do-i-change-the-connection-parameters","text":"Only the master of the connection can change the connection parameters. Peripheral devices can request a change, but only the master can accept and set the connection parameters. Cell phones and mobile operating systems have different restrictions on connection parameters. Peripheral applications have the following structure that is used to request connection parameter updates. /* iOS connection parameter update requirements The connection parameter request may be rejected if it does not meet the following guidelines: * Peripheral Latency of up to 30 connection intervals. * Supervision Timeout from 2 seconds to 6 seconds. * Interval Min of at least 15 ms. * Interval Min is a multiple of 15 ms. * One of the following: * Interval Max at least 15 ms greater than Interval Min. * Interval Max and Interval Min both set to 15 ms. * Interval Max * (Peripheral Latency + 1) of 2 seconds or less. * Supervision Timeout greater than Interval Max * (Peripheral Latency + 1) * 3. */ /*! configurable parameters for connection parameter update */ static const appUpdateCfg_t datsUpdateCfg = { 0, /*! ^ Connection idle period in ms before attempting connection parameter update. set to zero to disable */ (15 * 8 / 1.25), /*! Minimum connection interval in 1.25ms units */ (15 * 12 / 1.25), /*! Maximum connection interval in 1.25ms units */ 0, /*! Connection latency */ 600, /*! Supervision timeout in 10ms units */ 5 /*! Number of update attempts before giving up */ }; The DmConnUpdate() function can also be used to request a connection parameter update from the peripheral or initiate one from the master. /*************************************************************************************************/ /*! * \\brief Update the connection parameters of an open connection * * \\param connId Connection identifier. * \\param pConnSpec Connection specification. * * \\return None. */ /*************************************************************************************************/ void DmConnUpdate(dmConnId_t connId, hciConnSpec_t *pConnSpec);","title":"How do I change the connection parameters?"},{"location":"Libraries/Cordio/docs/CORDIO_USERGUIDE/#how-do-i-use-the-low-power-modes","text":"All of the applications will enter sleep mode in idle when built with DEBUG=0 . The Wireless Stack Framework (WSF) operating system will call PalSysSleep() mode when idle. With DEBUG=1 , the CPU will stay in active mode to leave the debugger enabled. To enter the lowest power states, refer to the BLE_FreeRTOS application. This will create FreeRTOS tasks for the Cordio stack and allow users to add additional tasks. Enable configUSE_TICKLESS_IDLE , and the device will enter standby mode and deep sleep between events. WARNING: The CPU debugger is disabled in sleep modes. If your application enters sleep mode directly after reset, it will be difficult to debug and reprogram.","title":"How do I use the low-power modes?"},{"location":"Libraries/Cordio/docs/CORDIO_USERGUIDE/#how-do-i-send-unformatted-data-like-a-uart","text":"Unfortunately, there is no Bluetooth SIG-defined standard for this protocol. This stack has a proprietary data transfer service that is used to transmit unformatted data between devices. Refer to the BLE_dats (BLE Data Server) for the peripheral application. You can connect to this device with the BLE_datc (BLE data client) application to see simple data transmission. Refer to the BLE_dats and BLE_dats README for more information.","title":"How do I send unformatted data like a UART?"},{"location":"Libraries/Cordio/docs/CORDIO_USERGUIDE/#additional-documentation","text":"Documentation for Python tools used for Bluetooth development and debugging can be found here . Documentation for each of the supporting applications can be found below: BLE4 BLE5 FreeRTOS DAT Client/Server BLE FCC BLE Fit BLE MCS OTA Client/Server BLE Periph RF Test","title":"Additional Documentation"},{"location":"Libraries/Cordio/docs/CORDIO_USERGUIDE/#certification","text":"Bluetooth LE Mesh solution implementing the Bluetooth Mesh Profile 1.0 and the Bluetooth Mesh Model 1.0 wireless technical specifications QDID 116593 Bluetooth LE Host protocol stack implementing Bluetooth Core 5.2 specification QDID 146344 Bluetooth LE Link Layer protocol stack implementing Bluetooth 5.2 specification QDID 146281 MAX32655 controller subsystem QDID 159701 MAX32665 controller subsystem QDID 142345 Consult the Bluetooth Qualification Process for further details regarding certification.","title":"Certification"},{"location":"Libraries/Cordio/docs/LICENSE/","text":"Copyright (c) 2019 Packetcraft, Inc. Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"LICENSE"},{"location":"Libraries/Cordio/docs/PACKETCRAFT/","text":"Packetcraft Protocol Software Packetcraft protocol software is a collection of embedded stacks implementing the Bluetooth Low Energy Link Layer, Host, Profile and Mesh specification (www.bluetooth.org). This repository contains open source release of Packetcraft's software. This is a qualified release and may be used in products. Please consult the Bluetooth Qualification Process for further details regarding additional certification requirements. Release notes This latest release of the Packetcraft Host and Packetcraft Controller is Bluetooth 5.2 qualified and implements the following new Bluetooth 5.2 features: LE Isochronous Channels, Enhanced Attribute Protocol, and LE Power Control. This release includes the following completed requirements for r20.05: FW-3340 Isochronous Demo: single BIS data stream FW-3354 TCRL.2019-1 compliant FW-3359 Core v5.2: LE Isochronous Channels (ISO) FW-3360 Core v5.2: LE Power Control FW-3361 Core v5.2: Enhanced ATT (EATT) FW-3617 Core v5.2: Isochronous Abstraction Layer (ISOAL) FW-3726 Core v5.2: Host Support for LE Isochronous Channels (ISO) FW-3727 Nordic nRF5 SDK 16.0.0 FW-3730 Compile BLE host for 64-bit platform FW-3736 Light CTL Model FW-3738 Mesh v1.0.1 compliant FW-3739 TCRL.2019-2 qualification FW-3750 Laird BL654 platform FW-3767 SBC codec FW-3803 GCC compiler support for gcc-arm-none-eabi-9-2019-q4-major FW-3820 Protect against SweynTooth vulnerability Platforms This release was tested on the following platforms. Note: platforms listed may not be available in this repository. Nordic nRF52840 / PCA10056 development kit / Nordic nRF5 SDK 16.0.0 (make configuration: \"PLATFORM=nordic BOARD=PCA10056\") Nordic nRF52832 / PCA10040 development kit / Nordic nRF5 SDK 16.0.0 (make configuration: \"PLATFORM=nordic BOARD=PCA10040\") Laird BL654 / 451-00004 USB adapter / Nordic nRF5 SDK 16.0.0 (make configuration: \"PLATFORM=laird\") Certification Bluetooth LE Mesh solution implementing of the Bluetooth Mesh Profile 1.0 and the Bluetooth Mesh Model 1.0 wireless technical specifications QDID 116593 Bluetooth LE Host protocol stack implementing Bluetooth Core 5.2 specification QDID 146344 Bluetooth LE Link Layer protocol stack implementing Bluetooth 5.2 specification QDID 146281 Verification Packetcraft Mesh is verified with the TCRL.2019-2 compliance tester using the following: Bluetooth Profile Tuning Suites 7.6.1 Packetcraft Host is verified with the TCRL.2019-2 compliance tester using the following: Bluetooth Profile Tuning Suites 7.6.1 Packetcraft Profiles is verified with the TCRL.2018-2 compliance tester using the following: Bluetooth Profile Tuning Suites 7.3.0 Packetcraft Link Layer conforms to the Bluetooth TCRL.2019-2 requirements verified with the following: Teledyne Harmony LE Tester version 19.12.16916.21195 This product was compiled and tested with the following version of GNU GCC gcc-arm-none-eabi-9-2019-q4-major","title":"PACKETCRAFT"},{"location":"Libraries/Cordio/docs/PACKETCRAFT/#packetcraft-protocol-software","text":"Packetcraft protocol software is a collection of embedded stacks implementing the Bluetooth Low Energy Link Layer, Host, Profile and Mesh specification (www.bluetooth.org). This repository contains open source release of Packetcraft's software. This is a qualified release and may be used in products. Please consult the Bluetooth Qualification Process for further details regarding additional certification requirements.","title":"Packetcraft Protocol Software"},{"location":"Libraries/Cordio/docs/PACKETCRAFT/#release-notes","text":"This latest release of the Packetcraft Host and Packetcraft Controller is Bluetooth 5.2 qualified and implements the following new Bluetooth 5.2 features: LE Isochronous Channels, Enhanced Attribute Protocol, and LE Power Control. This release includes the following completed requirements for r20.05: FW-3340 Isochronous Demo: single BIS data stream FW-3354 TCRL.2019-1 compliant FW-3359 Core v5.2: LE Isochronous Channels (ISO) FW-3360 Core v5.2: LE Power Control FW-3361 Core v5.2: Enhanced ATT (EATT) FW-3617 Core v5.2: Isochronous Abstraction Layer (ISOAL) FW-3726 Core v5.2: Host Support for LE Isochronous Channels (ISO) FW-3727 Nordic nRF5 SDK 16.0.0 FW-3730 Compile BLE host for 64-bit platform FW-3736 Light CTL Model FW-3738 Mesh v1.0.1 compliant FW-3739 TCRL.2019-2 qualification FW-3750 Laird BL654 platform FW-3767 SBC codec FW-3803 GCC compiler support for gcc-arm-none-eabi-9-2019-q4-major FW-3820 Protect against SweynTooth vulnerability","title":"Release notes"},{"location":"Libraries/Cordio/docs/PACKETCRAFT/#platforms","text":"This release was tested on the following platforms. Note: platforms listed may not be available in this repository. Nordic nRF52840 / PCA10056 development kit / Nordic nRF5 SDK 16.0.0 (make configuration: \"PLATFORM=nordic BOARD=PCA10056\") Nordic nRF52832 / PCA10040 development kit / Nordic nRF5 SDK 16.0.0 (make configuration: \"PLATFORM=nordic BOARD=PCA10040\") Laird BL654 / 451-00004 USB adapter / Nordic nRF5 SDK 16.0.0 (make configuration: \"PLATFORM=laird\")","title":"Platforms"},{"location":"Libraries/Cordio/docs/PACKETCRAFT/#certification","text":"Bluetooth LE Mesh solution implementing of the Bluetooth Mesh Profile 1.0 and the Bluetooth Mesh Model 1.0 wireless technical specifications QDID 116593 Bluetooth LE Host protocol stack implementing Bluetooth Core 5.2 specification QDID 146344 Bluetooth LE Link Layer protocol stack implementing Bluetooth 5.2 specification QDID 146281","title":"Certification"},{"location":"Libraries/Cordio/docs/PACKETCRAFT/#verification","text":"Packetcraft Mesh is verified with the TCRL.2019-2 compliance tester using the following: Bluetooth Profile Tuning Suites 7.6.1 Packetcraft Host is verified with the TCRL.2019-2 compliance tester using the following: Bluetooth Profile Tuning Suites 7.6.1 Packetcraft Profiles is verified with the TCRL.2018-2 compliance tester using the following: Bluetooth Profile Tuning Suites 7.3.0 Packetcraft Link Layer conforms to the Bluetooth TCRL.2019-2 requirements verified with the following: Teledyne Harmony LE Tester version 19.12.16916.21195 This product was compiled and tested with the following version of GNU GCC gcc-arm-none-eabi-9-2019-q4-major","title":"Verification"},{"location":"Libraries/Cordio/docs/Applications/BLE4_ctr/","text":"Description Bluetooth version 4.2 controller, accepts HCI commands via Serial Port. Usage LEDs The red LED will indicate that an error assertion has occurred. The green LED indicates CPU activity. When the LED is on, the CPU is active, when the LED is off, the CPU is in sleep mode. Expected Output On startup: RAM: 4 x 752 bytes -- connection context RAM: 16 x 719 bytes -- Tx buffer descriptors LlHandlerInit: LL initialization completed opModeFlags = 0x005F5C40 ### LlApi ### LlSetBdAddr Static BDA[5:3]=00:18:80 BDA[2:0]=F9:69:42 ### LlApi ### LlSetAdvTxPower, advTxPwr=0 HCI: python3 BLE_hci.py /dev/ttyUSB0 Bluetooth Low Energy HCI tool Serial port: /dev/ttyUSB0 8N1 115200 >>> reset 2022-03-08 09:03:26.602167 > 01030C00 2022-03-08 09:03:26.616613 < 040E0401030C00 >>> This shows HCI_Reset command sent to controller along with response event from controller. If command successful then the terminal shows the following trace messages. ### LlApi ### LlReset lctrMstScanExecuteSm: state=0, event=0 lctrMstInitExecuteSm: state=0, event=0 lctrSlvAdvExecuteSm: state=0, event=0 ### LlEvent ### LL_RESET_CNF, status=LL_SUCCESS","title":"Description"},{"location":"Libraries/Cordio/docs/Applications/BLE4_ctr/#description","text":"Bluetooth version 4.2 controller, accepts HCI commands via Serial Port.","title":"Description"},{"location":"Libraries/Cordio/docs/Applications/BLE4_ctr/#usage","text":"","title":"Usage"},{"location":"Libraries/Cordio/docs/Applications/BLE4_ctr/#leds","text":"The red LED will indicate that an error assertion has occurred. The green LED indicates CPU activity. When the LED is on, the CPU is active, when the LED is off, the CPU is in sleep mode.","title":"LEDs"},{"location":"Libraries/Cordio/docs/Applications/BLE4_ctr/#expected-output","text":"On startup: RAM: 4 x 752 bytes -- connection context RAM: 16 x 719 bytes -- Tx buffer descriptors LlHandlerInit: LL initialization completed opModeFlags = 0x005F5C40 ### LlApi ### LlSetBdAddr Static BDA[5:3]=00:18:80 BDA[2:0]=F9:69:42 ### LlApi ### LlSetAdvTxPower, advTxPwr=0 HCI: python3 BLE_hci.py /dev/ttyUSB0 Bluetooth Low Energy HCI tool Serial port: /dev/ttyUSB0 8N1 115200 >>> reset 2022-03-08 09:03:26.602167 > 01030C00 2022-03-08 09:03:26.616613 < 040E0401030C00 >>> This shows HCI_Reset command sent to controller along with response event from controller. If command successful then the terminal shows the following trace messages. ### LlApi ### LlReset lctrMstScanExecuteSm: state=0, event=0 lctrMstInitExecuteSm: state=0, event=0 lctrSlvAdvExecuteSm: state=0, event=0 ### LlEvent ### LL_RESET_CNF, status=LL_SUCCESS","title":"Expected Output"},{"location":"Libraries/Cordio/docs/Applications/BLE5_ctr/","text":"Description Bluetooth version 5.2 controller, accepts HCI commands via Serial Port. Usage LEDs The red LED will indicate that an error assertion has occurred. The green LED indicates CPU activity. When the LED is on, the CPU is active, when the LED is off, the CPU is in sleep mode. Expected Output On startup: RAM: 4 x 752 bytes -- connection context RAM: 16 x 719 bytes -- Tx buffer descriptors RAM: 2 x 2296 bytes -- advertising set context RAM: 2 x 704 bytes -- CIS context RAM: 2 x 124 bytes -- CIG context RAM: 2 x 208 bytes -- BIS context RAM: 2 x 584 bytes -- BIG context RAM: 8 x 120 bytes -- Tx buffer descriptors LlHandlerInit: LL initialization completed opModeFlags = 0x005F5C40 ### LlApi ### LlSetBdAddr Static BDA[5:3]=00:18:80 BDA[2:0]=F9:69:42 ### LlApi ### LlSetAdvTxPower, advTxPwr=0 HCI: python3 BLE_hci.py /dev/ttyUSB0 Bluetooth Low Energy HCI tool Serial port: /dev/ttyUSB0 8N1 115200 >>> reset 2022-03-08 09:03:26.602167 > 01030C00 2022-03-08 09:03:26.616613 < 040E0401030C00 >>> This shows HCI_Reset command sent to controller along with response event from controller. If command successful then the terminal shows the following trace messages. ### LlApi ### LlReset lctrMstScanExecuteSm: state=0, event=0 lctrMstInitExecuteSm: state=0, event=0 lctrSlvAdvExecuteSm: state=0, event=0 lctrMstExtScanExecuteSm: phy=0, state=0, event=0 lctrMstExtScanExecuteCommonSm: numScanEnabled=0, scanMode=0, event=RESET lctrMstExtInitExecuteSm: state=0, event=0 lctrMstExtInitExecuteCommonSm: scanMode=0, event=RESET lctrMstCreateSyncExecuteSm: state=0, event=0 lctrMstTransferSyncExecuteSm: state=0, event=0 lctrMstPerScanExecuteSm: state=0, event=0 lctrMstPerScanExecuteSm: state=0, event=0 lctrMstPerScanExecuteSm: state=0, event=0 lctrMstPerScanExecuteSm: state=0, event=0 lctrMstPerScanExecuteSm: state=0, event=0 lctrMstPerScanExecuteSm: state=0, event=0 lctrSlvAcadDisp: handle=4, event=0 ### LlEvent ### LL_RESET_CNF, status=LL_SUCCESS","title":"Description"},{"location":"Libraries/Cordio/docs/Applications/BLE5_ctr/#description","text":"Bluetooth version 5.2 controller, accepts HCI commands via Serial Port.","title":"Description"},{"location":"Libraries/Cordio/docs/Applications/BLE5_ctr/#usage","text":"","title":"Usage"},{"location":"Libraries/Cordio/docs/Applications/BLE5_ctr/#leds","text":"The red LED will indicate that an error assertion has occurred. The green LED indicates CPU activity. When the LED is on, the CPU is active, when the LED is off, the CPU is in sleep mode.","title":"LEDs"},{"location":"Libraries/Cordio/docs/Applications/BLE5_ctr/#expected-output","text":"On startup: RAM: 4 x 752 bytes -- connection context RAM: 16 x 719 bytes -- Tx buffer descriptors RAM: 2 x 2296 bytes -- advertising set context RAM: 2 x 704 bytes -- CIS context RAM: 2 x 124 bytes -- CIG context RAM: 2 x 208 bytes -- BIS context RAM: 2 x 584 bytes -- BIG context RAM: 8 x 120 bytes -- Tx buffer descriptors LlHandlerInit: LL initialization completed opModeFlags = 0x005F5C40 ### LlApi ### LlSetBdAddr Static BDA[5:3]=00:18:80 BDA[2:0]=F9:69:42 ### LlApi ### LlSetAdvTxPower, advTxPwr=0 HCI: python3 BLE_hci.py /dev/ttyUSB0 Bluetooth Low Energy HCI tool Serial port: /dev/ttyUSB0 8N1 115200 >>> reset 2022-03-08 09:03:26.602167 > 01030C00 2022-03-08 09:03:26.616613 < 040E0401030C00 >>> This shows HCI_Reset command sent to controller along with response event from controller. If command successful then the terminal shows the following trace messages. ### LlApi ### LlReset lctrMstScanExecuteSm: state=0, event=0 lctrMstInitExecuteSm: state=0, event=0 lctrSlvAdvExecuteSm: state=0, event=0 lctrMstExtScanExecuteSm: phy=0, state=0, event=0 lctrMstExtScanExecuteCommonSm: numScanEnabled=0, scanMode=0, event=RESET lctrMstExtInitExecuteSm: state=0, event=0 lctrMstExtInitExecuteCommonSm: scanMode=0, event=RESET lctrMstCreateSyncExecuteSm: state=0, event=0 lctrMstTransferSyncExecuteSm: state=0, event=0 lctrMstPerScanExecuteSm: state=0, event=0 lctrMstPerScanExecuteSm: state=0, event=0 lctrMstPerScanExecuteSm: state=0, event=0 lctrMstPerScanExecuteSm: state=0, event=0 lctrMstPerScanExecuteSm: state=0, event=0 lctrMstPerScanExecuteSm: state=0, event=0 lctrSlvAcadDisp: handle=4, event=0 ### LlEvent ### LL_RESET_CNF, status=LL_SUCCESS","title":"Expected Output"},{"location":"Libraries/Cordio/docs/Applications/BLE_FreeRTOS/","text":"Description A basic getting started application for BLE and FreeRTOS. Usage LEDs The red LED will indicate that an error assertion has occurred. The green LED indicates CPU activity. When the LED is on, the CPU is active, when the LED is off, the CPU is in sleep mode. Expected Output On startup: -=- MAX32655 BLE FreeRTOS (V10.2.0) Demo -=- SystemCoreClock = 100000000 terminal: init 32kHz trimed to 0x16 DatsHandlerInit Calculating database hash Dats got evt 119 Dats got evt 32 >>> Reset complete <<< dmAdvActConfig: state: 0 dmAdvActSetData: state: 0 dmAdvActSetData: state: 0 dmAdvActStart: state: 0 HCI_LE_ADV_ENABLE_CMD_CMPL_CBACK_EVT: state: 3 dmDevPassEvtToDevPriv: event: 12, param: 33, advHandle: 0 Dats got evt 33 >>> Advertising started <<< Database hash calculation complete Dats got evt 21 Database hash updated When a connection (to evkit running DATC example) has been made. dmConnIdByBdAddr not found dmConnCcbAlloc 1 dmConnSmExecute event=28 state=0 dmAdvConnected: state: 1 dmDevPassEvtToDevPriv: event: 13, param: 34, advHandle: 0 AttsCccInitTable connId=1 smpDbGetRecord: connId: 1 type: 0 smpDbAddDevice SmpDbGetFailureCount: connId: 1 count: 0 smpDbGetRecord: connId: 1 type: 0 smpDbAddDevice SmpDbGetPairingDisabledTime: connId: 1 period: 0 attemptMult: 0 Dats got evt 39 >>> Connection opened <<< Dats got evt 65 attsProcMtuReq features 0x00 hciCoreTxAclStart len=7 Dats got evt 22 hciCoreTxAclStart len=24 Dats got evt 87 connId=1 idleMask=0x0004 hciCoreTxAclStart len=9 hciCoreTxAclStart len=34 hciCoreTxAclStart len=9 connId=1 idleMask=0x0004 hciCoreTxAclStart len=10 connId=1 idleMask=0x0004 hciCoreTxAclStart len=9 hciCoreTxAclStart len=27 hciCoreTxAclStart len=9 connId=1 idleMask=0x0004 hciCoreTxAclStart len=9 hciCoreTxAclStart len=27 hciCoreTxAclStart len=9 connId=1 idleMask=0x0004 hciCoreTxAclStart len=10 connId=1 idleMask=0x0004 hciCoreTxAclStart len=9 attsCccMainCback connId=1 handle=19 hciCoreTxAclStart len=5 connId 1 updated csf to 0x01 hciCoreTxAclStart len=5 attsCccMainCback connId=1 handle=515 hciCoreTxAclStart len=5 App got evt 16 When message received from peer hello world hciCoreTxAclStart len=18 Dats got evt 18 Commands Type the desired command and parameter (if applicable) and press enter to execute the command. help Displays the available commands. echo (on|off) Enables or disables the input echo. On by default. btn (ID) (s|m|l|x) Simulates button presses. Example: \"btn 1 s\" for a short button press on button 1. pin (ConnID) (Pin Code) Used to input the pairing pin code. Push buttons Push buttons can be used to interact with the application. short press is less than 200 ms medium press is between 200 and 500 ms long press is between 500 and 1000 ms extra long press is greater than 1000 ms When disconnected Button 1 short press: Start advertising Button 1 medium press: Enter bondable mode Button 1 long press: Clear all bonding info Button 1 extra long press: Show version info Button 2 short press: Stop advertising When connected Button 2 short press: Change PHY (1M-2M-Coded_S2-Coded_S8)","title":"BLE FreeRTOS"},{"location":"Libraries/Cordio/docs/Applications/BLE_FreeRTOS/#description","text":"A basic getting started application for BLE and FreeRTOS.","title":"Description"},{"location":"Libraries/Cordio/docs/Applications/BLE_FreeRTOS/#usage","text":"","title":"Usage"},{"location":"Libraries/Cordio/docs/Applications/BLE_FreeRTOS/#leds","text":"The red LED will indicate that an error assertion has occurred. The green LED indicates CPU activity. When the LED is on, the CPU is active, when the LED is off, the CPU is in sleep mode.","title":"LEDs"},{"location":"Libraries/Cordio/docs/Applications/BLE_FreeRTOS/#expected-output","text":"On startup: -=- MAX32655 BLE FreeRTOS (V10.2.0) Demo -=- SystemCoreClock = 100000000 terminal: init 32kHz trimed to 0x16 DatsHandlerInit Calculating database hash Dats got evt 119 Dats got evt 32 >>> Reset complete <<< dmAdvActConfig: state: 0 dmAdvActSetData: state: 0 dmAdvActSetData: state: 0 dmAdvActStart: state: 0 HCI_LE_ADV_ENABLE_CMD_CMPL_CBACK_EVT: state: 3 dmDevPassEvtToDevPriv: event: 12, param: 33, advHandle: 0 Dats got evt 33 >>> Advertising started <<< Database hash calculation complete Dats got evt 21 Database hash updated When a connection (to evkit running DATC example) has been made. dmConnIdByBdAddr not found dmConnCcbAlloc 1 dmConnSmExecute event=28 state=0 dmAdvConnected: state: 1 dmDevPassEvtToDevPriv: event: 13, param: 34, advHandle: 0 AttsCccInitTable connId=1 smpDbGetRecord: connId: 1 type: 0 smpDbAddDevice SmpDbGetFailureCount: connId: 1 count: 0 smpDbGetRecord: connId: 1 type: 0 smpDbAddDevice SmpDbGetPairingDisabledTime: connId: 1 period: 0 attemptMult: 0 Dats got evt 39 >>> Connection opened <<< Dats got evt 65 attsProcMtuReq features 0x00 hciCoreTxAclStart len=7 Dats got evt 22 hciCoreTxAclStart len=24 Dats got evt 87 connId=1 idleMask=0x0004 hciCoreTxAclStart len=9 hciCoreTxAclStart len=34 hciCoreTxAclStart len=9 connId=1 idleMask=0x0004 hciCoreTxAclStart len=10 connId=1 idleMask=0x0004 hciCoreTxAclStart len=9 hciCoreTxAclStart len=27 hciCoreTxAclStart len=9 connId=1 idleMask=0x0004 hciCoreTxAclStart len=9 hciCoreTxAclStart len=27 hciCoreTxAclStart len=9 connId=1 idleMask=0x0004 hciCoreTxAclStart len=10 connId=1 idleMask=0x0004 hciCoreTxAclStart len=9 attsCccMainCback connId=1 handle=19 hciCoreTxAclStart len=5 connId 1 updated csf to 0x01 hciCoreTxAclStart len=5 attsCccMainCback connId=1 handle=515 hciCoreTxAclStart len=5 App got evt 16 When message received from peer hello world hciCoreTxAclStart len=18 Dats got evt 18","title":"Expected Output"},{"location":"Libraries/Cordio/docs/Applications/BLE_FreeRTOS/#commands","text":"Type the desired command and parameter (if applicable) and press enter to execute the command. help Displays the available commands. echo (on|off) Enables or disables the input echo. On by default. btn (ID) (s|m|l|x) Simulates button presses. Example: \"btn 1 s\" for a short button press on button 1. pin (ConnID) (Pin Code) Used to input the pairing pin code.","title":"Commands"},{"location":"Libraries/Cordio/docs/Applications/BLE_FreeRTOS/#push-buttons","text":"Push buttons can be used to interact with the application. short press is less than 200 ms medium press is between 200 and 500 ms long press is between 500 and 1000 ms extra long press is greater than 1000 ms","title":"Push buttons"},{"location":"Libraries/Cordio/docs/Applications/BLE_FreeRTOS/#when-disconnected","text":"Button 1 short press: Start advertising Button 1 medium press: Enter bondable mode Button 1 long press: Clear all bonding info Button 1 extra long press: Show version info Button 2 short press: Stop advertising","title":"When disconnected"},{"location":"Libraries/Cordio/docs/Applications/BLE_FreeRTOS/#when-connected","text":"Button 2 short press: Change PHY (1M-2M-Coded_S2-Coded_S8)","title":"When connected"},{"location":"Libraries/Cordio/docs/Applications/BLE_datc_dats/","text":"BLE_datc_dats BLE Data Client and Data Server. These examples demonstrate a simple data client and server. The intent here is to show simple unformatted data exchange between two devices. The Bluetooth specification does not define a simple data exchange protocol, similar to UART. We use a proprietary GATT service to offer this feature. The data server will advertise with a devices name of \"DATS\". The data client will scan for this device and create a connection. Once the conneciton has been created and the client completes the discovery, it will enable notificaitons and indiciations on the proprietary data serivce. This will allow the server to transmit data to the client with notifications to the proprietary data characteristic. The client can transmit data to the server by writing to the proprietary data characteristic. ADI Attach connected to DATS ARM Proprietary data service UUID: E0262760-08C2-11E1-9073-0E8AC72E1001 This is a proprietary serivce is used for simple unformatted data exchange between the server and the client. Secure data service UUID: 42FC367E-32D9-4285-87C6-339924D135BE This is another proprietary service used for secure data exchange that requires elevated levels of encryption and authentication. Devices must be paired with LE Secure Connections to enable data transfer with this service. LEDs The red LED will indicate that an error assertion has occurred. The green LED indicates CPU activity. When the LED is on, the CPU is active, when the LED is off, the CPU is in sleep mode. BLE_Dats Bluetooth data server that advertises as \"DATS\" and accepts connection requests. This exmaples contains two proprietary services that are used to show simple message passing to and from the data client. Expected Output On startup: terminal: init 32kHz trimmed to 0x16 DatsHandlerInit Dats got evt 32 >>> Reset complete <<< dmAdvActConfig: state: 0 dmAdvActSetData: state: 0 dmAdvActSetData: state: 0 dmAdvActStart: state: 0 HCI_LE_ADV_ENABLE_CMD_CMPL_CBACK_EVT: state: 3 dmDevPassEvtToDevPriv: event: 12, param: 33, advHandle: 0 Dats got evt 33 >>> Advertising started <<< Dats got evt 21 Database hash updated When a connection attempting to connect to the client. Dats got evt 21 Database hash updated Dats got evt 153 dmConnIdByBdAddr not found dmConnCcbAlloc 1 dmConnSmExecute event=28 state=0 dmAdvConnected: state: 1 dmDevPassEvtToDevPriv: event: 13, param: 34, advHandle: 0 smpDbGetRecord: connId: 1 type: 0 smpDbAddDevice SmpDbGetFailureCount: connId: 1 count: 0 smpDbGetRecord: connId: 1 type: 0 smpDbAddDevice SmpDbGetPairingDisabledTime: connId: 1 period: 0 attemptMult: 0 Dats got evt 39 >>> Connection opened <<< Dats got evt 65 Dats got evt 22 smpSmExecute event=6 state=0 connId=1 idleMask=0x0001 Dats got evt 49 smpSmExecute event=2 state=2 smpSmExecute event=17 state=3 smpSmExecute event=4 state=5 smpSmExecute event=6 state=4 smpSmExecute event=20 state=6 connId=1 idleMask=0x0001 Dats got evt 46 >>> Prompt user to enter passkey <<< Dats got evt 87 connId=1 idleMask=0x0005 connId=1 idleMask=0x0005 connId=1 idleMask=0x0005 connId=1 idleMask=0x0005 connId=1 idleMask=0x0005 connId=1 idleMask=0x0005 connId=1 idleMask=0x0005 connId=1 idleMask=0x0005 When matching pins have been entered > smpSmExecute event=4 state=13 Rand Nb [52730a1e 080e2b3f 6d010f4b 0d29b8ac] smpSmExecute event=28 state=15 Cbi [520aab85 e23b56d5 70598231 64553242] connId=1 idleMask=0x0001 smpSmExecute event=6 state=16 smpSmExecute event=28 state=17 Ca [634082f9 ae97841d 408a0609 d3149a0f] Ca Peer [634082f9 ae97841d 408a0609 d3149a0f] connId=1 idleMask=0x0001 smpSmExecute event=26 state=18 smpSmExecute event=6 state=14 Rand Nb [2b4f65e1 41465986 1732c49b 0779c049] smpSmExecute event=28 state=15 Cbi [34b63e15 0a0b1d8a fbaac17d ae94c891] connId=1 idleMask=0x0001 smpSmExecute event=6 state=16 smpSmExecute event=28 state=17 Ca [e7b74ec3 7bb660e0 fd3ffb69 a70fc1b5] Ca Peer [e7b74ec3 7bb660e0 fd3ffb69 a70fc1b5] connId=1 idleMask=0x0001 smpSmExecute event=26 state=18 smpSmExecute event=6 state=14 Rand Nb [cb42c521 d4edb9cd fe2a5777 526d153d] smpSmExecute event=28 state=15 Cbi [58d9a8c4 c4710a1a bd41ed81 2e666953] connId=1 idleMask=0x0001 smpSmExecute event=6 state=16 smpSmExecute event=28 state=17 Ca [d100648f ae87b3e0 850e96ef 3c2c9a47] Ca Peer [d100648f ae87b3e0 850e96ef 3c2c9a47] connId=1 idleMask=0x0001 smpSmExecute event=26 state=18 smpSmExecute event=6 state=14 Rand Nb [21a3cd36 613f1834 c6e3d6fa 337e3f6c] smpSmExecute event=28 state=15 Cbi [314e5afe c5799362 0c3c7e01 54a62b7d] connId=1 idleMask=0x0001 smpSmExecute event=6 state=16 smpSmExecute event=28 state=17 Ca [bc03c14d cf73fbab c64c8de8 65c9bd3f] Ca Peer [bc03c14d cf73fbab c64c8de8 65c9bd3f] connId=1 idleMask=0x0001 smpSmExecute event=26 state=18 smpSmExecute event=6 state=14 Rand Nb [3e0cb037 9edea6c2 dfdd238f eee47a18] smpSmExecute event=28 state=15 Cbi [223876ac 32cfa06e 5764766f e655cfda] connId=1 idleMask=0x0001 smpSmExecute event=6 state=16 smpSmExecute event=28 state=17 Ca [3a1dceac 4ed11dc5 60384042 5f625042] Ca Peer [3a1dceac 4ed11dc5 60384042 5f625042] connId=1 idleMask=0x0001 smpSmExecute event=26 state=18 smpSmExecute event=6 state=14 Rand Nb [23ca1caf 70a3ba5b fd40e6ca db907405] smpSmExecute event=28 state=15 Cbi [0f969efc f159e4c6 588c68ae 5d1f9851] connId=1 idleMask=0x0001 smpSmExecute event=6 state=16 smpSmExecute event=28 state=17 Ca [c34f8c33 3e16ee08 3cac6f79 1eea831f] Ca Peer [c34f8c33 3e16ee08 3cac6f79 1eea831f] connId=1 idleMask=0x0001 smpSmExecute event=26 state=18 smpSmExecute event=6 state=14 Rand Nb [840f704c 59845fc2 47d5463a 9c68159b] smpSmExecute event=28 state=15 Cbi [f5a84dfe 36bdfc2d 410e133d 0c474039] connId=1 idleMask=0x0001 smpSmExecute event=6 state=16 smpSmExecute event=28 state=17 Ca [e27af695 a9227a18 74c2ba3d 57ed5254] Ca Peer [e27af695 a9227a18 74c2ba3d 57ed5254] connId=1 idleMask=0x0001 smpSmExecute event=26 state=18 smpSmExecute event=6 state=14 Rand Nb [5558d557 ba639669 226f7665 98ba1755] smpSmExecute event=28 state=15 Cbi [c8158453 c50a9448 236c7bd5 fe249a0d] connId=1 idleMask=0x0001 smpSmExecute event=6 state=16 smpSmExecute event=28 state=17 Ca [530da1cb 834ec9fa 6076fd05 037dce54] Ca Peer [530da1cb 834ec9fa 6076fd05 037dce54] connId=1 idleMask=0x0001 smpSmExecute event=26 state=18 smpSmExecute event=6 state=14 Rand Nb [9f57fda8 897aac72 810475a4 eda95e4c] smpSmExecute event=28 state=15 Cbi [12494fdf 83718797 5efa3ff7 4e230a9d] connId=1 idleMask=0x0001 smpSmExecute event=6 state=16 smpSmExecute event=28 state=17 Ca [b9c97dbe 7a725ab4 20c59148 10821669] Ca Peer [b9c97dbe 7a725ab4 20c59148 10821669] connId=1 idleMask=0x0001 smpSmExecute event=26 state=18 smpSmExecute event=6 state=14 Rand Nb [564e5d0e 2605341f 4d5b6913 0c89c1aa] smpSmExecute event=28 state=15 Cbi [a8b37963 eafdcaee ecbf62ab a23f686a] connId=1 idleMask=0x0001 smpSmExecute event=6 state=16 smpSmExecute event=28 state=17 Ca [b1387cd1 054a3616 3a73b06d 085e74b7] Ca Peer [b1387cd1 054a3616 3a73b06d 085e74b7] connId=1 idleMask=0x0001 smpSmExecute event=26 state=18 smpSmExecute event=6 state=14 Rand Nb [fc4d0a4e 2e6ca8f1 65f242a8 88876d0e] smpSmExecute event=28 state=15 Cbi [623c1256 7e20dba1 f5257b86 11b54ece] connId=1 idleMask=0x0001 smpSmExecute event=6 state=16 smpSmExecute event=28 state=17 Ca [4540e3cd 77e8ac57 8024607c 0de42ce2] Ca Peer [4540e3cd 77e8ac57 8024607c 0de42ce2] connId=1 idleMask=0x0001 smpSmExecute event=26 state=18 smpSmExecute event=6 state=14 Rand Nb [144e1412 64996fa0 d686011f 7913327d] smpSmExecute event=28 state=15 Cbi [b354740a 3d097abc e33af952 cffc0e8a] connId=1 idleMask=0x0001 smpSmExecute event=6 state=16 smpSmExecute event=28 state=17 Ca [ba1e5505 2e488dda b984bd08 2d07fdeb] Ca Peer [ba1e5505 2e488dda b984bd08 2d07fdeb] connId=1 idleMask=0x0001 smpSmExecute event=26 state=18 smpSmExecute event=6 state=14 Rand Nb [2596e6cd 44929e11 9791ba02 62e3feef] smpSmExecute event=28 state=15 Cbi [3790e2f7 96ca63b6 826bbf5c 077c3f31] connId=1 idleMask=0x0001 smpSmExecute event=6 state=16 smpSmExecute event=28 state=17 Ca [fe05bd6a 1f277dee 124de8b0 02c03343] Ca Peer [fe05bd6a 1f277dee 124de8b0 02c03343] connId=1 idleMask=0x0001 smpSmExecute event=26 state=18 smpSmExecute event=6 state=14 Rand Nb [06175016 3aabb9f3 f3aa5925 c9b8a43d] smpSmExecute event=28 state=15 Cbi [57d2399c 89fbc8f0 3ee71020 f66b45d5] connId=1 idleMask=0x0001 smpSmExecute event=6 state=16 smpSmExecute event=28 state=17 Ca [c2dff69b 7ae8eba8 e92f3b57 ff3978c7] Ca Peer [c2dff69b 7ae8eba8 e92f3b57 ff3978c7] connId=1 idleMask=0x0001 smpSmExecute event=26 state=18 smpSmExecute event=6 state=14 Rand Nb [5c70daab 66fe0495 07d0e27d 824d9865] smpSmExecute event=28 state=15 Cbi [f03928aa 2324a2ca 8c3c1fd8 9d589afe] connId=1 idleMask=0x0001 smpSmExecute event=6 state=16 smpSmExecute event=28 state=17 Ca [9f8dec26 018dcea5 0cc56156 32b9107b] Ca Peer [9f8dec26 018dcea5 0cc56156 32b9107b] connId=1 idleMask=0x0001 smpSmExecute event=26 state=18 smpSmExecute event=6 state=14 Rand Nb [fd89b81d e2b3fdaf f22cf4c4 b39da763] smpSmExecute event=28 state=15 Cbi [c005af08 39334b4a ac68cf0a ca5acc00] connId=1 idleMask=0x0001 smpSmExecute event=6 state=16 smpSmExecute event=28 state=17 Ca [94681382 aa6a4d27 1b8eb879 a5ed8043] Ca Peer [94681382 aa6a4d27 1b8eb879 a5ed8043] connId=1 idleMask=0x0001 smpSmExecute event=26 state=18 smpSmExecute event=6 state=14 Rand Nb [5b0789ba 4bd1a9f8 10e15f9d 0dbd4ac2] smpSmExecute event=28 state=15 Cbi [b719fe1d 02e6cc10 8776a1b4 0bc0fa6b] connId=1 idleMask=0x0001 smpSmExecute event=6 state=16 smpSmExecute event=28 state=17 Ca [3f8a85da fad78d81 0c8e0733 876df6fb] Ca Peer [3f8a85da fad78d81 0c8e0733 876df6fb] connId=1 idleMask=0x0001 smpSmExecute event=26 state=18 smpSmExecute event=6 state=14 Rand Nb [c0c90b30 03659e86 a143abe4 ec289e73] smpSmExecute event=28 state=15 Cbi [d02d6808 35888e79 55e04238 f0930c07] connId=1 idleMask=0x0001 smpSmExecute event=6 state=16 smpSmExecute event=28 state=17 Ca [4efc0b02 bcd8bc6a ac93b70c effeaee1] Ca Peer [4efc0b02 bcd8bc6a ac93b70c effeaee1] connId=1 idleMask=0x0001 smpSmExecute event=26 state=18 smpSmExecute event=6 state=14 Rand Nb [96aab51d 5e627668 ba927ed6 d1192554] smpSmExecute event=28 state=15 Cbi [49660e21 5b3e82cd 32e3ac9a d839ad2d] connId=1 idleMask=0x0001 smpSmExecute event=6 state=16 smpSmExecute event=28 state=17 Ca [2db916d0 32b02469 1711edf5 812ae090] Ca Peer [2db916d0 32b02469 1711edf5 812ae090] connId=1 idleMask=0x0001 smpSmExecute event=26 state=18 smpSmExecute event=6 state=14 Rand Nb [d9e874e4 9b02cb3f 9aac021d 7ad59561] smpSmExecute event=28 state=15 Cbi [837b81cf 6c409caa c29a550b 649b2c46] connId=1 idleMask=0x0001 smpSmExecute event=6 state=16 smpSmExecute event=28 state=17 Ca [f3d0b1b5 76097bfb 14418e57 6d3c11ba] Ca Peer [f3d0b1b5 76097bfb 14418e57 6d3c11ba] smpSmExecute event=27 state=18 connId=1 idleMask=0x0001 smpSmExecute event=6 state=21 smpSmExecute event=25 state=22 DHKey (Shared Secret) [bf891259 97f62954 0f8d8934 5bcd585f] [48fc2eb4 4c6f5c19 b8f817a9 907571b3] smpSmExecute event=28 state=23 T [72c2ed8a fe1ae569 8237053f b5af654c] smpSmExecute event=28 state=24 MAC [273eaeb4 163166a1 362c8773 888811aa] smpSmExecute event=28 state=25 LTK [7eacbbfe 776de847 1b78effc 32e84ba5] smpSmExecute event=28 state=26 DHKey Ea [e619e7cf 7d654f17 f621cb5c f6dd720b] smpSmExecute event=28 state=27 DHKey Eb [1e72f16f dcab7a66 2787c1ce ee93d5ec] connId=1 idleMask=0x0001 connId=1 idleMask=0x0001 smpSmExecute event=8 state=36 Dats got evt 44 >>> Connection encrypted <<< Dats got evt 47 smpSmExecute event=12 state=37 smpSmExecute event=12 state=37 smpSmExecute event=6 state=37 smpSmExecute event=6 state=37 smpSmExecute event=14 state=37 connId=1 idleMask=0x0000 Dats got evt 47 Dats got evt 42 >>> Pairing completed successfully <<< dmDevPassEvtToDevPriv: event: 13, param: 1, advHandle: 0 Dats got evt 58 Dats got evt 63 Dats got evt 153 When PHY change performed > btn 2 s Short Button 2 Press 2 MBit TX and RX PHY Requested Dats got evt 70 DM_PHY_UPDATE_IND - RX: 2, TX: 2 Dats got evt 65 App got evt 16 App got evt 16 connId=1 idleMask=0x0000 > btn 2 s Short Button 2 Press LE Coded S2 TX and RX PHY Requested Dats got evt 70 DM_PHY_UPDATE_IND - RX: 3, TX: 3 Dats got evt 65 App got evt 16 App got evt 16 dmConnUpdExecute event=113 state=3 dmConnSmExecute event=30 state=3 Dats got evt 41 > btn 2 s Short Button 2 Press LE Coded S8 TX and RX PHY Requested Dats got evt 70 DM_PHY_UPDATE_IND - RX: 3, TX: 3 > btn 2 s Short Button 2 Press 1 MBit TX and RX PHY Requested Dats got evt 70 DM_PHY_UPDATE_IND - RX: 1, TX: 1 Dats got evt 65 When message received from peer hello world hciCoreTxAclStart len=18 Dats got evt 18 When secure message recevied from peer >> Received secure data << Secret number is 0x42 Dats got evt 18 Commands Type the desired command and parameter (if applicable) and press enter to execute the command. help Displays the available commands. echo (on|off) Enables or disables the input echo. On by default. btn (ID) (s|m|l|x) Simulates button presses. Example: \"btn 1 s\" for a short button press on button 1. pin (ConnID) (Pin Code) Used to input the pairing pin code. Push buttons Push buttons can be used to interact with the application. short press is less than 200 ms medium press is between 200 and 500 ms long press is between 500 and 1000 ms extra long press is greater than 1000 ms When disconnected Button 1 short press: Start advertising Button 1 medium press: Enter bondable mode Button 1 long press: Clear all bonding info Button 1 extra long press: Show version info Button 2 short press: Stop advertising When connected Button 2 short press: Change PHY (1M-2M-Coded_S2-Coded_S8) BLE_Datc Bluetooth data client that scans and connections to devices advertising with the device name \"DATS\". The client will automatically discover the profiles and services on the device, subscribing to notifications and indications to enable the unformatted data exchange with the proprietary data service. Expected Output On startup: terminal: init 32kHz trimmed to 0xF DatcHandlerInit Calculating database hash Datc got evt 32 >>> Reset complete <<< Datc got evt 58 Database hash calculation complete Datc got evt 21 Database hash updated dmDevPassEvtToDevPriv: event: 13, param: 1, advHandle: 0 Datc got evt 63 Datc got evt 153 dmDevPassEvtToDevPriv: event: 12, param: 36, advHandle: 0 Datc got evt 36 >>> Scanning started <<< When a scan report has been received: Scan Report: 55:CF:67:1F:6F:27 Scan Report: 00:05:8B:44:12:02 Name: Fit When server has been found: Scan Report: 00:18:80:04:52:1F Name: DATS dmDevPassEvtToDevPriv: event: 13, param: 37, advHandle: 0 Datc got evt 37 Scan results: 4 dmConnIdByBdAddr not found dmConnCcbAlloc 1 >>> Scanning stopped <<< dmConnSmExecute event=24 state=0 dmDevPassEvtToDevPriv: event: 14, param: 0, advHandle: 0 dmConnSmExecute event=28 state=1 dmDevPassEvtToDevPriv: event: 14, param: 1, advHandle: 0 dmDevPassEvtToDevPriv: event: 12, param: 39, advHandle: 0 smpDbGetRecord: connId: 1 type: 0 smpDbAddDevice SmpDbGetFailureCount: connId: 1 count: 0 smpDbGetRecord: connId: 1 type: 0 smpDbAddDevice SmpDbGetPairingDisabledTime: connId: 1 period: 0 attemptMult: 0 Datc got evt 39 >>> Connection opened <<< smpSmExecute event=1 state=0 connId=1 idleMask=0x0001 Datc got evt 65 Datc got evt 22 smpSmExecute event=6 state=1 smpSmExecute event=17 state=2 smpSmExecute event=4 state=3 connId=1 idleMask=0x0001 Datc got evt 87 Datc got evt 4 connId=1 idleMask=0x0009 smpSmExecute event=6 state=4 smpSmExecute event=20 state=5 Datc got evt 46 >>> Prompt user to enter passkey <<< Datc got evt 3 AttcDiscServiceCmpl status 0x00 Datc got evt 4 AttcDiscCharCmpl status 0x79 Datc got evt 4 AttcDiscCharCmpl status 0x79 Datc got evt 2 AttcDiscCharCmpl status 0x00 connId=1 idleMask=0x0009 Datc got evt 3 AttcDiscServiceCmpl status 0x00 Datc got evt 4 AttcDiscCharCmpl status 0x79 Datc got evt 4 AttcDiscCharCmpl status 0x00 connId=1 idleMask=0x0009 Datc got evt 3 AttcDiscServiceCmpl status 0x00 Datc got evt 4 AttcDiscCharCmpl status 0x79 Datc got evt 4 AttcDiscCharCmpl status 0x79 Datc got evt 2 AttcDiscCharCmpl status 0x00 connId=1 idleMask=0x0009 Datc got evt 3 AttcDiscServiceCmpl status 0x00 Datc got evt 4 AttcDiscCharCmpl status 0x79 Datc got evt 4 AttcDiscCharCmpl status 0x79 Datc got evt 2 AttcDiscCharCmpl status 0x79 Datc got evt 2 AttcDiscCharCmpl status 0x00 connId=1 idleMask=0x0001 AppDiscComplete connId:1 status:0x04 connId=1 idleMask=0x0009 Datc got evt 9 AttcDiscConfigCmpl status 0x79 Datc got evt 9 AttcDiscConfigCmpl status 0x79 Datc got evt 9 AttcDiscConfigCmpl status 0x79 Datc got evt 9 AttcDiscConfigCmpl status 0x00 connId=1 idleMask=0x0001 AppDiscComplete connId:1 status:0x08 After entering a pin pin 1 12345 > smpSmExecute event=4 state=11 Rand Na [5fa96af9 f434b4de 3e452813 fef4f5eb] smpSmExecute event=28 state=12 Cai [57964640 e18b1aa1 8ea7d8b2 2eb274c3] connId=1 idleMask=0x0001 Once server enters a matching pin and encrypted connection is established smpSmExecute event=6 state=14 smpSmExecute event=28 state=15 Cbi [7e2523a4 be6a8923 8ef900bf d4eaa458] smpSmExecute event=26 state=16 Rand Na [efb856be 61bd11a8 2dff39c0 1f5d4d91] smpSmExecute event=28 state=12 Cai [65f7c942 8c216010 cc73fdc9 bd21120e] connId=1 idleMask=0x0001 smpSmExecute event=6 state=13 connId=1 idleMask=0x0001 smpSmExecute event=6 state=14 smpSmExecute event=28 state=15 Cbi [db4858f8 33a964c1 e35ba27c 1f07e7db] smpSmExecute event=26 state=16 Rand Na [9904fded 40ea2bb1 dfabe4be b9bcba45] smpSmExecute event=28 state=12 Cai [1362d0db 074d32ea 32d0e79c 1155a20b] connId=1 idleMask=0x0001 smpSmExecute event=6 state=13 connId=1 idleMask=0x0001 smpSmExecute event=6 state=14 smpSmExecute event=28 state=15 Cbi [efd27c04 96ff72e0 c893bf54 9c524f0a] smpSmExecute event=26 state=16 Rand Na [5ba16640 fd3af1ae afc6d035 d8eb1fa5] smpSmExecute event=28 state=12 Cai [79603efa ad87d2cd bdc4c83b 17dcffe6] connId=1 idleMask=0x0001 smpSmExecute event=6 state=13 connId=1 idleMask=0x0001 smpSmExecute event=6 state=14 smpSmExecute event=28 state=15 Cbi [c1221276 73df3bf7 90e8df64 741909c1] smpSmExecute event=26 state=16 Rand Na [59ea06d0 760407f7 87415144 fe234a1e] smpSmExecute event=28 state=12 Cai [40b9915c af4a8712 c81e98f9 f197953a] connId=1 idleMask=0x0001 smpSmExecute event=6 state=13 connId=1 idleMask=0x0001 smpSmExecute event=6 state=14 smpSmExecute event=28 state=15 Cbi [325fe15b 5a6862e1 f4de459d 6c91c220] smpSmExecute event=26 state=16 Rand Na [4c56f9f9 b1d91236 8dfb81f8 b0629bb7] smpSmExecute event=28 state=12 Cai [c2fb6b18 63cb9311 d53c3333 0a2924cf] connId=1 idleMask=0x0001 smpSmExecute event=6 state=13 connId=1 idleMask=0x0001 smpSmExecute event=6 state=14 smpSmExecute event=28 state=15 Cbi [7725d42d 35f8e465 b3b6cfed 9bfe125a] smpSmExecute event=26 state=16 Rand Na [3909e384 45979c24 c85d36d3 fc2bd4bf] smpSmExecute event=28 state=12 Cai [9e570480 195412a0 07c84616 36cd6a06] connId=1 idleMask=0x0001 smpSmExecute event=6 state=13 connId=1 idleMask=0x0001 smpSmExecute event=6 state=14 smpSmExecute event=28 state=15 Cbi [1bce9472 21f7d6c4 4f8fe62b 91ac2271] smpSmExecute event=26 state=16 Rand Na [fe57e223 78ca04e3 cd13bd82 ad43289c] smpSmExecute event=28 state=12 Cai [42ba2b2e bd35ebe6 56c59b28 957639d2] connId=1 idleMask=0x0001 smpSmExecute event=6 state=13 connId=1 idleMask=0x0001 smpSmExecute event=6 state=14 smpSmExecute event=28 state=15 Cbi [a35acba5 00eba332 31442e10 aea9dacf] smpSmExecute event=26 state=16 Rand Na [71aa44ad abe2d668 07b79f02 d2a974dc] smpSmExecute event=28 state=12 Cai [5b02fce8 f92549ca 54bea290 c9fdfd1b] connId=1 idleMask=0x0001 smpSmExecute event=6 state=13 connId=1 idleMask=0x0001 smpSmExecute event=6 state=14 smpSmExecute event=28 state=15 Cbi [4a52c87c a504c8cf 49d9e8f0 1a69aca2] smpSmExecute event=26 state=16 Rand Na [0f87eb54 83f4f78b 754d2f74 1b406c0d] smpSmExecute event=28 state=12 Cai [16a9ba43 8c8b39d2 912f1f85 3f738170] connId=1 idleMask=0x0001 smpSmExecute event=6 state=13 connId=1 idleMask=0x0001 smpSmExecute event=6 state=14 smpSmExecute event=28 state=15 Cbi [b2aa1f53 802fa4ad 3e415844 4953c931] smpSmExecute event=26 state=16 Rand Na [466db705 9fd2d031 35759a3f 45869950] smpSmExecute event=28 state=12 Cai [004c8d5f 4413efb9 f60c10c2 8af82058] connId=1 idleMask=0x0001 smpSmExecute event=6 state=13 connId=1 idleMask=0x0001 smpSmExecute event=6 state=14 smpSmExecute event=28 state=15 Cbi [6b93dfa8 91d6bc27 fbb7142a 778d6eab] smpSmExecute event=26 state=16 Rand Na [4d0cfaee 277f0959 ee9ad6b5 bf89e129] smpSmExecute event=28 state=12 Cai [b977b373 4fdeb62d 4b9fc6dd 0cd58ccb] connId=1 idleMask=0x0001 smpSmExecute event=6 state=13 connId=1 idleMask=0x0001 smpSmExecute event=6 state=14 smpSmExecute event=28 state=15 Cbi [7d734f74 37d7575f 9a2176fe 9e0d7793] smpSmExecute event=26 state=16 Rand Na [aa704717 22c5a505 922ea504 c8f32c21] smpSmExecute event=28 state=12 Cai [b8db800a c2cfb643 0ad2127e 154b27e3] connId=1 idleMask=0x0001 smpSmExecute event=6 state=13 connId=1 idleMask=0x0001 smpSmExecute event=6 state=14 smpSmExecute event=28 state=15 Cbi [fb8bfb47 1db075d6 c10dfe20 275580a6] smpSmExecute event=26 state=16 Rand Na [6715c20d 284d6526 c826990b c0266d4d] smpSmExecute event=28 state=12 Cai [9a07bded 4652b3b3 04e58dd3 ddc41f5b] connId=1 idleMask=0x0001 smpSmExecute event=6 state=13 connId=1 idleMask=0x0001 smpSmExecute event=6 state=14 smpSmExecute event=28 state=15 Cbi [9b11572d 6ac46706 2a42ddf7 fa3f7eb6] smpSmExecute event=26 state=16 Rand Na [276b1950 0160195c 2ca2749e 04cc0bba] smpSmExecute event=28 state=12 Cai [7811b835 1ee6cd01 b35e0068 b0e995a2] connId=1 idleMask=0x0001 smpSmExecute event=6 state=13 connId=1 idleMask=0x0001 smpSmExecute event=6 state=14 smpSmExecute event=28 state=15 Cbi [febf4094 ccf93969 adc4d7e3 c3f26246] smpSmExecute event=26 state=16 Rand Na [31c8d021 62bd5eb6 470c008d 0f9a8f69] smpSmExecute event=28 state=12 Cai [6cc99436 0835e6bf b7ccd2a8 81eb7c2d] connId=1 idleMask=0x0001 smpSmExecute event=6 state=13 connId=1 idleMask=0x0001 smpSmExecute event=6 state=14 smpSmExecute event=28 state=15 Cbi [314f5edd e73e8b9e 865c3924 c438e032] smpSmExecute event=26 state=16 Rand Na [4f46b9ce 57474f8d 8d00a000 74bdea15] smpSmExecute event=28 state=12 Cai [baea7468 fabb299a 837bbbfb c47572e2] connId=1 idleMask=0x0001 smpSmExecute event=6 state=13 connId=1 idleMask=0x0001 smpSmExecute event=6 state=14 smpSmExecute event=28 state=15 Cbi [f8a46358 201aab0a ae9aae2c 0c32fb92] smpSmExecute event=26 state=16 Rand Na [b80a6511 3c82e7e6 055243e6 a45202a6] smpSmExecute event=28 state=12 Cai [24c084e8 e92b8e03 1a37f096 f4d5c31f] connId=1 idleMask=0x0001 smpSmExecute event=6 state=13 connId=1 idleMask=0x0001 smpSmExecute event=6 state=14 smpSmExecute event=28 state=15 Cbi [04aa43e8 dac7aa2a 490e6154 11b81966] smpSmExecute event=26 state=16 Rand Na [16bc0b9f a93b2745 729a08b9 85682b0d] smpSmExecute event=28 state=12 Cai [a5caa3a1 b7b66eaa f113972c 88645db6] connId=1 idleMask=0x0001 smpSmExecute event=6 state=13 connId=1 idleMask=0x0001 smpSmExecute event=6 state=14 smpSmExecute event=28 state=15 Cbi [831b8daf 7ae674d8 e2c5fbc3 9fc27be3] smpSmExecute event=26 state=16 Rand Na [3a8e02cf 001e84b3 08d9a24e 19ff9b18] smpSmExecute event=28 state=12 Cai [bf5345f1 299bca3f 0c99eac6 3ea96052] connId=1 idleMask=0x0001 smpSmExecute event=6 state=13 connId=1 idleMask=0x0001 smpSmExecute event=6 state=14 smpSmExecute event=28 state=15 Cbi [0a4dec2e 6aebc804 7bb1a21b aadc18c1] smpSmExecute event=27 state=16 smpSmExecute event=25 state=19 DHKey (Shared Secret) [7cf8b651 6c0f5bff 7d66bbf6 d8d85abd] [0ef6bf2d 85a594d2 f55dccc3 6f98dd1d] smpSmExecute event=28 state=20 T [a02f2c9d 9a153f28 0bde8cb2 ab2a7b84] smpSmExecute event=28 state=21 MAC [66ebd01a c4818e8b 1cec71bf f0644ed9] smpSmExecute event=28 state=22 LTK [b4cad222 8324e2fb 71bbca0f 04bfc828] smpSmExecute event=28 state=23 DHKey Ea [a2925a68 0b71e9c3 065a959d 39079b01] smpSmExecute event=28 state=24 DHKey Eb [3ed3c373 5b99fc5e 16577603 7a1ba181] connId=1 idleMask=0x0001 smpSmExecute event=6 state=25 connId=1 idleMask=0x0001 smpSmExecute event=8 state=34 Datc got evt 44 >>> Connection encrypted <<< smpSmExecute event=6 state=35 smpSmExecute event=6 state=35 smpSmExecute event=12 state=35 Datc got evt 47 Datc got evt 47 smpSmExecute event=12 state=35 smpSmExecute event=12 state=35 smpSmExecute event=14 state=35 connId=1 idleMask=0x0000 Datc got evt 42 >>> Pairing completed successfully <<< dmDevPassEvtToDevPriv: event: 13, param: 1, advHandle: 0 Datc got evt 58 Datc got evt 63 Simple message passing to peer: btn 2 l Long Button 2 Press > Datc got evt 10 Datc got evt 13 hello back Secure message passing to peer: btn 2 m Medium Button 2 Press > Datc got evt 10 Datc got evt 13 >> Notification from secure data service <<< Secure data received! On PHY change request: btn 1 x XL Button 1 Press 2 MBit TX and RX PHY Requested > Datc got evt 70 DM_PHY_UPDATE_IND - RX: 2, TX: 2 Datc got evt 65 btn 1 x XL Button 1 Press LE Coded S2 TX and RX PHY Requested > Datc got evt 70 DM_PHY_UPDATE_IND - RX: 3, TX: 3 Datc got evt 65 btn 1 x XL Button 1 Press LE Coded S8 TX and RX PHY Requested > Datc got evt 70 DM_PHY_UPDATE_IND - RX: 3, TX: 3 btn 1 x XL Button 1 Press 1 MBit TX and RX PHY Requested > Datc got evt 70 DM_PHY_UPDATE_IND - RX: 1, TX: 1 Datc got evt 65 Data Transfer Speed test (1M PHY): btn 2 x XL Button 2 Press Starting speed test ... flowDisabled=1 handle=0 flowDisabled=0 handle=0 9520000 bits transferred in 18823249 us 505757 bps Data Transfer Speed test (2M PHY): btn 2 x XL Button 2 Press Starting speed test ... flowDisabled=1 handle=0 flowDisabled=0 handle=0 9520000 bits transferred in 9413977 us 1011262 bps Commands Type the desired command and parameter (if applicable) and press enter to execute the command. help Displays the available commands. echo (on|off) Enables or disables the input echo. On by default. btn (ID) (s|m|l|x) Simulates button presses. Example: \"btn 1 s\" for a short button press on button 1. pin (ConnID) (Pin Code) Used to input the pairing pin code. Push buttons Push buttons can be used to interact with the application. short : press is less than 200 ms medium : press is between 200 and 500 ms long : press is between 500 and 1000 ms extra long : press is greater than 1000 ms When disconnected Button 1 short: Start/Stop scanning Button 1 medium: Cycle through the connection index (select connection) Button 1 long: Clear all bonding info Button 1 extra long: Add RPAO characteristic to GAP service -- needed only when DM Privacy enabled Button 2 extra long: Enable device privacy -- start generating local RPAs every 15 minutes When connected Button 1 short: Start/Stop scanning Button 1 medium: Cycle through connection index (select connection) Button 1 long: Close selected connection Button 2 short: Request PHY change (1M-2M-S2-S8) Only for BLE5 version. Button 2 medium : Send secure message to peer Button 2 long: Send short message to peer Button 2 extra long: Start data transfer speed test","title":"BLE_datc_dats"},{"location":"Libraries/Cordio/docs/Applications/BLE_datc_dats/#ble_datc_dats","text":"BLE Data Client and Data Server. These examples demonstrate a simple data client and server. The intent here is to show simple unformatted data exchange between two devices. The Bluetooth specification does not define a simple data exchange protocol, similar to UART. We use a proprietary GATT service to offer this feature. The data server will advertise with a devices name of \"DATS\". The data client will scan for this device and create a connection. Once the conneciton has been created and the client completes the discovery, it will enable notificaitons and indiciations on the proprietary data serivce. This will allow the server to transmit data to the client with notifications to the proprietary data characteristic. The client can transmit data to the server by writing to the proprietary data characteristic. ADI Attach connected to DATS","title":"BLE_datc_dats"},{"location":"Libraries/Cordio/docs/Applications/BLE_datc_dats/#arm-proprietary-data-service","text":"UUID: E0262760-08C2-11E1-9073-0E8AC72E1001 This is a proprietary serivce is used for simple unformatted data exchange between the server and the client.","title":"ARM Proprietary data service"},{"location":"Libraries/Cordio/docs/Applications/BLE_datc_dats/#secure-data-service","text":"UUID: 42FC367E-32D9-4285-87C6-339924D135BE This is another proprietary service used for secure data exchange that requires elevated levels of encryption and authentication. Devices must be paired with LE Secure Connections to enable data transfer with this service.","title":"Secure data service"},{"location":"Libraries/Cordio/docs/Applications/BLE_datc_dats/#leds","text":"The red LED will indicate that an error assertion has occurred. The green LED indicates CPU activity. When the LED is on, the CPU is active, when the LED is off, the CPU is in sleep mode.","title":"LEDs"},{"location":"Libraries/Cordio/docs/Applications/BLE_datc_dats/#ble_dats","text":"Bluetooth data server that advertises as \"DATS\" and accepts connection requests. This exmaples contains two proprietary services that are used to show simple message passing to and from the data client.","title":"BLE_Dats"},{"location":"Libraries/Cordio/docs/Applications/BLE_datc_dats/#expected-output","text":"On startup: terminal: init 32kHz trimmed to 0x16 DatsHandlerInit Dats got evt 32 >>> Reset complete <<< dmAdvActConfig: state: 0 dmAdvActSetData: state: 0 dmAdvActSetData: state: 0 dmAdvActStart: state: 0 HCI_LE_ADV_ENABLE_CMD_CMPL_CBACK_EVT: state: 3 dmDevPassEvtToDevPriv: event: 12, param: 33, advHandle: 0 Dats got evt 33 >>> Advertising started <<< Dats got evt 21 Database hash updated When a connection attempting to connect to the client. Dats got evt 21 Database hash updated Dats got evt 153 dmConnIdByBdAddr not found dmConnCcbAlloc 1 dmConnSmExecute event=28 state=0 dmAdvConnected: state: 1 dmDevPassEvtToDevPriv: event: 13, param: 34, advHandle: 0 smpDbGetRecord: connId: 1 type: 0 smpDbAddDevice SmpDbGetFailureCount: connId: 1 count: 0 smpDbGetRecord: connId: 1 type: 0 smpDbAddDevice SmpDbGetPairingDisabledTime: connId: 1 period: 0 attemptMult: 0 Dats got evt 39 >>> Connection opened <<< Dats got evt 65 Dats got evt 22 smpSmExecute event=6 state=0 connId=1 idleMask=0x0001 Dats got evt 49 smpSmExecute event=2 state=2 smpSmExecute event=17 state=3 smpSmExecute event=4 state=5 smpSmExecute event=6 state=4 smpSmExecute event=20 state=6 connId=1 idleMask=0x0001 Dats got evt 46 >>> Prompt user to enter passkey <<< Dats got evt 87 connId=1 idleMask=0x0005 connId=1 idleMask=0x0005 connId=1 idleMask=0x0005 connId=1 idleMask=0x0005 connId=1 idleMask=0x0005 connId=1 idleMask=0x0005 connId=1 idleMask=0x0005 connId=1 idleMask=0x0005 When matching pins have been entered > smpSmExecute event=4 state=13 Rand Nb [52730a1e 080e2b3f 6d010f4b 0d29b8ac] smpSmExecute event=28 state=15 Cbi [520aab85 e23b56d5 70598231 64553242] connId=1 idleMask=0x0001 smpSmExecute event=6 state=16 smpSmExecute event=28 state=17 Ca [634082f9 ae97841d 408a0609 d3149a0f] Ca Peer [634082f9 ae97841d 408a0609 d3149a0f] connId=1 idleMask=0x0001 smpSmExecute event=26 state=18 smpSmExecute event=6 state=14 Rand Nb [2b4f65e1 41465986 1732c49b 0779c049] smpSmExecute event=28 state=15 Cbi [34b63e15 0a0b1d8a fbaac17d ae94c891] connId=1 idleMask=0x0001 smpSmExecute event=6 state=16 smpSmExecute event=28 state=17 Ca [e7b74ec3 7bb660e0 fd3ffb69 a70fc1b5] Ca Peer [e7b74ec3 7bb660e0 fd3ffb69 a70fc1b5] connId=1 idleMask=0x0001 smpSmExecute event=26 state=18 smpSmExecute event=6 state=14 Rand Nb [cb42c521 d4edb9cd fe2a5777 526d153d] smpSmExecute event=28 state=15 Cbi [58d9a8c4 c4710a1a bd41ed81 2e666953] connId=1 idleMask=0x0001 smpSmExecute event=6 state=16 smpSmExecute event=28 state=17 Ca [d100648f ae87b3e0 850e96ef 3c2c9a47] Ca Peer [d100648f ae87b3e0 850e96ef 3c2c9a47] connId=1 idleMask=0x0001 smpSmExecute event=26 state=18 smpSmExecute event=6 state=14 Rand Nb [21a3cd36 613f1834 c6e3d6fa 337e3f6c] smpSmExecute event=28 state=15 Cbi [314e5afe c5799362 0c3c7e01 54a62b7d] connId=1 idleMask=0x0001 smpSmExecute event=6 state=16 smpSmExecute event=28 state=17 Ca [bc03c14d cf73fbab c64c8de8 65c9bd3f] Ca Peer [bc03c14d cf73fbab c64c8de8 65c9bd3f] connId=1 idleMask=0x0001 smpSmExecute event=26 state=18 smpSmExecute event=6 state=14 Rand Nb [3e0cb037 9edea6c2 dfdd238f eee47a18] smpSmExecute event=28 state=15 Cbi [223876ac 32cfa06e 5764766f e655cfda] connId=1 idleMask=0x0001 smpSmExecute event=6 state=16 smpSmExecute event=28 state=17 Ca [3a1dceac 4ed11dc5 60384042 5f625042] Ca Peer [3a1dceac 4ed11dc5 60384042 5f625042] connId=1 idleMask=0x0001 smpSmExecute event=26 state=18 smpSmExecute event=6 state=14 Rand Nb [23ca1caf 70a3ba5b fd40e6ca db907405] smpSmExecute event=28 state=15 Cbi [0f969efc f159e4c6 588c68ae 5d1f9851] connId=1 idleMask=0x0001 smpSmExecute event=6 state=16 smpSmExecute event=28 state=17 Ca [c34f8c33 3e16ee08 3cac6f79 1eea831f] Ca Peer [c34f8c33 3e16ee08 3cac6f79 1eea831f] connId=1 idleMask=0x0001 smpSmExecute event=26 state=18 smpSmExecute event=6 state=14 Rand Nb [840f704c 59845fc2 47d5463a 9c68159b] smpSmExecute event=28 state=15 Cbi [f5a84dfe 36bdfc2d 410e133d 0c474039] connId=1 idleMask=0x0001 smpSmExecute event=6 state=16 smpSmExecute event=28 state=17 Ca [e27af695 a9227a18 74c2ba3d 57ed5254] Ca Peer [e27af695 a9227a18 74c2ba3d 57ed5254] connId=1 idleMask=0x0001 smpSmExecute event=26 state=18 smpSmExecute event=6 state=14 Rand Nb [5558d557 ba639669 226f7665 98ba1755] smpSmExecute event=28 state=15 Cbi [c8158453 c50a9448 236c7bd5 fe249a0d] connId=1 idleMask=0x0001 smpSmExecute event=6 state=16 smpSmExecute event=28 state=17 Ca [530da1cb 834ec9fa 6076fd05 037dce54] Ca Peer [530da1cb 834ec9fa 6076fd05 037dce54] connId=1 idleMask=0x0001 smpSmExecute event=26 state=18 smpSmExecute event=6 state=14 Rand Nb [9f57fda8 897aac72 810475a4 eda95e4c] smpSmExecute event=28 state=15 Cbi [12494fdf 83718797 5efa3ff7 4e230a9d] connId=1 idleMask=0x0001 smpSmExecute event=6 state=16 smpSmExecute event=28 state=17 Ca [b9c97dbe 7a725ab4 20c59148 10821669] Ca Peer [b9c97dbe 7a725ab4 20c59148 10821669] connId=1 idleMask=0x0001 smpSmExecute event=26 state=18 smpSmExecute event=6 state=14 Rand Nb [564e5d0e 2605341f 4d5b6913 0c89c1aa] smpSmExecute event=28 state=15 Cbi [a8b37963 eafdcaee ecbf62ab a23f686a] connId=1 idleMask=0x0001 smpSmExecute event=6 state=16 smpSmExecute event=28 state=17 Ca [b1387cd1 054a3616 3a73b06d 085e74b7] Ca Peer [b1387cd1 054a3616 3a73b06d 085e74b7] connId=1 idleMask=0x0001 smpSmExecute event=26 state=18 smpSmExecute event=6 state=14 Rand Nb [fc4d0a4e 2e6ca8f1 65f242a8 88876d0e] smpSmExecute event=28 state=15 Cbi [623c1256 7e20dba1 f5257b86 11b54ece] connId=1 idleMask=0x0001 smpSmExecute event=6 state=16 smpSmExecute event=28 state=17 Ca [4540e3cd 77e8ac57 8024607c 0de42ce2] Ca Peer [4540e3cd 77e8ac57 8024607c 0de42ce2] connId=1 idleMask=0x0001 smpSmExecute event=26 state=18 smpSmExecute event=6 state=14 Rand Nb [144e1412 64996fa0 d686011f 7913327d] smpSmExecute event=28 state=15 Cbi [b354740a 3d097abc e33af952 cffc0e8a] connId=1 idleMask=0x0001 smpSmExecute event=6 state=16 smpSmExecute event=28 state=17 Ca [ba1e5505 2e488dda b984bd08 2d07fdeb] Ca Peer [ba1e5505 2e488dda b984bd08 2d07fdeb] connId=1 idleMask=0x0001 smpSmExecute event=26 state=18 smpSmExecute event=6 state=14 Rand Nb [2596e6cd 44929e11 9791ba02 62e3feef] smpSmExecute event=28 state=15 Cbi [3790e2f7 96ca63b6 826bbf5c 077c3f31] connId=1 idleMask=0x0001 smpSmExecute event=6 state=16 smpSmExecute event=28 state=17 Ca [fe05bd6a 1f277dee 124de8b0 02c03343] Ca Peer [fe05bd6a 1f277dee 124de8b0 02c03343] connId=1 idleMask=0x0001 smpSmExecute event=26 state=18 smpSmExecute event=6 state=14 Rand Nb [06175016 3aabb9f3 f3aa5925 c9b8a43d] smpSmExecute event=28 state=15 Cbi [57d2399c 89fbc8f0 3ee71020 f66b45d5] connId=1 idleMask=0x0001 smpSmExecute event=6 state=16 smpSmExecute event=28 state=17 Ca [c2dff69b 7ae8eba8 e92f3b57 ff3978c7] Ca Peer [c2dff69b 7ae8eba8 e92f3b57 ff3978c7] connId=1 idleMask=0x0001 smpSmExecute event=26 state=18 smpSmExecute event=6 state=14 Rand Nb [5c70daab 66fe0495 07d0e27d 824d9865] smpSmExecute event=28 state=15 Cbi [f03928aa 2324a2ca 8c3c1fd8 9d589afe] connId=1 idleMask=0x0001 smpSmExecute event=6 state=16 smpSmExecute event=28 state=17 Ca [9f8dec26 018dcea5 0cc56156 32b9107b] Ca Peer [9f8dec26 018dcea5 0cc56156 32b9107b] connId=1 idleMask=0x0001 smpSmExecute event=26 state=18 smpSmExecute event=6 state=14 Rand Nb [fd89b81d e2b3fdaf f22cf4c4 b39da763] smpSmExecute event=28 state=15 Cbi [c005af08 39334b4a ac68cf0a ca5acc00] connId=1 idleMask=0x0001 smpSmExecute event=6 state=16 smpSmExecute event=28 state=17 Ca [94681382 aa6a4d27 1b8eb879 a5ed8043] Ca Peer [94681382 aa6a4d27 1b8eb879 a5ed8043] connId=1 idleMask=0x0001 smpSmExecute event=26 state=18 smpSmExecute event=6 state=14 Rand Nb [5b0789ba 4bd1a9f8 10e15f9d 0dbd4ac2] smpSmExecute event=28 state=15 Cbi [b719fe1d 02e6cc10 8776a1b4 0bc0fa6b] connId=1 idleMask=0x0001 smpSmExecute event=6 state=16 smpSmExecute event=28 state=17 Ca [3f8a85da fad78d81 0c8e0733 876df6fb] Ca Peer [3f8a85da fad78d81 0c8e0733 876df6fb] connId=1 idleMask=0x0001 smpSmExecute event=26 state=18 smpSmExecute event=6 state=14 Rand Nb [c0c90b30 03659e86 a143abe4 ec289e73] smpSmExecute event=28 state=15 Cbi [d02d6808 35888e79 55e04238 f0930c07] connId=1 idleMask=0x0001 smpSmExecute event=6 state=16 smpSmExecute event=28 state=17 Ca [4efc0b02 bcd8bc6a ac93b70c effeaee1] Ca Peer [4efc0b02 bcd8bc6a ac93b70c effeaee1] connId=1 idleMask=0x0001 smpSmExecute event=26 state=18 smpSmExecute event=6 state=14 Rand Nb [96aab51d 5e627668 ba927ed6 d1192554] smpSmExecute event=28 state=15 Cbi [49660e21 5b3e82cd 32e3ac9a d839ad2d] connId=1 idleMask=0x0001 smpSmExecute event=6 state=16 smpSmExecute event=28 state=17 Ca [2db916d0 32b02469 1711edf5 812ae090] Ca Peer [2db916d0 32b02469 1711edf5 812ae090] connId=1 idleMask=0x0001 smpSmExecute event=26 state=18 smpSmExecute event=6 state=14 Rand Nb [d9e874e4 9b02cb3f 9aac021d 7ad59561] smpSmExecute event=28 state=15 Cbi [837b81cf 6c409caa c29a550b 649b2c46] connId=1 idleMask=0x0001 smpSmExecute event=6 state=16 smpSmExecute event=28 state=17 Ca [f3d0b1b5 76097bfb 14418e57 6d3c11ba] Ca Peer [f3d0b1b5 76097bfb 14418e57 6d3c11ba] smpSmExecute event=27 state=18 connId=1 idleMask=0x0001 smpSmExecute event=6 state=21 smpSmExecute event=25 state=22 DHKey (Shared Secret) [bf891259 97f62954 0f8d8934 5bcd585f] [48fc2eb4 4c6f5c19 b8f817a9 907571b3] smpSmExecute event=28 state=23 T [72c2ed8a fe1ae569 8237053f b5af654c] smpSmExecute event=28 state=24 MAC [273eaeb4 163166a1 362c8773 888811aa] smpSmExecute event=28 state=25 LTK [7eacbbfe 776de847 1b78effc 32e84ba5] smpSmExecute event=28 state=26 DHKey Ea [e619e7cf 7d654f17 f621cb5c f6dd720b] smpSmExecute event=28 state=27 DHKey Eb [1e72f16f dcab7a66 2787c1ce ee93d5ec] connId=1 idleMask=0x0001 connId=1 idleMask=0x0001 smpSmExecute event=8 state=36 Dats got evt 44 >>> Connection encrypted <<< Dats got evt 47 smpSmExecute event=12 state=37 smpSmExecute event=12 state=37 smpSmExecute event=6 state=37 smpSmExecute event=6 state=37 smpSmExecute event=14 state=37 connId=1 idleMask=0x0000 Dats got evt 47 Dats got evt 42 >>> Pairing completed successfully <<< dmDevPassEvtToDevPriv: event: 13, param: 1, advHandle: 0 Dats got evt 58 Dats got evt 63 Dats got evt 153 When PHY change performed > btn 2 s Short Button 2 Press 2 MBit TX and RX PHY Requested Dats got evt 70 DM_PHY_UPDATE_IND - RX: 2, TX: 2 Dats got evt 65 App got evt 16 App got evt 16 connId=1 idleMask=0x0000 > btn 2 s Short Button 2 Press LE Coded S2 TX and RX PHY Requested Dats got evt 70 DM_PHY_UPDATE_IND - RX: 3, TX: 3 Dats got evt 65 App got evt 16 App got evt 16 dmConnUpdExecute event=113 state=3 dmConnSmExecute event=30 state=3 Dats got evt 41 > btn 2 s Short Button 2 Press LE Coded S8 TX and RX PHY Requested Dats got evt 70 DM_PHY_UPDATE_IND - RX: 3, TX: 3 > btn 2 s Short Button 2 Press 1 MBit TX and RX PHY Requested Dats got evt 70 DM_PHY_UPDATE_IND - RX: 1, TX: 1 Dats got evt 65 When message received from peer hello world hciCoreTxAclStart len=18 Dats got evt 18 When secure message recevied from peer >> Received secure data << Secret number is 0x42 Dats got evt 18","title":"Expected Output"},{"location":"Libraries/Cordio/docs/Applications/BLE_datc_dats/#commands","text":"Type the desired command and parameter (if applicable) and press enter to execute the command. help Displays the available commands. echo (on|off) Enables or disables the input echo. On by default. btn (ID) (s|m|l|x) Simulates button presses. Example: \"btn 1 s\" for a short button press on button 1. pin (ConnID) (Pin Code) Used to input the pairing pin code.","title":"Commands"},{"location":"Libraries/Cordio/docs/Applications/BLE_datc_dats/#push-buttons","text":"Push buttons can be used to interact with the application. short press is less than 200 ms medium press is between 200 and 500 ms long press is between 500 and 1000 ms extra long press is greater than 1000 ms","title":"Push buttons"},{"location":"Libraries/Cordio/docs/Applications/BLE_datc_dats/#when-disconnected","text":"Button 1 short press: Start advertising Button 1 medium press: Enter bondable mode Button 1 long press: Clear all bonding info Button 1 extra long press: Show version info Button 2 short press: Stop advertising","title":"When disconnected"},{"location":"Libraries/Cordio/docs/Applications/BLE_datc_dats/#when-connected","text":"Button 2 short press: Change PHY (1M-2M-Coded_S2-Coded_S8)","title":"When connected"},{"location":"Libraries/Cordio/docs/Applications/BLE_datc_dats/#ble_datc","text":"Bluetooth data client that scans and connections to devices advertising with the device name \"DATS\". The client will automatically discover the profiles and services on the device, subscribing to notifications and indications to enable the unformatted data exchange with the proprietary data service.","title":"BLE_Datc"},{"location":"Libraries/Cordio/docs/Applications/BLE_datc_dats/#expected-output_1","text":"On startup: terminal: init 32kHz trimmed to 0xF DatcHandlerInit Calculating database hash Datc got evt 32 >>> Reset complete <<< Datc got evt 58 Database hash calculation complete Datc got evt 21 Database hash updated dmDevPassEvtToDevPriv: event: 13, param: 1, advHandle: 0 Datc got evt 63 Datc got evt 153 dmDevPassEvtToDevPriv: event: 12, param: 36, advHandle: 0 Datc got evt 36 >>> Scanning started <<< When a scan report has been received: Scan Report: 55:CF:67:1F:6F:27 Scan Report: 00:05:8B:44:12:02 Name: Fit When server has been found: Scan Report: 00:18:80:04:52:1F Name: DATS dmDevPassEvtToDevPriv: event: 13, param: 37, advHandle: 0 Datc got evt 37 Scan results: 4 dmConnIdByBdAddr not found dmConnCcbAlloc 1 >>> Scanning stopped <<< dmConnSmExecute event=24 state=0 dmDevPassEvtToDevPriv: event: 14, param: 0, advHandle: 0 dmConnSmExecute event=28 state=1 dmDevPassEvtToDevPriv: event: 14, param: 1, advHandle: 0 dmDevPassEvtToDevPriv: event: 12, param: 39, advHandle: 0 smpDbGetRecord: connId: 1 type: 0 smpDbAddDevice SmpDbGetFailureCount: connId: 1 count: 0 smpDbGetRecord: connId: 1 type: 0 smpDbAddDevice SmpDbGetPairingDisabledTime: connId: 1 period: 0 attemptMult: 0 Datc got evt 39 >>> Connection opened <<< smpSmExecute event=1 state=0 connId=1 idleMask=0x0001 Datc got evt 65 Datc got evt 22 smpSmExecute event=6 state=1 smpSmExecute event=17 state=2 smpSmExecute event=4 state=3 connId=1 idleMask=0x0001 Datc got evt 87 Datc got evt 4 connId=1 idleMask=0x0009 smpSmExecute event=6 state=4 smpSmExecute event=20 state=5 Datc got evt 46 >>> Prompt user to enter passkey <<< Datc got evt 3 AttcDiscServiceCmpl status 0x00 Datc got evt 4 AttcDiscCharCmpl status 0x79 Datc got evt 4 AttcDiscCharCmpl status 0x79 Datc got evt 2 AttcDiscCharCmpl status 0x00 connId=1 idleMask=0x0009 Datc got evt 3 AttcDiscServiceCmpl status 0x00 Datc got evt 4 AttcDiscCharCmpl status 0x79 Datc got evt 4 AttcDiscCharCmpl status 0x00 connId=1 idleMask=0x0009 Datc got evt 3 AttcDiscServiceCmpl status 0x00 Datc got evt 4 AttcDiscCharCmpl status 0x79 Datc got evt 4 AttcDiscCharCmpl status 0x79 Datc got evt 2 AttcDiscCharCmpl status 0x00 connId=1 idleMask=0x0009 Datc got evt 3 AttcDiscServiceCmpl status 0x00 Datc got evt 4 AttcDiscCharCmpl status 0x79 Datc got evt 4 AttcDiscCharCmpl status 0x79 Datc got evt 2 AttcDiscCharCmpl status 0x79 Datc got evt 2 AttcDiscCharCmpl status 0x00 connId=1 idleMask=0x0001 AppDiscComplete connId:1 status:0x04 connId=1 idleMask=0x0009 Datc got evt 9 AttcDiscConfigCmpl status 0x79 Datc got evt 9 AttcDiscConfigCmpl status 0x79 Datc got evt 9 AttcDiscConfigCmpl status 0x79 Datc got evt 9 AttcDiscConfigCmpl status 0x00 connId=1 idleMask=0x0001 AppDiscComplete connId:1 status:0x08 After entering a pin pin 1 12345 > smpSmExecute event=4 state=11 Rand Na [5fa96af9 f434b4de 3e452813 fef4f5eb] smpSmExecute event=28 state=12 Cai [57964640 e18b1aa1 8ea7d8b2 2eb274c3] connId=1 idleMask=0x0001 Once server enters a matching pin and encrypted connection is established smpSmExecute event=6 state=14 smpSmExecute event=28 state=15 Cbi [7e2523a4 be6a8923 8ef900bf d4eaa458] smpSmExecute event=26 state=16 Rand Na [efb856be 61bd11a8 2dff39c0 1f5d4d91] smpSmExecute event=28 state=12 Cai [65f7c942 8c216010 cc73fdc9 bd21120e] connId=1 idleMask=0x0001 smpSmExecute event=6 state=13 connId=1 idleMask=0x0001 smpSmExecute event=6 state=14 smpSmExecute event=28 state=15 Cbi [db4858f8 33a964c1 e35ba27c 1f07e7db] smpSmExecute event=26 state=16 Rand Na [9904fded 40ea2bb1 dfabe4be b9bcba45] smpSmExecute event=28 state=12 Cai [1362d0db 074d32ea 32d0e79c 1155a20b] connId=1 idleMask=0x0001 smpSmExecute event=6 state=13 connId=1 idleMask=0x0001 smpSmExecute event=6 state=14 smpSmExecute event=28 state=15 Cbi [efd27c04 96ff72e0 c893bf54 9c524f0a] smpSmExecute event=26 state=16 Rand Na [5ba16640 fd3af1ae afc6d035 d8eb1fa5] smpSmExecute event=28 state=12 Cai [79603efa ad87d2cd bdc4c83b 17dcffe6] connId=1 idleMask=0x0001 smpSmExecute event=6 state=13 connId=1 idleMask=0x0001 smpSmExecute event=6 state=14 smpSmExecute event=28 state=15 Cbi [c1221276 73df3bf7 90e8df64 741909c1] smpSmExecute event=26 state=16 Rand Na [59ea06d0 760407f7 87415144 fe234a1e] smpSmExecute event=28 state=12 Cai [40b9915c af4a8712 c81e98f9 f197953a] connId=1 idleMask=0x0001 smpSmExecute event=6 state=13 connId=1 idleMask=0x0001 smpSmExecute event=6 state=14 smpSmExecute event=28 state=15 Cbi [325fe15b 5a6862e1 f4de459d 6c91c220] smpSmExecute event=26 state=16 Rand Na [4c56f9f9 b1d91236 8dfb81f8 b0629bb7] smpSmExecute event=28 state=12 Cai [c2fb6b18 63cb9311 d53c3333 0a2924cf] connId=1 idleMask=0x0001 smpSmExecute event=6 state=13 connId=1 idleMask=0x0001 smpSmExecute event=6 state=14 smpSmExecute event=28 state=15 Cbi [7725d42d 35f8e465 b3b6cfed 9bfe125a] smpSmExecute event=26 state=16 Rand Na [3909e384 45979c24 c85d36d3 fc2bd4bf] smpSmExecute event=28 state=12 Cai [9e570480 195412a0 07c84616 36cd6a06] connId=1 idleMask=0x0001 smpSmExecute event=6 state=13 connId=1 idleMask=0x0001 smpSmExecute event=6 state=14 smpSmExecute event=28 state=15 Cbi [1bce9472 21f7d6c4 4f8fe62b 91ac2271] smpSmExecute event=26 state=16 Rand Na [fe57e223 78ca04e3 cd13bd82 ad43289c] smpSmExecute event=28 state=12 Cai [42ba2b2e bd35ebe6 56c59b28 957639d2] connId=1 idleMask=0x0001 smpSmExecute event=6 state=13 connId=1 idleMask=0x0001 smpSmExecute event=6 state=14 smpSmExecute event=28 state=15 Cbi [a35acba5 00eba332 31442e10 aea9dacf] smpSmExecute event=26 state=16 Rand Na [71aa44ad abe2d668 07b79f02 d2a974dc] smpSmExecute event=28 state=12 Cai [5b02fce8 f92549ca 54bea290 c9fdfd1b] connId=1 idleMask=0x0001 smpSmExecute event=6 state=13 connId=1 idleMask=0x0001 smpSmExecute event=6 state=14 smpSmExecute event=28 state=15 Cbi [4a52c87c a504c8cf 49d9e8f0 1a69aca2] smpSmExecute event=26 state=16 Rand Na [0f87eb54 83f4f78b 754d2f74 1b406c0d] smpSmExecute event=28 state=12 Cai [16a9ba43 8c8b39d2 912f1f85 3f738170] connId=1 idleMask=0x0001 smpSmExecute event=6 state=13 connId=1 idleMask=0x0001 smpSmExecute event=6 state=14 smpSmExecute event=28 state=15 Cbi [b2aa1f53 802fa4ad 3e415844 4953c931] smpSmExecute event=26 state=16 Rand Na [466db705 9fd2d031 35759a3f 45869950] smpSmExecute event=28 state=12 Cai [004c8d5f 4413efb9 f60c10c2 8af82058] connId=1 idleMask=0x0001 smpSmExecute event=6 state=13 connId=1 idleMask=0x0001 smpSmExecute event=6 state=14 smpSmExecute event=28 state=15 Cbi [6b93dfa8 91d6bc27 fbb7142a 778d6eab] smpSmExecute event=26 state=16 Rand Na [4d0cfaee 277f0959 ee9ad6b5 bf89e129] smpSmExecute event=28 state=12 Cai [b977b373 4fdeb62d 4b9fc6dd 0cd58ccb] connId=1 idleMask=0x0001 smpSmExecute event=6 state=13 connId=1 idleMask=0x0001 smpSmExecute event=6 state=14 smpSmExecute event=28 state=15 Cbi [7d734f74 37d7575f 9a2176fe 9e0d7793] smpSmExecute event=26 state=16 Rand Na [aa704717 22c5a505 922ea504 c8f32c21] smpSmExecute event=28 state=12 Cai [b8db800a c2cfb643 0ad2127e 154b27e3] connId=1 idleMask=0x0001 smpSmExecute event=6 state=13 connId=1 idleMask=0x0001 smpSmExecute event=6 state=14 smpSmExecute event=28 state=15 Cbi [fb8bfb47 1db075d6 c10dfe20 275580a6] smpSmExecute event=26 state=16 Rand Na [6715c20d 284d6526 c826990b c0266d4d] smpSmExecute event=28 state=12 Cai [9a07bded 4652b3b3 04e58dd3 ddc41f5b] connId=1 idleMask=0x0001 smpSmExecute event=6 state=13 connId=1 idleMask=0x0001 smpSmExecute event=6 state=14 smpSmExecute event=28 state=15 Cbi [9b11572d 6ac46706 2a42ddf7 fa3f7eb6] smpSmExecute event=26 state=16 Rand Na [276b1950 0160195c 2ca2749e 04cc0bba] smpSmExecute event=28 state=12 Cai [7811b835 1ee6cd01 b35e0068 b0e995a2] connId=1 idleMask=0x0001 smpSmExecute event=6 state=13 connId=1 idleMask=0x0001 smpSmExecute event=6 state=14 smpSmExecute event=28 state=15 Cbi [febf4094 ccf93969 adc4d7e3 c3f26246] smpSmExecute event=26 state=16 Rand Na [31c8d021 62bd5eb6 470c008d 0f9a8f69] smpSmExecute event=28 state=12 Cai [6cc99436 0835e6bf b7ccd2a8 81eb7c2d] connId=1 idleMask=0x0001 smpSmExecute event=6 state=13 connId=1 idleMask=0x0001 smpSmExecute event=6 state=14 smpSmExecute event=28 state=15 Cbi [314f5edd e73e8b9e 865c3924 c438e032] smpSmExecute event=26 state=16 Rand Na [4f46b9ce 57474f8d 8d00a000 74bdea15] smpSmExecute event=28 state=12 Cai [baea7468 fabb299a 837bbbfb c47572e2] connId=1 idleMask=0x0001 smpSmExecute event=6 state=13 connId=1 idleMask=0x0001 smpSmExecute event=6 state=14 smpSmExecute event=28 state=15 Cbi [f8a46358 201aab0a ae9aae2c 0c32fb92] smpSmExecute event=26 state=16 Rand Na [b80a6511 3c82e7e6 055243e6 a45202a6] smpSmExecute event=28 state=12 Cai [24c084e8 e92b8e03 1a37f096 f4d5c31f] connId=1 idleMask=0x0001 smpSmExecute event=6 state=13 connId=1 idleMask=0x0001 smpSmExecute event=6 state=14 smpSmExecute event=28 state=15 Cbi [04aa43e8 dac7aa2a 490e6154 11b81966] smpSmExecute event=26 state=16 Rand Na [16bc0b9f a93b2745 729a08b9 85682b0d] smpSmExecute event=28 state=12 Cai [a5caa3a1 b7b66eaa f113972c 88645db6] connId=1 idleMask=0x0001 smpSmExecute event=6 state=13 connId=1 idleMask=0x0001 smpSmExecute event=6 state=14 smpSmExecute event=28 state=15 Cbi [831b8daf 7ae674d8 e2c5fbc3 9fc27be3] smpSmExecute event=26 state=16 Rand Na [3a8e02cf 001e84b3 08d9a24e 19ff9b18] smpSmExecute event=28 state=12 Cai [bf5345f1 299bca3f 0c99eac6 3ea96052] connId=1 idleMask=0x0001 smpSmExecute event=6 state=13 connId=1 idleMask=0x0001 smpSmExecute event=6 state=14 smpSmExecute event=28 state=15 Cbi [0a4dec2e 6aebc804 7bb1a21b aadc18c1] smpSmExecute event=27 state=16 smpSmExecute event=25 state=19 DHKey (Shared Secret) [7cf8b651 6c0f5bff 7d66bbf6 d8d85abd] [0ef6bf2d 85a594d2 f55dccc3 6f98dd1d] smpSmExecute event=28 state=20 T [a02f2c9d 9a153f28 0bde8cb2 ab2a7b84] smpSmExecute event=28 state=21 MAC [66ebd01a c4818e8b 1cec71bf f0644ed9] smpSmExecute event=28 state=22 LTK [b4cad222 8324e2fb 71bbca0f 04bfc828] smpSmExecute event=28 state=23 DHKey Ea [a2925a68 0b71e9c3 065a959d 39079b01] smpSmExecute event=28 state=24 DHKey Eb [3ed3c373 5b99fc5e 16577603 7a1ba181] connId=1 idleMask=0x0001 smpSmExecute event=6 state=25 connId=1 idleMask=0x0001 smpSmExecute event=8 state=34 Datc got evt 44 >>> Connection encrypted <<< smpSmExecute event=6 state=35 smpSmExecute event=6 state=35 smpSmExecute event=12 state=35 Datc got evt 47 Datc got evt 47 smpSmExecute event=12 state=35 smpSmExecute event=12 state=35 smpSmExecute event=14 state=35 connId=1 idleMask=0x0000 Datc got evt 42 >>> Pairing completed successfully <<< dmDevPassEvtToDevPriv: event: 13, param: 1, advHandle: 0 Datc got evt 58 Datc got evt 63 Simple message passing to peer: btn 2 l Long Button 2 Press > Datc got evt 10 Datc got evt 13 hello back Secure message passing to peer: btn 2 m Medium Button 2 Press > Datc got evt 10 Datc got evt 13 >> Notification from secure data service <<< Secure data received! On PHY change request: btn 1 x XL Button 1 Press 2 MBit TX and RX PHY Requested > Datc got evt 70 DM_PHY_UPDATE_IND - RX: 2, TX: 2 Datc got evt 65 btn 1 x XL Button 1 Press LE Coded S2 TX and RX PHY Requested > Datc got evt 70 DM_PHY_UPDATE_IND - RX: 3, TX: 3 Datc got evt 65 btn 1 x XL Button 1 Press LE Coded S8 TX and RX PHY Requested > Datc got evt 70 DM_PHY_UPDATE_IND - RX: 3, TX: 3 btn 1 x XL Button 1 Press 1 MBit TX and RX PHY Requested > Datc got evt 70 DM_PHY_UPDATE_IND - RX: 1, TX: 1 Datc got evt 65 Data Transfer Speed test (1M PHY): btn 2 x XL Button 2 Press Starting speed test ... flowDisabled=1 handle=0 flowDisabled=0 handle=0 9520000 bits transferred in 18823249 us 505757 bps Data Transfer Speed test (2M PHY): btn 2 x XL Button 2 Press Starting speed test ... flowDisabled=1 handle=0 flowDisabled=0 handle=0 9520000 bits transferred in 9413977 us 1011262 bps","title":"Expected Output"},{"location":"Libraries/Cordio/docs/Applications/BLE_datc_dats/#commands_1","text":"Type the desired command and parameter (if applicable) and press enter to execute the command. help Displays the available commands. echo (on|off) Enables or disables the input echo. On by default. btn (ID) (s|m|l|x) Simulates button presses. Example: \"btn 1 s\" for a short button press on button 1. pin (ConnID) (Pin Code) Used to input the pairing pin code.","title":"Commands"},{"location":"Libraries/Cordio/docs/Applications/BLE_datc_dats/#push-buttons_1","text":"Push buttons can be used to interact with the application. short : press is less than 200 ms medium : press is between 200 and 500 ms long : press is between 500 and 1000 ms extra long : press is greater than 1000 ms","title":"Push buttons"},{"location":"Libraries/Cordio/docs/Applications/BLE_datc_dats/#when-disconnected_1","text":"Button 1 short: Start/Stop scanning Button 1 medium: Cycle through the connection index (select connection) Button 1 long: Clear all bonding info Button 1 extra long: Add RPAO characteristic to GAP service -- needed only when DM Privacy enabled Button 2 extra long: Enable device privacy -- start generating local RPAs every 15 minutes","title":"When disconnected"},{"location":"Libraries/Cordio/docs/Applications/BLE_datc_dats/#when-connected_1","text":"Button 1 short: Start/Stop scanning Button 1 medium: Cycle through connection index (select connection) Button 1 long: Close selected connection Button 2 short: Request PHY change (1M-2M-S2-S8) Only for BLE5 version. Button 2 medium : Send secure message to peer Button 2 long: Send short message to peer Button 2 extra long: Start data transfer speed test","title":"When connected"},{"location":"Libraries/Cordio/docs/Applications/BLE_fcc/","text":"BLE_fcc Project builds a simple serial port console for FCC testing. Usage LEDs The red LED will indicate that an error assertion has occurred. The green LED indicates CPU activity. When the LED is on, the CPU is active, when the LED is off, the CPU is in sleep mode. Expected Output On startup: RAM: 4 x 752 bytes -- connection context RAM: 16 x 719 bytes -- Tx buffer descriptors RAM: 6 x 2296 bytes -- advertising set context LlHandlerInit: LL initialization completed opModeFlags = 0x005F5C40 ### LlApi ### LlSetBdAddr Static BDA[5:3]=00:18:80 BDA[2:0]=06:81:0C Usage: (0) Transmit on RF channel 0 (2402 MHz) (1) Transmit on RF channel 19 (2440 MHz) (2) Transmit on RF channel 39 (2480 MHz) (3) Receive on RF channel 39 (2480 MHz) (4) Set Transmit power (5) Enable constant TX (6) Disable constant TX -- MUST be called after (5) (8) Set PHY (9) TX Frequency Hop (e) End transmission -- MUST be used after each (0-3, 9) (u) Print usage On TX test start (0) and stop (e) Transmit RF channel 0, 255 bytes/pkt, 0xAA, 1M PHY, forever .. ### LlApi ### LlTxTest, rfChan=0, len=255, pktType=7 res = 0 (SUCCESS) End test ### LlApi ### LlEndTest Test completed, numTx=1106 numRxSuccess=0 numRxCrcError=0 numRxTimeout=0 On RX test start (3) and stop (e) Receive RF channel 39, 1M PHY, forever .. ### LlApi ### LlRxTest, rfChan=39 res = 0 (SUCCESS) End test ### LlApi ### LlEndTest Test completed, numTx=0 numRxSuccess=658 numRxCrcError=0 numRxTimeout=0 On TX Frequency Hop test start (9) and stop (e) Starting frequency hopping ### LlApi ### LlTxTest, rfChan=0, len=255, pktType=7 ### LlApi ### LlTxTest, rfChan=1, len=255, pktType=7 ... ### LlApi ### LlTxTest, rfChan=23, len=255, pktType=7 ### LlApi ### LlTxTest, rfChan=24, len=255, pktType=7 End test ### LlApi ### LlEndTest Test completed, numTx=1304 numRxSuccess=0 numRxCrcError=0 numRxTimeout=0","title":"BLE_fcc"},{"location":"Libraries/Cordio/docs/Applications/BLE_fcc/#ble_fcc","text":"Project builds a simple serial port console for FCC testing.","title":"BLE_fcc"},{"location":"Libraries/Cordio/docs/Applications/BLE_fcc/#usage","text":"","title":"Usage"},{"location":"Libraries/Cordio/docs/Applications/BLE_fcc/#leds","text":"The red LED will indicate that an error assertion has occurred. The green LED indicates CPU activity. When the LED is on, the CPU is active, when the LED is off, the CPU is in sleep mode.","title":"LEDs"},{"location":"Libraries/Cordio/docs/Applications/BLE_fcc/#expected-output","text":"On startup: RAM: 4 x 752 bytes -- connection context RAM: 16 x 719 bytes -- Tx buffer descriptors RAM: 6 x 2296 bytes -- advertising set context LlHandlerInit: LL initialization completed opModeFlags = 0x005F5C40 ### LlApi ### LlSetBdAddr Static BDA[5:3]=00:18:80 BDA[2:0]=06:81:0C Usage: (0) Transmit on RF channel 0 (2402 MHz) (1) Transmit on RF channel 19 (2440 MHz) (2) Transmit on RF channel 39 (2480 MHz) (3) Receive on RF channel 39 (2480 MHz) (4) Set Transmit power (5) Enable constant TX (6) Disable constant TX -- MUST be called after (5) (8) Set PHY (9) TX Frequency Hop (e) End transmission -- MUST be used after each (0-3, 9) (u) Print usage On TX test start (0) and stop (e) Transmit RF channel 0, 255 bytes/pkt, 0xAA, 1M PHY, forever .. ### LlApi ### LlTxTest, rfChan=0, len=255, pktType=7 res = 0 (SUCCESS) End test ### LlApi ### LlEndTest Test completed, numTx=1106 numRxSuccess=0 numRxCrcError=0 numRxTimeout=0 On RX test start (3) and stop (e) Receive RF channel 39, 1M PHY, forever .. ### LlApi ### LlRxTest, rfChan=39 res = 0 (SUCCESS) End test ### LlApi ### LlEndTest Test completed, numTx=0 numRxSuccess=658 numRxCrcError=0 numRxTimeout=0 On TX Frequency Hop test start (9) and stop (e) Starting frequency hopping ### LlApi ### LlTxTest, rfChan=0, len=255, pktType=7 ### LlApi ### LlTxTest, rfChan=1, len=255, pktType=7 ... ### LlApi ### LlTxTest, rfChan=23, len=255, pktType=7 ### LlApi ### LlTxTest, rfChan=24, len=255, pktType=7 End test ### LlApi ### LlEndTest Test completed, numTx=1304 numRxSuccess=0 numRxCrcError=0 numRxTimeout=0","title":"Expected Output"},{"location":"Libraries/Cordio/docs/Applications/BLE_fit/","text":"BLE_fit Bluetooth fitness device. Showcases heart rate, battery level, running speed and cadence. Usage LEDs The red LED will indicate that an error assertion has occurred. The green LED indicates CPU activity. When the LED is on, the CPU is active, when the LED is off, the CPU is in sleep mode. Expected Output On startup: terminal: init 32kHz trimmed to 0xF FitHandlerInit Calculating database hash Fit got evt 32 >>> Reset complete <<< dmAdvActConfig: state: 0 dmAdvActSetData: state: 0 dmAdvActSetData: state: 0 dmAdvActStart: state: 0 HCI_LE_ADV_ENABLE_CMD_CMPL_CBACK_EVT: state: 3 dmDevPassEvtToDevPriv: event: 12, param: 33, advHandle: 0 Fit got evt 33 >>> Advertising started <<< Database hash calculation complete Fit got evt 21 Database hash updated Fit got evt 52 When a connection has been made. dmConnIdByBdAddr not found dmConnCcbAlloc 1 dmConnSmExecute event=28 state=0 dmAdvConnected: state: 1 dmDevPassEvtToDevPriv: event: 13, param: 34, advHandle: 0 AttsCccInitTable connId=1 smpDbGetRecord: connId: 1 type: 1 smpDbAddDevice SmpDbGetFailureCount: connId: 1 count: 0 smpDbGetRecord: connId: 1 type: 1 smpDbAddDevice SmpDbGetPairingDisabledTime: connId: 1 period: 0 attemptMult: 0 Fit got evt 39 >>> Connection opened <<< Fit got evt 65 Fit got evt 87 attsProcMtuReq features 0x00 hciCoreTxAclStart len=7 connId=1 idleMask=0x0004 hciCoreTxAclStart len=24 connId=1 idleMask=0x0004 hciCoreTxAclStart len=24 hciCoreTxAclStart len=27 hciCoreTxAclStart len=13 connId=1 idleMask=0x0004 hciCoreTxAclStart len=26 connId=1 idleMask=0x0004 hciCoreTxAclStart len=14 attsCccMainCback connId=1 handle=19 hciCoreTxAclStart len=5 Fit got evt 20 ccc state ind value:2 handle:19 idx:0 hciCoreTxAclStart len=27 hciCoreTxAclStart len=27 hciCoreTxAclStart len=27 hciCoreTxAclStart len=27 hciCoreTxAclStart len=13 hciCoreTxAclStart len=27 hciCoreTxAclStart len=9 connId=1 idleMask=0x0004 hciCoreTxAclStart len=10 hciCoreTxAclStart len=13 hciCoreTxAclStart len=13 hciCoreTxAclStart len=26 hciCoreTxAclStart len=27 hciCoreTxAclStart len=5 hciCoreTxAclStart len=23 hciCoreTxAclStart len=23 hciCoreTxAclStart len=23 hciCoreTxAclStart len=11 hciCoreTxAclStart len=12 connId=1 idleMask=0x0004 hciCoreTxAclStart len=10 hciCoreTxAclStart len=6 connId=1 idleMask=0x0004 hciCoreTxAclStart len=10 connId=1 idleMask=0x0004 hciCoreTxAclStart len=9 attsCccMainCback connId=1 handle=35 hciCoreTxAclStart len=7 attsCccMainCback connId=1 handle=99 hciCoreTxAclStart len=7 attsCccMainCback connId=1 handle=1189 hciCoreTxAclStart len=7 hciCoreTxAclStart len=14 App got evt 16 Commands Type the desired command and parameter (if applicable) and press enter to execute the command. help Displays the available commands. echo (on|off) Enables or disables the input echo. On by default. btn (ID) (s|m|l|x) Simulates button presses. Example: \"btn 1 s\" for a short button press on button 1. pin (ConnID) (Pin Code) Used to input the pairing pin code. Push buttons Push buttons can be used to interact with the application. short press is less than 200 ms medium press is between 200 and 500 ms long press is between 500 and 1000 ms extra long press is greater than 1000 ms When disconnected Button 1 short: Start/Stop scanning Button 1 medium: Enter discoverable and bondable mode Button 1 long: Clear all bonding info Button 2 short: Toggle HRM flag for 8 and 16 bit values When connected Button 1 short: Increment the heart rate Button 1 long: Close the connection Button 2 short: Decrement the heart rate Button 2 medium: Toggle HRM DET flags Button 2 long: Toggle HRM RR Interval feature flag Use ARM core and RISC-V core for split HCI In the project.mk, changing USE_DUAL_CORE to 1 will enable using both ARM core and RISC-V core for the split HCI.","title":"BLE_fit"},{"location":"Libraries/Cordio/docs/Applications/BLE_fit/#ble_fit","text":"Bluetooth fitness device. Showcases heart rate, battery level, running speed and cadence.","title":"BLE_fit"},{"location":"Libraries/Cordio/docs/Applications/BLE_fit/#usage","text":"","title":"Usage"},{"location":"Libraries/Cordio/docs/Applications/BLE_fit/#leds","text":"The red LED will indicate that an error assertion has occurred. The green LED indicates CPU activity. When the LED is on, the CPU is active, when the LED is off, the CPU is in sleep mode.","title":"LEDs"},{"location":"Libraries/Cordio/docs/Applications/BLE_fit/#expected-output","text":"On startup: terminal: init 32kHz trimmed to 0xF FitHandlerInit Calculating database hash Fit got evt 32 >>> Reset complete <<< dmAdvActConfig: state: 0 dmAdvActSetData: state: 0 dmAdvActSetData: state: 0 dmAdvActStart: state: 0 HCI_LE_ADV_ENABLE_CMD_CMPL_CBACK_EVT: state: 3 dmDevPassEvtToDevPriv: event: 12, param: 33, advHandle: 0 Fit got evt 33 >>> Advertising started <<< Database hash calculation complete Fit got evt 21 Database hash updated Fit got evt 52 When a connection has been made. dmConnIdByBdAddr not found dmConnCcbAlloc 1 dmConnSmExecute event=28 state=0 dmAdvConnected: state: 1 dmDevPassEvtToDevPriv: event: 13, param: 34, advHandle: 0 AttsCccInitTable connId=1 smpDbGetRecord: connId: 1 type: 1 smpDbAddDevice SmpDbGetFailureCount: connId: 1 count: 0 smpDbGetRecord: connId: 1 type: 1 smpDbAddDevice SmpDbGetPairingDisabledTime: connId: 1 period: 0 attemptMult: 0 Fit got evt 39 >>> Connection opened <<< Fit got evt 65 Fit got evt 87 attsProcMtuReq features 0x00 hciCoreTxAclStart len=7 connId=1 idleMask=0x0004 hciCoreTxAclStart len=24 connId=1 idleMask=0x0004 hciCoreTxAclStart len=24 hciCoreTxAclStart len=27 hciCoreTxAclStart len=13 connId=1 idleMask=0x0004 hciCoreTxAclStart len=26 connId=1 idleMask=0x0004 hciCoreTxAclStart len=14 attsCccMainCback connId=1 handle=19 hciCoreTxAclStart len=5 Fit got evt 20 ccc state ind value:2 handle:19 idx:0 hciCoreTxAclStart len=27 hciCoreTxAclStart len=27 hciCoreTxAclStart len=27 hciCoreTxAclStart len=27 hciCoreTxAclStart len=13 hciCoreTxAclStart len=27 hciCoreTxAclStart len=9 connId=1 idleMask=0x0004 hciCoreTxAclStart len=10 hciCoreTxAclStart len=13 hciCoreTxAclStart len=13 hciCoreTxAclStart len=26 hciCoreTxAclStart len=27 hciCoreTxAclStart len=5 hciCoreTxAclStart len=23 hciCoreTxAclStart len=23 hciCoreTxAclStart len=23 hciCoreTxAclStart len=11 hciCoreTxAclStart len=12 connId=1 idleMask=0x0004 hciCoreTxAclStart len=10 hciCoreTxAclStart len=6 connId=1 idleMask=0x0004 hciCoreTxAclStart len=10 connId=1 idleMask=0x0004 hciCoreTxAclStart len=9 attsCccMainCback connId=1 handle=35 hciCoreTxAclStart len=7 attsCccMainCback connId=1 handle=99 hciCoreTxAclStart len=7 attsCccMainCback connId=1 handle=1189 hciCoreTxAclStart len=7 hciCoreTxAclStart len=14 App got evt 16","title":"Expected Output"},{"location":"Libraries/Cordio/docs/Applications/BLE_fit/#commands","text":"Type the desired command and parameter (if applicable) and press enter to execute the command. help Displays the available commands. echo (on|off) Enables or disables the input echo. On by default. btn (ID) (s|m|l|x) Simulates button presses. Example: \"btn 1 s\" for a short button press on button 1. pin (ConnID) (Pin Code) Used to input the pairing pin code.","title":"Commands"},{"location":"Libraries/Cordio/docs/Applications/BLE_fit/#push-buttons","text":"Push buttons can be used to interact with the application. short press is less than 200 ms medium press is between 200 and 500 ms long press is between 500 and 1000 ms extra long press is greater than 1000 ms","title":"Push buttons"},{"location":"Libraries/Cordio/docs/Applications/BLE_fit/#when-disconnected","text":"Button 1 short: Start/Stop scanning Button 1 medium: Enter discoverable and bondable mode Button 1 long: Clear all bonding info Button 2 short: Toggle HRM flag for 8 and 16 bit values","title":"When disconnected"},{"location":"Libraries/Cordio/docs/Applications/BLE_fit/#when-connected","text":"Button 1 short: Increment the heart rate Button 1 long: Close the connection Button 2 short: Decrement the heart rate Button 2 medium: Toggle HRM DET flags Button 2 long: Toggle HRM RR Interval feature flag","title":"When connected"},{"location":"Libraries/Cordio/docs/Applications/BLE_fit/#use-arm-core-and-risc-v-core-for-split-hci","text":"In the project.mk, changing USE_DUAL_CORE to 1 will enable using both ARM core and RISC-V core for the split HCI.","title":"Use ARM core and RISC-V core for split HCI"},{"location":"Libraries/Cordio/docs/Applications/BLE_mcs/","text":"Description Maxim custom Bluetooth profile and service that advertises as \"MCS\" and accepts connection requests. Usage LEDs Each LED is controlled by a characteristic. Write the characteristic to 1 to turn on the LED, 0 to turn off the LED. Boards without 3 LEDs have the characteristics combined. Red LED Characteristic : 0x85FC567F31D9418587C6339924D1C5BE Green LED Characteristic : 0x85FC568031D9418587C6339924D1C5BE Blue LED Characteristic : 0x85FC568131D9418587C6339924D1C5BE Expected Output On startup: terminal: init McsAppHandlerInit Calculating database hash McsApp got evt 119 McsApp got evt 32 >>> Reset complete <<< dmAdvActConfig: state: 0 dmAdvActSetData: state: 0 dmAdvActSetData: state: 0 dmAdvActStart: state: 0 HCI_LE_ADV_ENABLE_CMD_CMPL_CBACK_EVT: state: 3 dmDevPassEvtToDevPriv: event: 12, param: 33, advHandle: 0 McsApp got evt 33 >>> Advertising started <<< Database hash calculation complete McsApp got evt 21 Database hash updated When a connection has been made. HCI_LE_ADV_ENABLE_CMD_CMPL_CBACK_EVT: state: 5 dmDevPassEvtToDevPriv: event: 13, param: 34, advHandle: 0 McsApp got evt 34 >>> Advertising stopped <<< dmAdvActConfig: state: 0 dmAdvActStart: state: 0 HCI_LE_ADV_ENABLE_CMD_CMPL_CBACK_EVT: state: 3 dmDevPassEvtToDevPriv: event: 12, param: 33, advHandle: 0 McsApp got evt 33 >>> Advertising started <<< dmConnIdByBdAddr not found dmConnCcbAlloc 1 dmConnSmExecute event=28 state=0 dmAdvConnected: state: 1 dmDevPassEvtToDevPriv: event: 13, param: 34, advHandle: 0 AttsCccInitTable connId=1 smpDbGetRecord: connId: 1 type: 1 smpDbAddDevice SmpDbGetFailureCount: connId: 1 count: 0 smpDbGetRecord: connId: 1 type: 1 smpDbAddDevice SmpDbGetPairingDisabledTime: connId: 1 period: 0 attemptMult: 0 McsApp got evt 39 >>> Connection opened <<< McsApp got evt 65 McsApp got evt 87 attsProcMtuReq features 0x00 hciCoreTxAclStart len=7 McsApp got evt 22 connId=1 idleMask=0x0004 hciCoreTxAclStart len=18 connId=1 idleMask=0x0004 hciCoreTxAclStart len=26 hciCoreTxAclStart len=34 connId=1 idleMask=0x0004 hciCoreTxAclStart len=34 attsCccMainCback connId=1 handle=19 hciCoreTxAclStart len=5 McsApp got evt 20 ccc state ind value:2 handle:19 idx:0 hciCoreTxAclStart len=90 hciCoreTxAclStart len=9 connId=1 idleMask=0x0004 hciCoreTxAclStart len=10 connId=1 idleMask=0x0004 hciCoreTxAclStart len=9 attsCccMainCback connId=1 handle=5379 hciCoreTxAclStart len=7 hciCoreTxAclStart len=14 When push buttons pressed btn 1 s Short Button 1 Press mcsAppBtnCback; 2 > hciCoreTxAclStart len=8 McsApp got evt 18 btn 1 m Medium Button 1 Press mcsAppBtnCback; 3 > hciCoreTxAclStart len=8 McsApp got evt 18 btn 1 l Long Button 1 Press mcsAppBtnCback; 4 > hciCoreTxAclStart len=8 McsApp got evt 18 btn 1 x XL Button 1 Press mcsAppBtnCback; 5 > hciCoreTxAclStart len=8 McsApp got evt 18 btn 2 s Short Button 2 Press mcsAppBtnCback; 7 > hciCoreTxAclStart len=8 McsApp got evt 18 btn 2 m Medium Button 2 Press mcsAppBtnCback; 8 > hciCoreTxAclStart len=8 McsApp got evt 18 btn 2 l Long Button 2 Press mcsAppBtnCback; 9 > hciCoreTxAclStart len=8 McsApp got evt 18 btn 2 x XL Button 2 Press mcsAppBtnCback; 10 > hciCoreTxAclStart len=8 McsApp got evt 18 Commands Type the desired command and parameter (if applicable) and press enter to execute the command. help Displays the available commands. echo (on|off) Enables or disables the input echo. On by default. btn (ID) (s|m|l|x) Simulates button presses. Example: \"btn 1 s\" for a short button press on button 1. pin (ConnID) (Pin Code) Used to input the pairing pin code. Push buttons Push buttons can be used to set McsButton characteristic. The value can be read via BLE. short press is less than 200 ms medium press is between 200 and 500 ms long press is between 500 and 1000 ms extra long press is greater than 1000 ms When connected Button 1 short press: set McsButton = 0x02 Button 1 medium press: set McsButton = 0x03 Button 1 long press: set McsButton = 0x04 Button 1 extra long press: set McsButton = 0x05 Button 2 short press: set McsButton = 0x07 Button 2 medium press: set McsButton = 0x08 Button 2 long press: set McsButton = 0x09 Button 2 extra long press: set McsButton = 0x0A","title":"BLE mcs"},{"location":"Libraries/Cordio/docs/Applications/BLE_mcs/#description","text":"Maxim custom Bluetooth profile and service that advertises as \"MCS\" and accepts connection requests.","title":"Description"},{"location":"Libraries/Cordio/docs/Applications/BLE_mcs/#usage","text":"","title":"Usage"},{"location":"Libraries/Cordio/docs/Applications/BLE_mcs/#leds","text":"Each LED is controlled by a characteristic. Write the characteristic to 1 to turn on the LED, 0 to turn off the LED. Boards without 3 LEDs have the characteristics combined. Red LED Characteristic : 0x85FC567F31D9418587C6339924D1C5BE Green LED Characteristic : 0x85FC568031D9418587C6339924D1C5BE Blue LED Characteristic : 0x85FC568131D9418587C6339924D1C5BE","title":"LEDs"},{"location":"Libraries/Cordio/docs/Applications/BLE_mcs/#expected-output","text":"On startup: terminal: init McsAppHandlerInit Calculating database hash McsApp got evt 119 McsApp got evt 32 >>> Reset complete <<< dmAdvActConfig: state: 0 dmAdvActSetData: state: 0 dmAdvActSetData: state: 0 dmAdvActStart: state: 0 HCI_LE_ADV_ENABLE_CMD_CMPL_CBACK_EVT: state: 3 dmDevPassEvtToDevPriv: event: 12, param: 33, advHandle: 0 McsApp got evt 33 >>> Advertising started <<< Database hash calculation complete McsApp got evt 21 Database hash updated When a connection has been made. HCI_LE_ADV_ENABLE_CMD_CMPL_CBACK_EVT: state: 5 dmDevPassEvtToDevPriv: event: 13, param: 34, advHandle: 0 McsApp got evt 34 >>> Advertising stopped <<< dmAdvActConfig: state: 0 dmAdvActStart: state: 0 HCI_LE_ADV_ENABLE_CMD_CMPL_CBACK_EVT: state: 3 dmDevPassEvtToDevPriv: event: 12, param: 33, advHandle: 0 McsApp got evt 33 >>> Advertising started <<< dmConnIdByBdAddr not found dmConnCcbAlloc 1 dmConnSmExecute event=28 state=0 dmAdvConnected: state: 1 dmDevPassEvtToDevPriv: event: 13, param: 34, advHandle: 0 AttsCccInitTable connId=1 smpDbGetRecord: connId: 1 type: 1 smpDbAddDevice SmpDbGetFailureCount: connId: 1 count: 0 smpDbGetRecord: connId: 1 type: 1 smpDbAddDevice SmpDbGetPairingDisabledTime: connId: 1 period: 0 attemptMult: 0 McsApp got evt 39 >>> Connection opened <<< McsApp got evt 65 McsApp got evt 87 attsProcMtuReq features 0x00 hciCoreTxAclStart len=7 McsApp got evt 22 connId=1 idleMask=0x0004 hciCoreTxAclStart len=18 connId=1 idleMask=0x0004 hciCoreTxAclStart len=26 hciCoreTxAclStart len=34 connId=1 idleMask=0x0004 hciCoreTxAclStart len=34 attsCccMainCback connId=1 handle=19 hciCoreTxAclStart len=5 McsApp got evt 20 ccc state ind value:2 handle:19 idx:0 hciCoreTxAclStart len=90 hciCoreTxAclStart len=9 connId=1 idleMask=0x0004 hciCoreTxAclStart len=10 connId=1 idleMask=0x0004 hciCoreTxAclStart len=9 attsCccMainCback connId=1 handle=5379 hciCoreTxAclStart len=7 hciCoreTxAclStart len=14 When push buttons pressed btn 1 s Short Button 1 Press mcsAppBtnCback; 2 > hciCoreTxAclStart len=8 McsApp got evt 18 btn 1 m Medium Button 1 Press mcsAppBtnCback; 3 > hciCoreTxAclStart len=8 McsApp got evt 18 btn 1 l Long Button 1 Press mcsAppBtnCback; 4 > hciCoreTxAclStart len=8 McsApp got evt 18 btn 1 x XL Button 1 Press mcsAppBtnCback; 5 > hciCoreTxAclStart len=8 McsApp got evt 18 btn 2 s Short Button 2 Press mcsAppBtnCback; 7 > hciCoreTxAclStart len=8 McsApp got evt 18 btn 2 m Medium Button 2 Press mcsAppBtnCback; 8 > hciCoreTxAclStart len=8 McsApp got evt 18 btn 2 l Long Button 2 Press mcsAppBtnCback; 9 > hciCoreTxAclStart len=8 McsApp got evt 18 btn 2 x XL Button 2 Press mcsAppBtnCback; 10 > hciCoreTxAclStart len=8 McsApp got evt 18","title":"Expected Output"},{"location":"Libraries/Cordio/docs/Applications/BLE_mcs/#commands","text":"Type the desired command and parameter (if applicable) and press enter to execute the command. help Displays the available commands. echo (on|off) Enables or disables the input echo. On by default. btn (ID) (s|m|l|x) Simulates button presses. Example: \"btn 1 s\" for a short button press on button 1. pin (ConnID) (Pin Code) Used to input the pairing pin code.","title":"Commands"},{"location":"Libraries/Cordio/docs/Applications/BLE_mcs/#push-buttons","text":"Push buttons can be used to set McsButton characteristic. The value can be read via BLE. short press is less than 200 ms medium press is between 200 and 500 ms long press is between 500 and 1000 ms extra long press is greater than 1000 ms","title":"Push buttons"},{"location":"Libraries/Cordio/docs/Applications/BLE_mcs/#when-connected","text":"Button 1 short press: set McsButton = 0x02 Button 1 medium press: set McsButton = 0x03 Button 1 long press: set McsButton = 0x04 Button 1 extra long press: set McsButton = 0x05 Button 2 short press: set McsButton = 0x07 Button 2 medium press: set McsButton = 0x08 Button 2 long press: set McsButton = 0x09 Button 2 extra long press: set McsButton = 0x0A","title":"When connected"},{"location":"Libraries/Cordio/docs/Applications/BLE_otac_otas/","text":"BLE_otac Description Bluetooth data client that scans for and connects to advertisers with the name of \"OTAS\". The Wireless Data Exchange profile is used to transfer files from the client to the server. A CRC32 value is used to check the integrity of the transferred file. Usage LEDs The red LED will indicate that an error assertion has occurred. The green LED indicates CPU activity. When the LED is on, the CPU is active, when the LED is off, the CPU is in sleep mode. Setup The project.mk can be edited to select the appropriate application directory for the update image. Change FW_UPDATE_DIR to modify which application is used for the update. Whichever application is selected must be setup to run from the appropriate memory section, as defined by the Bootloader. Expected Output On startup: terminal: init 32kHz trimmed to 0x16 DatcHandlerInit File addr: 10025950 file size: 00033368 Update File CRC: 0x8871C78B WDXC: WdxcHandlerInit >>> Reset complete <<< Database hash updated dmDevPassEvtToDevPriv: event: 12, param: 36, advHandle: 0 >>> Scanning started <<< When a connection has been made. dmDevPassEvtToDevPriv: event: 13, param: 37, advHandle: 0 Scan results: 10 dmConnIdByBdAddr not found dmConnCcbAlloc 1 >>> Scanning stopped <<< dmConnSmExecute event=24 state=0 dmDevPassEvtToDevPriv: event: 14, param: 0, advHandle: 0 dmConnSmExecute event=28 state=1 dmDevPassEvtToDevPriv: event: 14, param: 1, advHandle: 0 dmDevPassEvtToDevPriv: event: 12, param: 39, advHandle: 0 smpDbGetRecord: connId: 1 type: 0 smpDbAddDevice SmpDbGetFailureCount: connId: 1 count: 0 smpDbGetRecord: connId: 1 type: 0 smpDbAddDevice SmpDbGetPairingDisabledTime: connId: 1 period: 0 attemptMult: 0 >>> Connection opened <<< connId=1 idleMask=0x0008 AttcDiscServiceCmpl status 0x00 AttcDiscCharCmpl status 0x79 AttcDiscCharCmpl status 0x79 AttcDiscCharCmpl status 0x00 connId=1 idleMask=0x0008 AttcDiscServiceCmpl status 0x00 AttcDiscCharCmpl status 0x79 AttcDiscCharCmpl status 0x00 connId=1 idleMask=0x0008 AttcDiscServiceCmpl status 0x00 AttcDiscCharCmpl status 0x79 AttcDiscCharCmpl status 0x79 AttcDiscCharCmpl status 0x00 connId=1 idleMask=0x0008 AttcDiscServiceCmpl status 0x00 AttcDiscCharCmpl status 0x79 AttcDiscCharCmpl status 0x79 AttcDiscCharCmpl status 0x79 AttcDiscCharCmpl status 0x79 AttcDiscCharCmpl status 0x79 AttcDiscCharCmpl status 0x79 AttcDiscCharCmpl status 0x00 connId=1 idleMask=0x0000 AppDiscComplete connId:1 status:0x04 connId=1 idleMask=0x0008 AttcDiscConfigCmpl status 0x79 AttcDiscConfigCmpl status 0x79 AttcDiscConfigCmpl status 0x79 AttcDiscConfigCmpl status 0x79 AttcDiscConfigCmpl status 0x79 AttcDiscConfigCmpl status 0x79 AttcDiscConfigCmpl status 0x00 connId=1 idleMask=0x0000 AppDiscComplete connId:1 status:0x08 OTA procedure btn 2 s Short Button 2 Press > WDXC file transfer control. FTC op: 2 status: 0 WDXC file transfer control. FTC op: 10 status: 0 >>> File discovery complete <<< >>> Current fw version: 1.0 <<< btn 2 m Medium Button 2 Press > WDXC file transfer control. FTC op: 4 status: 0 >>> Starting file transfer <<< ... WDXC file transfer control. FTC op: 10 status: 0 >>> File transfer complete 3547207 us <<< file_size = 209768 usec = 3547207 bps = 473112 flowDisabled=0 handle=0 btn 2 l Long Button 2 Press > WDXC file transfer control. FTC op: 8 status: 0 >>> Verify complete status: 0 <<< btn 2 x XL Button 2 Press > dmConnSmExecute event=29 state=3 dmConnCcbDealloc 1 dmDevPassEvtToDevPriv: event: 13, param: 40, advHandle: 0 smpDbGetRecord: connId: 1 type: 0 smpDbAddDevice SmpDbSetFailureCount: connId: 1 count: 0 smpSmExecute event=10 state=0 Connection closed status 0x0, reason 0x13 REMOTE TERM >>> Connection closed <<< Commands Type the desired command and parameter (if applicable) and press enter to execute the command. help Displays the available commands. echo (on|off) Enables or disables the input echo. On by default. btn (ID) (s|m|l|x) Simulates button presses. Example: \"btn 1 s\" for a short button press on button 1. pin (ConnID) (Pin Code) Used to input the pairing pin code. Push buttons Push buttons can be used to interact with the application. short press is less than 200 ms medium press is between 200 and 500 ms long press is between 500 and 1000 ms extra long press is greater than 1000 ms When connected Button 1 short: On/Off scanning Button 1 medium: Cycle through the connection index Button 1 long: Drop selected connection Button 1 extra long: Toggle PHY Button 2 short: Discover file space on the peer device. Button 2 medium: Start the update transfer. Button 2 long: Verify the transfer. Button 2 extra long: Command the peer to disconnect and reset. When disconnected Button 1 short press: On/Off scanning Button 1 medium press: Cycle through the connection index Button 1 long press: Clear all bonding info Button 1 extra long press: Add RPAO characteristic to GAP service -- needed only when DM Privacy enabled Button 2 extra long press: Enable device privacy -- start generating local RPAs every 15 minutes BLE_otas Description Bluetooth data server that advertises as \"OTAS\" and accepts connection requests. The Wireless Data Exchange profile is used to transfer files from the client to the server's internal/external flash. A CRC32 value is used to check the integrity of the transferred file. Usage LEDs The red LED will indicate that an error assertion has occurred. The green LED indicates CPU activity. When the LED is on, the CPU is active, when the LED is off, the CPU is in sleep mode. Setup The Bootloader application needs to be loaded prior to loading BLE_otas application. BLE_otas will run on top of the Bootloader . The linker file included with BLE_otas application must be used to properly setup the memory sections to coincide with the Bootloader . The project.mk in this BLE_otas application in conjunction with project.mk in Bootloader determine where the expected file is stored and read from. Default configuration is to use external flash to store the transferd file before writing it to internal flash space during the update. Alternatively by changing USE_INTERNAL_FLASH ?=0 to USE_INTERNAL_FLASH ?=1 the transfered file is stored in the update space. Expected Output On startup: terminal: init 32kHz trimmed to 0x18 DatsHandlerInit WDXS: WdxsHandlerInit FW_VERSION: 1.0 File Hdl: 1 Dats got evt 32 >>> Reset complete <<< dmAdvActConfig: state: 0 dmAdvActSetData: state: 0 dmAdvActSetData: state: 0 dmAdvActStart: state: 0 HCI_LE_ADV_ENABLE_CMD_CMPL_CBACK_EVT: state: 3 dmDevPassEvtToDevPriv: event: 12, param: 33, advHandle: 0 Dats got evt 33 >>> Advertising started <<< When a connection has been made. dmConnIdByBdAddr not found dmConnCcbAlloc 1 dmConnSmExecute event=28 state=0 dmAdvConnected: state: 1 dmDevPassEvtToDevPriv: event: 13, param: 34, advHandle: 0 smpDbGetRecord: connId: 1 type: 0 smpDbAddDevice SmpDbGetFailureCount: connId: 1 count: 0 smpDbGetRecord: connId: 1 type: 0 smpDbAddDevice SmpDbGetPairingDisabledTime: connId: 1 period: 0 attemptMult: 0 Dats got evt 39 >>> Connection opened <<< Dats got evt 65 Dats got evt 87 connId=1 idleMask=0x0004 connId=1 idleMask=0x0004 connId=1 idleMask=0x0004 connId=1 idleMask=0x0004 connId=1 idleMask=0x0004 connId=1 idleMask=0x0004 connId=1 idleMask=0x0004 connId=1 idleMask=0x0004 connId=1 idleMask=0x0004 connId=1 idleMask=0x0004 connId=1 idleMask=0x0004 Upon reception of btn 2 s command WDXS: FTC Write: len=12 WDXS: FTC Write: op=1 handle=0 WDXS: FTC GetReq handle=0 len=9 WDXS: FTC SendRsp op=2 handle=0 status=0 WDXS: Task Handler Evt=1 WDXS: FTC Send WDXS: AttHook handle=581 event=18 WDXS: Task Handler Evt=1 WDXS: FTC SendRsp op=10 handle=0 status=0 WDXS: AttHook handle=584 event=18 WDXS: Task Handler Evt=1 WDXS: FTC Send WDXS: AttHook handle=581 event=18 WDXS: Task Handler Evt=1 Upon reception of btn 2 m command WDXS: FTC Write: len=16 WDXS: FTC Write: op=3 handle=1 WDXS: FTC PutReq handle=1 offset=0, len=209768 >>> Initiating erase of 52 4K sectors in external flash <<< WDXS: FTC PutReq handle=1 status=0 >>> Erasing address 0x1000 in external flash <<< >>> Erasing address 0x2000 in external flash <<< >>> Erasing address 0x3000 in external flash <<< >>> Erasing address 0x4000 in external flash <<< >>> Erasing address 0x5000 in external flash <<< >>> Erasing address 0x6000 in external flash <<< >>> Erasing address 0x7000 in external flash <<< >>> Erasing address 0x8000 in external flash <<< ... ... >>> External flash erase complete <<< WDXS: FTC SendRsp op=4 handle=1 status=0 WDXS: Task Handler Evt=1 WDXS: FTC Send WDXS: AttHook handle=581 event=18 WDXS: Task Handler Evt=1 Ext Flash: Wrote 224 bytes @ 0x00000008 Ext Flash: Wrote 224 bytes @ 0x000000E8 Ext Flash: Wrote 224 bytes @ 0x000001C8 Ext Flash: Wrote 224 bytes @ 0x000002A8 Ext Flash: Wrote 224 bytes @ 0x00000388 Ext Flash: Wrote 224 bytes @ 0x00000468 Ext Flash: Wrote 224 bytes @ 0x00000548 Ext Flash: Wrote 224 bytes @ 0x00000628 ... ... WDXS: FTC SendRsp op=10 handle=1 status=0 WDXS: Task Handler Evt=1 WDXS: FTC Send WDXS: AttHook handle=581 event=18 WDXS: Task Handler Evt=1 Upon reception of btn 2 l command WDXS: FTC Write: len=3 WDXS: FTC Write: op=7 handle=1 WDXS: FTC VerifyReq: handle=1 CRC start addr: 0x00000000 Len: 0x00033368 CRC From File : 0x8871C78B CRC Calculated: 0x8871C78B WDXS: FTC SendRsp op=8 handle=1 status=0 WDXS: Task Handler Evt=1 WDXS: FTC Send WDXS: AttHook handle=581 event=18 WDXS: Task Handler Evt=1 Upon reception of btn 2 x command connId=1 idleMask=0x0000 dmConnSmExecute event=25 state=3 dmConnSmExecute event=29 state=4 dmConnCcbDealloc 1 smpDbGetRecord: connId: 1 type: 0 smpDbAddDevice SmpDbSetFailureCount: connId: 1 count: 0 smpSmExecute event=10 state=0 Dats got evt 40 Reseting! On successful update the device resets and connects once again. Commands Type the desired command and parameter (if applicable) and press enter to execute the command. help Displays the available commands. echo (on|off) Enables or disables the input echo. On by default. btn (ID) (s|m|l|x) Simulates button presses. Example: \"btn 1 s\" for a short button press on button 1. pin (ConnID) (Pin Code) Used to input the pairing pin code. Push buttons Push buttons can be used to interact with the application. short press is less than 200 ms medium press is between 200 and 500 ms long press is between 500 and 1000 ms extra long press is greater than 1000 ms When connected Button 2 short press: Toggle PHY Button 2 medium press : Display firmware version When disconnected Button 1 short press: On/Off advertising Button 1 medium press: Cycle through the connection index Button 1 long press: Clear all bonding info Button 1 extra long press: Add RPAO characteristic to GAP service -- needed only when DM Privacy enabled Button 2 medium press : Display firmware version Button 2 extra long press: Enable device privacy -- start generating local RPAs every 15 minutes","title":"BLE_otac"},{"location":"Libraries/Cordio/docs/Applications/BLE_otac_otas/#ble_otac","text":"","title":"BLE_otac"},{"location":"Libraries/Cordio/docs/Applications/BLE_otac_otas/#description","text":"Bluetooth data client that scans for and connects to advertisers with the name of \"OTAS\". The Wireless Data Exchange profile is used to transfer files from the client to the server. A CRC32 value is used to check the integrity of the transferred file.","title":"Description"},{"location":"Libraries/Cordio/docs/Applications/BLE_otac_otas/#usage","text":"","title":"Usage"},{"location":"Libraries/Cordio/docs/Applications/BLE_otac_otas/#leds","text":"The red LED will indicate that an error assertion has occurred. The green LED indicates CPU activity. When the LED is on, the CPU is active, when the LED is off, the CPU is in sleep mode.","title":"LEDs"},{"location":"Libraries/Cordio/docs/Applications/BLE_otac_otas/#setup","text":"The project.mk can be edited to select the appropriate application directory for the update image. Change FW_UPDATE_DIR to modify which application is used for the update. Whichever application is selected must be setup to run from the appropriate memory section, as defined by the Bootloader.","title":"Setup"},{"location":"Libraries/Cordio/docs/Applications/BLE_otac_otas/#expected-output","text":"On startup: terminal: init 32kHz trimmed to 0x16 DatcHandlerInit File addr: 10025950 file size: 00033368 Update File CRC: 0x8871C78B WDXC: WdxcHandlerInit >>> Reset complete <<< Database hash updated dmDevPassEvtToDevPriv: event: 12, param: 36, advHandle: 0 >>> Scanning started <<< When a connection has been made. dmDevPassEvtToDevPriv: event: 13, param: 37, advHandle: 0 Scan results: 10 dmConnIdByBdAddr not found dmConnCcbAlloc 1 >>> Scanning stopped <<< dmConnSmExecute event=24 state=0 dmDevPassEvtToDevPriv: event: 14, param: 0, advHandle: 0 dmConnSmExecute event=28 state=1 dmDevPassEvtToDevPriv: event: 14, param: 1, advHandle: 0 dmDevPassEvtToDevPriv: event: 12, param: 39, advHandle: 0 smpDbGetRecord: connId: 1 type: 0 smpDbAddDevice SmpDbGetFailureCount: connId: 1 count: 0 smpDbGetRecord: connId: 1 type: 0 smpDbAddDevice SmpDbGetPairingDisabledTime: connId: 1 period: 0 attemptMult: 0 >>> Connection opened <<< connId=1 idleMask=0x0008 AttcDiscServiceCmpl status 0x00 AttcDiscCharCmpl status 0x79 AttcDiscCharCmpl status 0x79 AttcDiscCharCmpl status 0x00 connId=1 idleMask=0x0008 AttcDiscServiceCmpl status 0x00 AttcDiscCharCmpl status 0x79 AttcDiscCharCmpl status 0x00 connId=1 idleMask=0x0008 AttcDiscServiceCmpl status 0x00 AttcDiscCharCmpl status 0x79 AttcDiscCharCmpl status 0x79 AttcDiscCharCmpl status 0x00 connId=1 idleMask=0x0008 AttcDiscServiceCmpl status 0x00 AttcDiscCharCmpl status 0x79 AttcDiscCharCmpl status 0x79 AttcDiscCharCmpl status 0x79 AttcDiscCharCmpl status 0x79 AttcDiscCharCmpl status 0x79 AttcDiscCharCmpl status 0x79 AttcDiscCharCmpl status 0x00 connId=1 idleMask=0x0000 AppDiscComplete connId:1 status:0x04 connId=1 idleMask=0x0008 AttcDiscConfigCmpl status 0x79 AttcDiscConfigCmpl status 0x79 AttcDiscConfigCmpl status 0x79 AttcDiscConfigCmpl status 0x79 AttcDiscConfigCmpl status 0x79 AttcDiscConfigCmpl status 0x79 AttcDiscConfigCmpl status 0x00 connId=1 idleMask=0x0000 AppDiscComplete connId:1 status:0x08 OTA procedure btn 2 s Short Button 2 Press > WDXC file transfer control. FTC op: 2 status: 0 WDXC file transfer control. FTC op: 10 status: 0 >>> File discovery complete <<< >>> Current fw version: 1.0 <<< btn 2 m Medium Button 2 Press > WDXC file transfer control. FTC op: 4 status: 0 >>> Starting file transfer <<< ... WDXC file transfer control. FTC op: 10 status: 0 >>> File transfer complete 3547207 us <<< file_size = 209768 usec = 3547207 bps = 473112 flowDisabled=0 handle=0 btn 2 l Long Button 2 Press > WDXC file transfer control. FTC op: 8 status: 0 >>> Verify complete status: 0 <<< btn 2 x XL Button 2 Press > dmConnSmExecute event=29 state=3 dmConnCcbDealloc 1 dmDevPassEvtToDevPriv: event: 13, param: 40, advHandle: 0 smpDbGetRecord: connId: 1 type: 0 smpDbAddDevice SmpDbSetFailureCount: connId: 1 count: 0 smpSmExecute event=10 state=0 Connection closed status 0x0, reason 0x13 REMOTE TERM >>> Connection closed <<<","title":"Expected Output"},{"location":"Libraries/Cordio/docs/Applications/BLE_otac_otas/#commands","text":"Type the desired command and parameter (if applicable) and press enter to execute the command. help Displays the available commands. echo (on|off) Enables or disables the input echo. On by default. btn (ID) (s|m|l|x) Simulates button presses. Example: \"btn 1 s\" for a short button press on button 1. pin (ConnID) (Pin Code) Used to input the pairing pin code.","title":"Commands"},{"location":"Libraries/Cordio/docs/Applications/BLE_otac_otas/#push-buttons","text":"Push buttons can be used to interact with the application. short press is less than 200 ms medium press is between 200 and 500 ms long press is between 500 and 1000 ms extra long press is greater than 1000 ms","title":"Push buttons"},{"location":"Libraries/Cordio/docs/Applications/BLE_otac_otas/#when-connected","text":"Button 1 short: On/Off scanning Button 1 medium: Cycle through the connection index Button 1 long: Drop selected connection Button 1 extra long: Toggle PHY Button 2 short: Discover file space on the peer device. Button 2 medium: Start the update transfer. Button 2 long: Verify the transfer. Button 2 extra long: Command the peer to disconnect and reset.","title":"When connected"},{"location":"Libraries/Cordio/docs/Applications/BLE_otac_otas/#when-disconnected","text":"Button 1 short press: On/Off scanning Button 1 medium press: Cycle through the connection index Button 1 long press: Clear all bonding info Button 1 extra long press: Add RPAO characteristic to GAP service -- needed only when DM Privacy enabled Button 2 extra long press: Enable device privacy -- start generating local RPAs every 15 minutes","title":"When disconnected"},{"location":"Libraries/Cordio/docs/Applications/BLE_otac_otas/#ble_otas","text":"","title":"BLE_otas"},{"location":"Libraries/Cordio/docs/Applications/BLE_otac_otas/#description_1","text":"Bluetooth data server that advertises as \"OTAS\" and accepts connection requests. The Wireless Data Exchange profile is used to transfer files from the client to the server's internal/external flash. A CRC32 value is used to check the integrity of the transferred file.","title":"Description"},{"location":"Libraries/Cordio/docs/Applications/BLE_otac_otas/#usage_1","text":"","title":"Usage"},{"location":"Libraries/Cordio/docs/Applications/BLE_otac_otas/#leds_1","text":"The red LED will indicate that an error assertion has occurred. The green LED indicates CPU activity. When the LED is on, the CPU is active, when the LED is off, the CPU is in sleep mode.","title":"LEDs"},{"location":"Libraries/Cordio/docs/Applications/BLE_otac_otas/#setup_1","text":"The Bootloader application needs to be loaded prior to loading BLE_otas application. BLE_otas will run on top of the Bootloader . The linker file included with BLE_otas application must be used to properly setup the memory sections to coincide with the Bootloader . The project.mk in this BLE_otas application in conjunction with project.mk in Bootloader determine where the expected file is stored and read from. Default configuration is to use external flash to store the transferd file before writing it to internal flash space during the update. Alternatively by changing USE_INTERNAL_FLASH ?=0 to USE_INTERNAL_FLASH ?=1 the transfered file is stored in the update space.","title":"Setup"},{"location":"Libraries/Cordio/docs/Applications/BLE_otac_otas/#expected-output_1","text":"On startup: terminal: init 32kHz trimmed to 0x18 DatsHandlerInit WDXS: WdxsHandlerInit FW_VERSION: 1.0 File Hdl: 1 Dats got evt 32 >>> Reset complete <<< dmAdvActConfig: state: 0 dmAdvActSetData: state: 0 dmAdvActSetData: state: 0 dmAdvActStart: state: 0 HCI_LE_ADV_ENABLE_CMD_CMPL_CBACK_EVT: state: 3 dmDevPassEvtToDevPriv: event: 12, param: 33, advHandle: 0 Dats got evt 33 >>> Advertising started <<< When a connection has been made. dmConnIdByBdAddr not found dmConnCcbAlloc 1 dmConnSmExecute event=28 state=0 dmAdvConnected: state: 1 dmDevPassEvtToDevPriv: event: 13, param: 34, advHandle: 0 smpDbGetRecord: connId: 1 type: 0 smpDbAddDevice SmpDbGetFailureCount: connId: 1 count: 0 smpDbGetRecord: connId: 1 type: 0 smpDbAddDevice SmpDbGetPairingDisabledTime: connId: 1 period: 0 attemptMult: 0 Dats got evt 39 >>> Connection opened <<< Dats got evt 65 Dats got evt 87 connId=1 idleMask=0x0004 connId=1 idleMask=0x0004 connId=1 idleMask=0x0004 connId=1 idleMask=0x0004 connId=1 idleMask=0x0004 connId=1 idleMask=0x0004 connId=1 idleMask=0x0004 connId=1 idleMask=0x0004 connId=1 idleMask=0x0004 connId=1 idleMask=0x0004 connId=1 idleMask=0x0004 Upon reception of btn 2 s command WDXS: FTC Write: len=12 WDXS: FTC Write: op=1 handle=0 WDXS: FTC GetReq handle=0 len=9 WDXS: FTC SendRsp op=2 handle=0 status=0 WDXS: Task Handler Evt=1 WDXS: FTC Send WDXS: AttHook handle=581 event=18 WDXS: Task Handler Evt=1 WDXS: FTC SendRsp op=10 handle=0 status=0 WDXS: AttHook handle=584 event=18 WDXS: Task Handler Evt=1 WDXS: FTC Send WDXS: AttHook handle=581 event=18 WDXS: Task Handler Evt=1 Upon reception of btn 2 m command WDXS: FTC Write: len=16 WDXS: FTC Write: op=3 handle=1 WDXS: FTC PutReq handle=1 offset=0, len=209768 >>> Initiating erase of 52 4K sectors in external flash <<< WDXS: FTC PutReq handle=1 status=0 >>> Erasing address 0x1000 in external flash <<< >>> Erasing address 0x2000 in external flash <<< >>> Erasing address 0x3000 in external flash <<< >>> Erasing address 0x4000 in external flash <<< >>> Erasing address 0x5000 in external flash <<< >>> Erasing address 0x6000 in external flash <<< >>> Erasing address 0x7000 in external flash <<< >>> Erasing address 0x8000 in external flash <<< ... ... >>> External flash erase complete <<< WDXS: FTC SendRsp op=4 handle=1 status=0 WDXS: Task Handler Evt=1 WDXS: FTC Send WDXS: AttHook handle=581 event=18 WDXS: Task Handler Evt=1 Ext Flash: Wrote 224 bytes @ 0x00000008 Ext Flash: Wrote 224 bytes @ 0x000000E8 Ext Flash: Wrote 224 bytes @ 0x000001C8 Ext Flash: Wrote 224 bytes @ 0x000002A8 Ext Flash: Wrote 224 bytes @ 0x00000388 Ext Flash: Wrote 224 bytes @ 0x00000468 Ext Flash: Wrote 224 bytes @ 0x00000548 Ext Flash: Wrote 224 bytes @ 0x00000628 ... ... WDXS: FTC SendRsp op=10 handle=1 status=0 WDXS: Task Handler Evt=1 WDXS: FTC Send WDXS: AttHook handle=581 event=18 WDXS: Task Handler Evt=1 Upon reception of btn 2 l command WDXS: FTC Write: len=3 WDXS: FTC Write: op=7 handle=1 WDXS: FTC VerifyReq: handle=1 CRC start addr: 0x00000000 Len: 0x00033368 CRC From File : 0x8871C78B CRC Calculated: 0x8871C78B WDXS: FTC SendRsp op=8 handle=1 status=0 WDXS: Task Handler Evt=1 WDXS: FTC Send WDXS: AttHook handle=581 event=18 WDXS: Task Handler Evt=1 Upon reception of btn 2 x command connId=1 idleMask=0x0000 dmConnSmExecute event=25 state=3 dmConnSmExecute event=29 state=4 dmConnCcbDealloc 1 smpDbGetRecord: connId: 1 type: 0 smpDbAddDevice SmpDbSetFailureCount: connId: 1 count: 0 smpSmExecute event=10 state=0 Dats got evt 40 Reseting! On successful update the device resets and connects once again.","title":"Expected Output"},{"location":"Libraries/Cordio/docs/Applications/BLE_otac_otas/#commands_1","text":"Type the desired command and parameter (if applicable) and press enter to execute the command. help Displays the available commands. echo (on|off) Enables or disables the input echo. On by default. btn (ID) (s|m|l|x) Simulates button presses. Example: \"btn 1 s\" for a short button press on button 1. pin (ConnID) (Pin Code) Used to input the pairing pin code.","title":"Commands"},{"location":"Libraries/Cordio/docs/Applications/BLE_otac_otas/#push-buttons_1","text":"Push buttons can be used to interact with the application. short press is less than 200 ms medium press is between 200 and 500 ms long press is between 500 and 1000 ms extra long press is greater than 1000 ms","title":"Push buttons"},{"location":"Libraries/Cordio/docs/Applications/BLE_otac_otas/#when-connected_1","text":"Button 2 short press: Toggle PHY Button 2 medium press : Display firmware version","title":"When connected"},{"location":"Libraries/Cordio/docs/Applications/BLE_otac_otas/#when-disconnected_1","text":"Button 1 short press: On/Off advertising Button 1 medium press: Cycle through the connection index Button 1 long press: Clear all bonding info Button 1 extra long press: Add RPAO characteristic to GAP service -- needed only when DM Privacy enabled Button 2 medium press : Display firmware version Button 2 extra long press: Enable device privacy -- start generating local RPAs every 15 minutes","title":"When disconnected"},{"location":"Libraries/Cordio/docs/Applications/BLE_periph/","text":"BLE_periph This is the simplest application that should be used when getting started. It will advertise as \"Periph\" and accepts connection requests. Board Setup Before building firmware you must select the correct value for BOARD in project.mk, e.g. \"EvKit_V1\". LEDs The red LED will indicate that an error assertion has occurred. The green LED indicates CPU activity. When the LED is on, the CPU is active, when the LED is off, the CPU is in sleep mode. Expected Output On startup: terminal: init PeriphHandlerInit Calculating database hash Periph got evt 119 Periph got evt 32 >>> Reset complete <<< dmAdvActConfig: state: 0 dmAdvActSetData: state: 0 dmAdvActStart: state: 0 HCI_LE_ADV_ENABLE_CMD_CMPL_CBACK_EVT: state: 3 dmDevPassEvtToDevPriv: event: 12, param: 33, advHandle: 0 Periph got evt 33 >>> Advertising started <<< When a connection has been made. dmConnIdByBdAddr not found dmConnCcbAlloc 1 dmConnSmExecute event=28 state=0 dmAdvConnected: state: 1 dmDevPassEvtToDevPriv: event: 13, param: 34, advHandle: 0 AttsCccInitTable connId=1 smpDbGetRecord: connId: 1 type: 1 smpDbAddDevice SmpDbGetFailureCount: connId: 1 count: 0 smpDbGetRecord: connId: 1 type: 1 smpDbAddDevice SmpDbGetPairingDisabledTime: connId: 1 period: 0 attemptMult: 0 Periph got evt 39 >>> Connection opened <<< Periph got evt 65 Periph got evt 87 attsProcMtuReq features 0x00 hciCoreTxAclStart len=7 Periph got evt 22 connId=1 idleMask=0x0004 hciCoreTxAclStart len=18 connId=1 idleMask=0x0004 hciCoreTxAclStart len=26 hciCoreTxAclStart len=34 connId=1 idleMask=0x0004 hciCoreTxAclStart len=34 attsCccMainCback connId=1 handle=19 hciCoreTxAclStart len=5 hciCoreTxAclStart len=27 hciCoreTxAclStart len=9 connId=1 idleMask=0x0004 hciCoreTxAclStart len=10 connId=1 idleMask=0x0004 hciCoreTxAclStart len=9 attsCccMainCback connId=1 handle=515 hciCoreTxAclStart len=7 hciCoreTxAclStart len=14 Commands Type the desired command and parameter (if applicable) and press enter to execute the command. help Displays the available commands. echo (on|off) Enables or disables the input echo. On by default. btn (ID) (s|m|l|x) Simulates button presses. Example: \"btn 1 s\" for a short button press on button 1. pin (ConnID) (Pin Code) Used to input the pairing pin code. Push buttons Push buttons are not implemented in this example. Stack Initialization GAP Peripheral / Slave Role Advertising interval The advertising interval is configurable in this structure. We can define multiple interverals, each with their own duration. In this case we will advertise at a short interval (96*0.625ms = 60ms) for 30 seconds. We will then transition to a long interval (1600*0.625 ms = 1000 ms) indefinetly. Longer advertising intervals will conserve power, but increase the latency when communicating with scanning devices or creating connections. /*! configurable parameters for advertising */ static const appAdvCfg_t periphAdvCfg = { { 30000, 0, 0 }, /*! Advertising durations in ms, 0 corresponds to infinite */ { 96, 1600, 0 } /*! Advertising intervals in 0.625 ms units */ }; Applications can also set a definite advertising duration with will cause the device to stop advertising at the end of the duation. The application can restart advertising by calling AppAdvStart(). Advertising data Applications can define the advertising data with this structure. This information will be broadcast in every advertising event. Each portion of the advertising data is defined by a length byte, a type byte, and the data. In this case we're advertising the flags that the device is discoverable and BR/EDR (Bluetooth Classic) is not supported. We're also advertising the device name \"Periph\". /*! advertising data, discoverable mode */ static const uint8_t periphAdvDataDisc[] = { /*! flags */ 2, /*! length */ DM_ADV_TYPE_FLAGS, /*! AD type */ DM_FLAG_LE_GENERAL_DISC | /*! flags */ DM_FLAG_LE_BREDR_NOT_SUP, /*! device name */ 7, /*! length */ DM_ADV_TYPE_LOCAL_NAME, /*! AD type */ 'P', 'e', 'r', 'i', 'p', 'h' }; GATT Server MTU size and Throughput Each layer of the stack has parameters that will bottleneck the throughput of the system. The ATT layer defines a Maximum Transmission Unit (MTU) to indiate the maximum length of an ATT packet. /*! ATT configurable parameters (increase MTU) * ATT_MAX_TRANS_TIMEOUT = 30 seconds */ static const attCfg_t periphAttCfg = { 15, /* ATT server service discovery connection idle timeout in seconds */ 241, /* desired ATT MTU */ ATT_MAX_TRANS_TIMEOUT, /* transcation timeout in seconds */ 4 /* number of queued prepare writes supported by server */ }; This MaxRxAclLen defines the maximum reassembled RX Asynchronous Connection-Orientated Logical(ACL) packet length. Packets received at the HCI layer must be buffered until the entire ACL packet has been received. Once the entire ACL packet has been received, the HCI layer will send the packet to the L2CAP layer. /*************************************************************************************************/ /*! * \\brief Set the maximum reassembled RX ACL packet length. Minimum value is 27. * * \\param len ACL packet length. * * \\return None. */ /*************************************************************************************************/ void HciSetMaxRxAclLen(uint16_t len); The MTU must be less than or equal to the MaxRxAclLen - L2C Header Length (4 bytes). /* if configured MTU size is larger than maximum RX PDU length */ if (pAttCfg->mtu > (HciGetMaxRxAclLen() - L2C_HDR_LEN)) { /* notify app about MTU misconfiguration */ attExecCallback(0, DM_ERROR_IND, 0, DM_ERR_ATT_RX_PDU_LEN_EXCEEDED, 0); } Callbacks Adding WSF events and handlers","title":"BLE_periph"},{"location":"Libraries/Cordio/docs/Applications/BLE_periph/#ble_periph","text":"This is the simplest application that should be used when getting started. It will advertise as \"Periph\" and accepts connection requests.","title":"BLE_periph"},{"location":"Libraries/Cordio/docs/Applications/BLE_periph/#board-setup","text":"Before building firmware you must select the correct value for BOARD in project.mk, e.g. \"EvKit_V1\".","title":"Board Setup"},{"location":"Libraries/Cordio/docs/Applications/BLE_periph/#leds","text":"The red LED will indicate that an error assertion has occurred. The green LED indicates CPU activity. When the LED is on, the CPU is active, when the LED is off, the CPU is in sleep mode.","title":"LEDs"},{"location":"Libraries/Cordio/docs/Applications/BLE_periph/#expected-output","text":"On startup: terminal: init PeriphHandlerInit Calculating database hash Periph got evt 119 Periph got evt 32 >>> Reset complete <<< dmAdvActConfig: state: 0 dmAdvActSetData: state: 0 dmAdvActStart: state: 0 HCI_LE_ADV_ENABLE_CMD_CMPL_CBACK_EVT: state: 3 dmDevPassEvtToDevPriv: event: 12, param: 33, advHandle: 0 Periph got evt 33 >>> Advertising started <<< When a connection has been made. dmConnIdByBdAddr not found dmConnCcbAlloc 1 dmConnSmExecute event=28 state=0 dmAdvConnected: state: 1 dmDevPassEvtToDevPriv: event: 13, param: 34, advHandle: 0 AttsCccInitTable connId=1 smpDbGetRecord: connId: 1 type: 1 smpDbAddDevice SmpDbGetFailureCount: connId: 1 count: 0 smpDbGetRecord: connId: 1 type: 1 smpDbAddDevice SmpDbGetPairingDisabledTime: connId: 1 period: 0 attemptMult: 0 Periph got evt 39 >>> Connection opened <<< Periph got evt 65 Periph got evt 87 attsProcMtuReq features 0x00 hciCoreTxAclStart len=7 Periph got evt 22 connId=1 idleMask=0x0004 hciCoreTxAclStart len=18 connId=1 idleMask=0x0004 hciCoreTxAclStart len=26 hciCoreTxAclStart len=34 connId=1 idleMask=0x0004 hciCoreTxAclStart len=34 attsCccMainCback connId=1 handle=19 hciCoreTxAclStart len=5 hciCoreTxAclStart len=27 hciCoreTxAclStart len=9 connId=1 idleMask=0x0004 hciCoreTxAclStart len=10 connId=1 idleMask=0x0004 hciCoreTxAclStart len=9 attsCccMainCback connId=1 handle=515 hciCoreTxAclStart len=7 hciCoreTxAclStart len=14","title":"Expected Output"},{"location":"Libraries/Cordio/docs/Applications/BLE_periph/#commands","text":"Type the desired command and parameter (if applicable) and press enter to execute the command. help Displays the available commands. echo (on|off) Enables or disables the input echo. On by default. btn (ID) (s|m|l|x) Simulates button presses. Example: \"btn 1 s\" for a short button press on button 1. pin (ConnID) (Pin Code) Used to input the pairing pin code.","title":"Commands"},{"location":"Libraries/Cordio/docs/Applications/BLE_periph/#push-buttons","text":"Push buttons are not implemented in this example.","title":"Push buttons"},{"location":"Libraries/Cordio/docs/Applications/BLE_periph/#stack-initialization","text":"","title":"Stack Initialization"},{"location":"Libraries/Cordio/docs/Applications/BLE_periph/#gap-peripheral-slave-role","text":"","title":"GAP Peripheral / Slave Role"},{"location":"Libraries/Cordio/docs/Applications/BLE_periph/#advertising-interval","text":"The advertising interval is configurable in this structure. We can define multiple interverals, each with their own duration. In this case we will advertise at a short interval (96*0.625ms = 60ms) for 30 seconds. We will then transition to a long interval (1600*0.625 ms = 1000 ms) indefinetly. Longer advertising intervals will conserve power, but increase the latency when communicating with scanning devices or creating connections. /*! configurable parameters for advertising */ static const appAdvCfg_t periphAdvCfg = { { 30000, 0, 0 }, /*! Advertising durations in ms, 0 corresponds to infinite */ { 96, 1600, 0 } /*! Advertising intervals in 0.625 ms units */ }; Applications can also set a definite advertising duration with will cause the device to stop advertising at the end of the duation. The application can restart advertising by calling AppAdvStart().","title":"Advertising interval"},{"location":"Libraries/Cordio/docs/Applications/BLE_periph/#advertising-data","text":"Applications can define the advertising data with this structure. This information will be broadcast in every advertising event. Each portion of the advertising data is defined by a length byte, a type byte, and the data. In this case we're advertising the flags that the device is discoverable and BR/EDR (Bluetooth Classic) is not supported. We're also advertising the device name \"Periph\". /*! advertising data, discoverable mode */ static const uint8_t periphAdvDataDisc[] = { /*! flags */ 2, /*! length */ DM_ADV_TYPE_FLAGS, /*! AD type */ DM_FLAG_LE_GENERAL_DISC | /*! flags */ DM_FLAG_LE_BREDR_NOT_SUP, /*! device name */ 7, /*! length */ DM_ADV_TYPE_LOCAL_NAME, /*! AD type */ 'P', 'e', 'r', 'i', 'p', 'h' };","title":"Advertising data"},{"location":"Libraries/Cordio/docs/Applications/BLE_periph/#gatt-server","text":"","title":"GATT Server"},{"location":"Libraries/Cordio/docs/Applications/BLE_periph/#mtu-size-and-throughput","text":"Each layer of the stack has parameters that will bottleneck the throughput of the system. The ATT layer defines a Maximum Transmission Unit (MTU) to indiate the maximum length of an ATT packet. /*! ATT configurable parameters (increase MTU) * ATT_MAX_TRANS_TIMEOUT = 30 seconds */ static const attCfg_t periphAttCfg = { 15, /* ATT server service discovery connection idle timeout in seconds */ 241, /* desired ATT MTU */ ATT_MAX_TRANS_TIMEOUT, /* transcation timeout in seconds */ 4 /* number of queued prepare writes supported by server */ }; This MaxRxAclLen defines the maximum reassembled RX Asynchronous Connection-Orientated Logical(ACL) packet length. Packets received at the HCI layer must be buffered until the entire ACL packet has been received. Once the entire ACL packet has been received, the HCI layer will send the packet to the L2CAP layer. /*************************************************************************************************/ /*! * \\brief Set the maximum reassembled RX ACL packet length. Minimum value is 27. * * \\param len ACL packet length. * * \\return None. */ /*************************************************************************************************/ void HciSetMaxRxAclLen(uint16_t len); The MTU must be less than or equal to the MaxRxAclLen - L2C Header Length (4 bytes). /* if configured MTU size is larger than maximum RX PDU length */ if (pAttCfg->mtu > (HciGetMaxRxAclLen() - L2C_HDR_LEN)) { /* notify app about MTU misconfiguration */ attExecCallback(0, DM_ERROR_IND, 0, DM_ERR_ATT_RX_PDU_LEN_EXCEEDED, 0); }","title":"MTU size and Throughput"},{"location":"Libraries/Cordio/docs/Applications/BLE_periph/#callbacks","text":"","title":"Callbacks"},{"location":"Libraries/Cordio/docs/Applications/BLE_periph/#adding-wsf-events-and-handlers","text":"","title":"Adding WSF events and handlers"},{"location":"Libraries/Cordio/docs/Applications/RF_Test/","text":"RF_Test","title":"RF_Test"},{"location":"Libraries/Cordio/docs/Applications/RF_Test/#rf_test","text":"","title":"RF_Test"},{"location":"Tools/Bluetooth/","text":"Bluetooth Tools These python tools are used for Bluetooth development and debugging. BLE_hci Host Controller Interface for controlling Bluetooth Controller devices. Uses a serial port and the HCI interface to send commands and receive events. usage: BLE_hci.py [-h] [--monPort [MONPORT]] [--serialPort [SERIALPORT]] [--baud [BAUD]] [-c COMMAND] [serial_port] [baud] Bluetooth Low Energy HCI tool. This tool is used in tandem with the BLE controller examples. This tools sends HCI commands through the serial port to the target device. It will receive and print the HCI events received from the target device. Serial port is configured as 8N1, no flow control, default baud rate of 115200. positional arguments: serial_port Serial port path or COM#, default: /dev/ttyUSB0 baud Serial port baud rate, default: 115200 options: -h, --help show this help message and exit --monPort [MONPORT] Monitor Trace Msg Serial Port path or COM#, default: --serialPort [SERIALPORT] Serial port path or COM#, default: /dev/ttyUSB0 --baud [BAUD] Serial port baud rate, default: 115200 -c COMMAND, --command COMMAND Commands to run commands: addr Set the device address adv Send the advertising commands scan Send the scanning commands and print scan reports. ctrl-c to exit init Send the initiating commands to open a connection dataLen Set the max data length sendAcl Send ACL packets sinkAcl Sink ACL packets, do not send events to host connStats Get the connection stats phy Update the PHY in the active connection reset Sends a HCI reset command listen Listen for HCI events, print to screen txTest (tx) Execute the transmitter test txTestVS (tx) Execute the transmitter test rxTest (rx) Execute the receiver test endTest (end) End the TX/RX test, print the number of correctly received packets txPower (txp) Set the TX power discon (dc) Send the command to disconnect setChMap Set the connection channel map to a given channel. cmd Send raw HCI commands readReg Read register, device performs a memcpy from address and returns the value writeReg Write register, device performs a memcpy to memory address exit (quit) Exit the program help (h) Show help message Mini RCDAT USB Control a Minicircuits attenuator over USB. RS FSL Control a Rhode and Schwartz FSL Spectrum analyzer over ethernet.","title":"Bluetooth Tools"},{"location":"Tools/Bluetooth/#bluetooth-tools","text":"These python tools are used for Bluetooth development and debugging.","title":"Bluetooth Tools"},{"location":"Tools/Bluetooth/#ble_hci","text":"Host Controller Interface for controlling Bluetooth Controller devices. Uses a serial port and the HCI interface to send commands and receive events. usage: BLE_hci.py [-h] [--monPort [MONPORT]] [--serialPort [SERIALPORT]] [--baud [BAUD]] [-c COMMAND] [serial_port] [baud] Bluetooth Low Energy HCI tool. This tool is used in tandem with the BLE controller examples. This tools sends HCI commands through the serial port to the target device. It will receive and print the HCI events received from the target device. Serial port is configured as 8N1, no flow control, default baud rate of 115200. positional arguments: serial_port Serial port path or COM#, default: /dev/ttyUSB0 baud Serial port baud rate, default: 115200 options: -h, --help show this help message and exit --monPort [MONPORT] Monitor Trace Msg Serial Port path or COM#, default: --serialPort [SERIALPORT] Serial port path or COM#, default: /dev/ttyUSB0 --baud [BAUD] Serial port baud rate, default: 115200 -c COMMAND, --command COMMAND Commands to run commands: addr Set the device address adv Send the advertising commands scan Send the scanning commands and print scan reports. ctrl-c to exit init Send the initiating commands to open a connection dataLen Set the max data length sendAcl Send ACL packets sinkAcl Sink ACL packets, do not send events to host connStats Get the connection stats phy Update the PHY in the active connection reset Sends a HCI reset command listen Listen for HCI events, print to screen txTest (tx) Execute the transmitter test txTestVS (tx) Execute the transmitter test rxTest (rx) Execute the receiver test endTest (end) End the TX/RX test, print the number of correctly received packets txPower (txp) Set the TX power discon (dc) Send the command to disconnect setChMap Set the connection channel map to a given channel. cmd Send raw HCI commands readReg Read register, device performs a memcpy from address and returns the value writeReg Write register, device performs a memcpy to memory address exit (quit) Exit the program help (h) Show help message","title":"BLE_hci"},{"location":"Tools/Bluetooth/#mini-rcdat-usb","text":"Control a Minicircuits attenuator over USB.","title":"Mini RCDAT USB"},{"location":"Tools/Bluetooth/#rs-fsl","text":"Control a Rhode and Schwartz FSL Spectrum analyzer over ethernet.","title":"RS FSL"}]}